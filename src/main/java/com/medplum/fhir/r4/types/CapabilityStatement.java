/*
 * Generated by com.medplum.generator.Generator
 * Do not edit manually.
 */

package com.medplum.fhir.r4.types;

import jakarta.json.JsonObject;

import com.medplum.fhir.r4.FhirPropertyNames;

/**
 * A Capability Statement documents a set of capabilities (behaviors) of
 * a FHIR Server for a particular version of FHIR that may be used as a
 * statement of actual server functionality or a statement of required or
 * desired server implementation.
 */
public class CapabilityStatement extends DomainResource {
    public static final String RESOURCE_TYPE = "CapabilityStatement";

    public static Builder create() {
        return new Builder();
    }

    public static Builder create(final JsonObject data) {
        return new Builder(data);
    }

    public CapabilityStatement(final JsonObject data) {
        super(data);
    }

    /**
     * An absolute URI that is used to identify this capability statement
     * when it is referenced in a specification, model, design or an
     * instance; also called its canonical identifier. This SHOULD be
     * globally unique and SHOULD be a literal address at which at which an
     * authoritative instance of this capability statement is (or will be)
     * published. This URL can be the target of a canonical reference. It
     * SHALL remain the same when the capability statement is stored on
     * different servers.
     */
    public java.net.URI url() {
        return getUri(FhirPropertyNames.PROPERTY_URL);
    }

    /**
     * The identifier that is used to identify this version of the capability
     * statement when it is referenced in a specification, model, design or
     * instance. This is an arbitrary value managed by the capability
     * statement author and is not expected to be globally unique. For
     * example, it might be a timestamp (e.g. yyyymmdd) if a managed version
     * is not available. There is also no expectation that versions can be
     * placed in a lexicographical sequence.
     */
    public String version() {
        return getString(FhirPropertyNames.PROPERTY_VERSION);
    }

    /**
     * A natural language name identifying the capability statement. This
     * name should be usable as an identifier for the module by machine
     * processing applications such as code generation.
     */
    public String name() {
        return getString(FhirPropertyNames.PROPERTY_NAME);
    }

    /**
     * A short, descriptive, user-friendly title for the capability
     * statement.
     */
    public String title() {
        return getString(FhirPropertyNames.PROPERTY_TITLE);
    }

    /**
     * The status of this capability statement. Enables tracking the
     * life-cycle of the content.
     */
    public String status() {
        return getString(FhirPropertyNames.PROPERTY_STATUS);
    }

    /**
     * A Boolean value to indicate that this capability statement is authored
     * for testing purposes (or education/evaluation/marketing) and is not
     * intended to be used for genuine usage.
     */
    public Boolean experimental() {
        return data.getBoolean(FhirPropertyNames.PROPERTY_EXPERIMENTAL);
    }

    /**
     * The date  (and optionally time) when the capability statement was
     * published. The date must change when the business version changes and
     * it must change if the status code changes. In addition, it should
     * change when the substantive content of the capability statement
     * changes.
     */
    public java.time.Instant date() {
        return getInstant(FhirPropertyNames.PROPERTY_DATE);
    }

    /**
     * The name of the organization or individual that published the
     * capability statement.
     */
    public String publisher() {
        return getString(FhirPropertyNames.PROPERTY_PUBLISHER);
    }

    /**
     * Contact details to assist a user in finding and communicating with the
     * publisher.
     */
    public java.util.List<ContactDetail> contact() {
        return getList(ContactDetail.class, FhirPropertyNames.PROPERTY_CONTACT);
    }

    /**
     * A free text natural language description of the capability statement
     * from a consumer's perspective. Typically, this is used when the
     * capability statement describes a desired rather than an actual
     * solution, for example as a formal expression of requirements as part
     * of an RFP.
     */
    public String description() {
        return getString(FhirPropertyNames.PROPERTY_DESCRIPTION);
    }

    /**
     * The content was developed with a focus and intent of supporting the
     * contexts that are listed. These contexts may be general categories
     * (gender, age, ...) or may be references to specific programs
     * (insurance plans, studies, ...) and may be used to assist with
     * indexing and searching for appropriate capability statement instances.
     */
    public java.util.List<UsageContext> useContext() {
        return getList(UsageContext.class, FhirPropertyNames.PROPERTY_USE_CONTEXT);
    }

    /**
     * A legal or geographic region in which the capability statement is
     * intended to be used.
     */
    public java.util.List<CodeableConcept> jurisdiction() {
        return getList(CodeableConcept.class, FhirPropertyNames.PROPERTY_JURISDICTION);
    }

    /**
     * Explanation of why this capability statement is needed and why it has
     * been designed as it has.
     */
    public String purpose() {
        return getString(FhirPropertyNames.PROPERTY_PURPOSE);
    }

    /**
     * A copyright statement relating to the capability statement and/or its
     * contents. Copyright statements are generally legal restrictions on the
     * use and publishing of the capability statement.
     */
    public String copyright() {
        return getString(FhirPropertyNames.PROPERTY_COPYRIGHT);
    }

    /**
     * The way that this statement is intended to be used, to describe an
     * actual running instance of software, a particular product (kind, not
     * instance of software) or a class of implementation (e.g. a desired
     * purchase).
     */
    public String kind() {
        return getString(FhirPropertyNames.PROPERTY_KIND);
    }

    /**
     * Reference to a canonical URL of another CapabilityStatement that this
     * software implements. This capability statement is a published API
     * description that corresponds to a business service. The server may
     * actually implement a subset of the capability statement it claims to
     * implement, so the capability statement must specify the full
     * capability details.
     */
    public java.util.List<String> instantiates() {
        return getList(String.class, FhirPropertyNames.PROPERTY_INSTANTIATES);
    }

    /**
     * Reference to a canonical URL of another CapabilityStatement that this
     * software adds to. The capability statement automatically includes
     * everything in the other statement, and it is not duplicated, though
     * the server may repeat the same resources, interactions and operations
     * to add additional details to them.
     */
    public java.util.List<String> imports() {
        return getList(String.class, FhirPropertyNames.PROPERTY_IMPORTS);
    }

    /**
     * Software that is covered by this capability statement.  It is used
     * when the capability statement describes the capabilities of a
     * particular software version, independent of an installation.
     */
    public CapabilityStatementSoftware software() {
        return getObject(CapabilityStatementSoftware.class, FhirPropertyNames.PROPERTY_SOFTWARE);
    }

    /**
     * Identifies a specific implementation instance that is described by the
     * capability statement - i.e. a particular installation, rather than the
     * capabilities of a software program.
     */
    public CapabilityStatementImplementation implementation() {
        return getObject(CapabilityStatementImplementation.class, FhirPropertyNames.PROPERTY_IMPLEMENTATION);
    }

    /**
     * The version of the FHIR specification that this CapabilityStatement
     * describes (which SHALL be the same as the FHIR version of the
     * CapabilityStatement itself). There is no default value.
     */
    public String fhirVersion() {
        return getString(FhirPropertyNames.PROPERTY_FHIR_VERSION);
    }

    /**
     * A list of the formats supported by this implementation using their
     * content types.
     */
    public java.util.List<String> format() {
        return getList(String.class, FhirPropertyNames.PROPERTY_FORMAT);
    }

    /**
     * A list of the patch formats supported by this implementation using
     * their content types.
     */
    public java.util.List<String> patchFormat() {
        return getList(String.class, FhirPropertyNames.PROPERTY_PATCH_FORMAT);
    }

    /**
     * A list of implementation guides that the server does (or should)
     * support in their entirety.
     */
    public java.util.List<String> implementationGuide() {
        return getList(String.class, FhirPropertyNames.PROPERTY_IMPLEMENTATION_GUIDE);
    }

    /**
     * A definition of the restful capabilities of the solution, if any.
     */
    public java.util.List<CapabilityStatementRest> rest() {
        return getList(CapabilityStatementRest.class, FhirPropertyNames.PROPERTY_REST);
    }

    /**
     * A description of the messaging capabilities of the solution.
     */
    public java.util.List<CapabilityStatementMessaging> messaging() {
        return getList(CapabilityStatementMessaging.class, FhirPropertyNames.PROPERTY_MESSAGING);
    }

    /**
     * A document definition.
     */
    public java.util.List<CapabilityStatementDocument> document() {
        return getList(CapabilityStatementDocument.class, FhirPropertyNames.PROPERTY_DOCUMENT);
    }

    public static final class Builder extends DomainResource.Builder<CapabilityStatement, CapabilityStatement.Builder> {

        private Builder() {
            super(RESOURCE_TYPE);
        }

        private Builder(final JsonObject data) {
            super(RESOURCE_TYPE, data);
        }

        public Builder url(final java.net.URI url) {
            b.add(FhirPropertyNames.PROPERTY_URL, url.toString());
            return this;
        }

        public Builder version(final String version) {
            b.add(FhirPropertyNames.PROPERTY_VERSION, version);
            return this;
        }

        public Builder name(final String name) {
            b.add(FhirPropertyNames.PROPERTY_NAME, name);
            return this;
        }

        public Builder title(final String title) {
            b.add(FhirPropertyNames.PROPERTY_TITLE, title);
            return this;
        }

        public Builder status(final String status) {
            b.add(FhirPropertyNames.PROPERTY_STATUS, status);
            return this;
        }

        public Builder experimental(final Boolean experimental) {
            b.add(FhirPropertyNames.PROPERTY_EXPERIMENTAL, experimental);
            return this;
        }

        public Builder date(final java.time.Instant date) {
            b.add(FhirPropertyNames.PROPERTY_DATE, date.toString());
            return this;
        }

        public Builder publisher(final String publisher) {
            b.add(FhirPropertyNames.PROPERTY_PUBLISHER, publisher);
            return this;
        }

        public Builder contact(final java.util.List<ContactDetail> contact) {
            b.add(FhirPropertyNames.PROPERTY_CONTACT, FhirObject.toArray(contact));
            return this;
        }

        public Builder description(final String description) {
            b.add(FhirPropertyNames.PROPERTY_DESCRIPTION, description);
            return this;
        }

        public Builder useContext(final java.util.List<UsageContext> useContext) {
            b.add(FhirPropertyNames.PROPERTY_USE_CONTEXT, FhirObject.toArray(useContext));
            return this;
        }

        public Builder jurisdiction(final java.util.List<CodeableConcept> jurisdiction) {
            b.add(FhirPropertyNames.PROPERTY_JURISDICTION, FhirObject.toArray(jurisdiction));
            return this;
        }

        public Builder purpose(final String purpose) {
            b.add(FhirPropertyNames.PROPERTY_PURPOSE, purpose);
            return this;
        }

        public Builder copyright(final String copyright) {
            b.add(FhirPropertyNames.PROPERTY_COPYRIGHT, copyright);
            return this;
        }

        public Builder kind(final String kind) {
            b.add(FhirPropertyNames.PROPERTY_KIND, kind);
            return this;
        }

        public Builder instantiates(final java.util.List<String> instantiates) {
            b.add(FhirPropertyNames.PROPERTY_INSTANTIATES, FhirObject.toStringArray(instantiates));
            return this;
        }

        public Builder imports(final java.util.List<String> imports) {
            b.add(FhirPropertyNames.PROPERTY_IMPORTS, FhirObject.toStringArray(imports));
            return this;
        }

        public Builder software(final CapabilityStatementSoftware software) {
            b.add(FhirPropertyNames.PROPERTY_SOFTWARE, software);
            return this;
        }

        public Builder implementation(final CapabilityStatementImplementation implementation) {
            b.add(FhirPropertyNames.PROPERTY_IMPLEMENTATION, implementation);
            return this;
        }

        public Builder fhirVersion(final String fhirVersion) {
            b.add(FhirPropertyNames.PROPERTY_FHIR_VERSION, fhirVersion);
            return this;
        }

        public Builder format(final java.util.List<String> format) {
            b.add(FhirPropertyNames.PROPERTY_FORMAT, FhirObject.toStringArray(format));
            return this;
        }

        public Builder patchFormat(final java.util.List<String> patchFormat) {
            b.add(FhirPropertyNames.PROPERTY_PATCH_FORMAT, FhirObject.toStringArray(patchFormat));
            return this;
        }

        public Builder implementationGuide(final java.util.List<String> implementationGuide) {
            b.add(FhirPropertyNames.PROPERTY_IMPLEMENTATION_GUIDE, FhirObject.toStringArray(implementationGuide));
            return this;
        }

        public Builder rest(final java.util.List<CapabilityStatementRest> rest) {
            b.add(FhirPropertyNames.PROPERTY_REST, FhirObject.toArray(rest));
            return this;
        }

        public Builder messaging(final java.util.List<CapabilityStatementMessaging> messaging) {
            b.add(FhirPropertyNames.PROPERTY_MESSAGING, FhirObject.toArray(messaging));
            return this;
        }

        public Builder document(final java.util.List<CapabilityStatementDocument> document) {
            b.add(FhirPropertyNames.PROPERTY_DOCUMENT, FhirObject.toArray(document));
            return this;
        }

        public CapabilityStatement build() {
            return new CapabilityStatement(b.build());
        }
    }

    /**
     * A Capability Statement documents a set of capabilities (behaviors) of
     * a FHIR Server for a particular version of FHIR that may be used as a
     * statement of actual server functionality or a statement of required or
     * desired server implementation.
     */
    public static class CapabilityStatementDocument extends FhirObject {
        public static final String RESOURCE_TYPE = "CapabilityStatementDocument";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public CapabilityStatementDocument(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Mode of this document declaration - whether an application is a
         * producer or consumer.
         */
        public String mode() {
            return getString(FhirPropertyNames.PROPERTY_MODE);
        }

        /**
         * A description of how the application supports or uses the specified
         * document profile.  For example, when documents are created, what
         * action is taken with consumed documents, etc.
         */
        public String documentation() {
            return getString(FhirPropertyNames.PROPERTY_DOCUMENTATION);
        }

        /**
         * A profile on the document Bundle that constrains which resources are
         * present, and their contents.
         */
        public String profile() {
            return getString(FhirPropertyNames.PROPERTY_PROFILE);
        }

        public static final class Builder extends FhirObject.Builder<CapabilityStatementDocument, CapabilityStatementDocument.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder mode(final String mode) {
                b.add(FhirPropertyNames.PROPERTY_MODE, mode);
                return this;
            }

            public Builder documentation(final String documentation) {
                b.add(FhirPropertyNames.PROPERTY_DOCUMENTATION, documentation);
                return this;
            }

            public Builder profile(final String profile) {
                b.add(FhirPropertyNames.PROPERTY_PROFILE, profile);
                return this;
            }

            public CapabilityStatementDocument build() {
                return new CapabilityStatementDocument(b.build());
            }
        }
    }

    /**
     * A Capability Statement documents a set of capabilities (behaviors) of
     * a FHIR Server for a particular version of FHIR that may be used as a
     * statement of actual server functionality or a statement of required or
     * desired server implementation.
     */
    public static class CapabilityStatementEndpoint extends FhirObject {
        public static final String RESOURCE_TYPE = "CapabilityStatementEndpoint";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public CapabilityStatementEndpoint(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * A list of the messaging transport protocol(s) identifiers, supported
         * by this endpoint.
         */
        public Coding protocol() {
            return getObject(Coding.class, FhirPropertyNames.PROPERTY_PROTOCOL);
        }

        /**
         * The network address of the endpoint. For solutions that do not use
         * network addresses for routing, it can be just an identifier.
         */
        public java.net.URI address() {
            return getUri(FhirPropertyNames.PROPERTY_ADDRESS);
        }

        public static final class Builder extends FhirObject.Builder<CapabilityStatementEndpoint, CapabilityStatementEndpoint.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder protocol(final Coding protocol) {
                b.add(FhirPropertyNames.PROPERTY_PROTOCOL, protocol);
                return this;
            }

            public Builder address(final java.net.URI address) {
                b.add(FhirPropertyNames.PROPERTY_ADDRESS, address.toString());
                return this;
            }

            public CapabilityStatementEndpoint build() {
                return new CapabilityStatementEndpoint(b.build());
            }
        }
    }

    /**
     * A Capability Statement documents a set of capabilities (behaviors) of
     * a FHIR Server for a particular version of FHIR that may be used as a
     * statement of actual server functionality or a statement of required or
     * desired server implementation.
     */
    public static class CapabilityStatementImplementation extends FhirObject {
        public static final String RESOURCE_TYPE = "CapabilityStatementImplementation";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public CapabilityStatementImplementation(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Information about the specific installation that this capability
         * statement relates to.
         */
        public String description() {
            return getString(FhirPropertyNames.PROPERTY_DESCRIPTION);
        }

        /**
         * An absolute base URL for the implementation.  This forms the base for
         * REST interfaces as well as the mailbox and document interfaces.
         */
        public java.net.URI url() {
            return getUri(FhirPropertyNames.PROPERTY_URL);
        }

        /**
         * The organization responsible for the management of the instance and
         * oversight of the data on the server at the specified URL.
         */
        public Reference custodian() {
            return getObject(Reference.class, FhirPropertyNames.PROPERTY_CUSTODIAN);
        }

        public static final class Builder extends FhirObject.Builder<CapabilityStatementImplementation, CapabilityStatementImplementation.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder description(final String description) {
                b.add(FhirPropertyNames.PROPERTY_DESCRIPTION, description);
                return this;
            }

            public Builder url(final java.net.URI url) {
                b.add(FhirPropertyNames.PROPERTY_URL, url.toString());
                return this;
            }

            public Builder custodian(final Reference custodian) {
                b.add(FhirPropertyNames.PROPERTY_CUSTODIAN, custodian);
                return this;
            }

            public CapabilityStatementImplementation build() {
                return new CapabilityStatementImplementation(b.build());
            }
        }
    }

    /**
     * A Capability Statement documents a set of capabilities (behaviors) of
     * a FHIR Server for a particular version of FHIR that may be used as a
     * statement of actual server functionality or a statement of required or
     * desired server implementation.
     */
    public static class CapabilityStatementInteraction extends FhirObject {
        public static final String RESOURCE_TYPE = "CapabilityStatementInteraction";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public CapabilityStatementInteraction(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Coded identifier of the operation, supported by the system resource.
         */
        public String code() {
            return getString(FhirPropertyNames.PROPERTY_CODE);
        }

        /**
         * Guidance specific to the implementation of this operation, such as
         * 'delete is a logical delete' or 'updates are only allowed with version
         * id' or 'creates permitted from pre-authorized certificates only'.
         */
        public String documentation() {
            return getString(FhirPropertyNames.PROPERTY_DOCUMENTATION);
        }

        public static final class Builder extends FhirObject.Builder<CapabilityStatementInteraction, CapabilityStatementInteraction.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder code(final String code) {
                b.add(FhirPropertyNames.PROPERTY_CODE, code);
                return this;
            }

            public Builder documentation(final String documentation) {
                b.add(FhirPropertyNames.PROPERTY_DOCUMENTATION, documentation);
                return this;
            }

            public CapabilityStatementInteraction build() {
                return new CapabilityStatementInteraction(b.build());
            }
        }
    }

    /**
     * A Capability Statement documents a set of capabilities (behaviors) of
     * a FHIR Server for a particular version of FHIR that may be used as a
     * statement of actual server functionality or a statement of required or
     * desired server implementation.
     */
    public static class CapabilityStatementInteraction1 extends FhirObject {
        public static final String RESOURCE_TYPE = "CapabilityStatementInteraction1";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public CapabilityStatementInteraction1(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * A coded identifier of the operation, supported by the system.
         */
        public String code() {
            return getString(FhirPropertyNames.PROPERTY_CODE);
        }

        /**
         * Guidance specific to the implementation of this operation, such as
         * limitations on the kind of transactions allowed, or information about
         * system wide search is implemented.
         */
        public String documentation() {
            return getString(FhirPropertyNames.PROPERTY_DOCUMENTATION);
        }

        public static final class Builder extends FhirObject.Builder<CapabilityStatementInteraction1, CapabilityStatementInteraction1.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder code(final String code) {
                b.add(FhirPropertyNames.PROPERTY_CODE, code);
                return this;
            }

            public Builder documentation(final String documentation) {
                b.add(FhirPropertyNames.PROPERTY_DOCUMENTATION, documentation);
                return this;
            }

            public CapabilityStatementInteraction1 build() {
                return new CapabilityStatementInteraction1(b.build());
            }
        }
    }

    /**
     * A Capability Statement documents a set of capabilities (behaviors) of
     * a FHIR Server for a particular version of FHIR that may be used as a
     * statement of actual server functionality or a statement of required or
     * desired server implementation.
     */
    public static class CapabilityStatementMessaging extends FhirObject {
        public static final String RESOURCE_TYPE = "CapabilityStatementMessaging";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public CapabilityStatementMessaging(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * An endpoint (network accessible address) to which messages and/or
         * replies are to be sent.
         */
        public java.util.List<CapabilityStatementEndpoint> endpoint() {
            return getList(CapabilityStatementEndpoint.class, FhirPropertyNames.PROPERTY_ENDPOINT);
        }

        /**
         * Length if the receiver's reliable messaging cache in minutes (if a
         * receiver) or how long the cache length on the receiver should be (if a
         * sender).
         */
        public Integer reliableCache() {
            return data.getInt(FhirPropertyNames.PROPERTY_RELIABLE_CACHE);
        }

        /**
         * Documentation about the system's messaging capabilities for this
         * endpoint not otherwise documented by the capability statement.  For
         * example, the process for becoming an authorized messaging exchange
         * partner.
         */
        public String documentation() {
            return getString(FhirPropertyNames.PROPERTY_DOCUMENTATION);
        }

        /**
         * References to message definitions for messages this system can send or
         * receive.
         */
        public java.util.List<CapabilityStatementSupportedMessage> supportedMessage() {
            return getList(CapabilityStatementSupportedMessage.class, FhirPropertyNames.PROPERTY_SUPPORTED_MESSAGE);
        }

        public static final class Builder extends FhirObject.Builder<CapabilityStatementMessaging, CapabilityStatementMessaging.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder endpoint(final java.util.List<CapabilityStatementEndpoint> endpoint) {
                b.add(FhirPropertyNames.PROPERTY_ENDPOINT, FhirObject.toArray(endpoint));
                return this;
            }

            public Builder reliableCache(final Integer reliableCache) {
                b.add(FhirPropertyNames.PROPERTY_RELIABLE_CACHE, reliableCache);
                return this;
            }

            public Builder documentation(final String documentation) {
                b.add(FhirPropertyNames.PROPERTY_DOCUMENTATION, documentation);
                return this;
            }

            public Builder supportedMessage(final java.util.List<CapabilityStatementSupportedMessage> supportedMessage) {
                b.add(FhirPropertyNames.PROPERTY_SUPPORTED_MESSAGE, FhirObject.toArray(supportedMessage));
                return this;
            }

            public CapabilityStatementMessaging build() {
                return new CapabilityStatementMessaging(b.build());
            }
        }
    }

    /**
     * A Capability Statement documents a set of capabilities (behaviors) of
     * a FHIR Server for a particular version of FHIR that may be used as a
     * statement of actual server functionality or a statement of required or
     * desired server implementation.
     */
    public static class CapabilityStatementOperation extends FhirObject {
        public static final String RESOURCE_TYPE = "CapabilityStatementOperation";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public CapabilityStatementOperation(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * The name of the operation or query. For an operation, this is the name
         * prefixed with $ and used in the URL. For a query, this is the name
         * used in the _query parameter when the query is called.
         */
        public String name() {
            return getString(FhirPropertyNames.PROPERTY_NAME);
        }

        /**
         * Where the formal definition can be found. If a server references the
         * base definition of an Operation (i.e. from the specification itself
         * such as
         * ```http://hl7.org/fhir/OperationDefinition/ValueSet-expand```), that
         * means it supports the full capabilities of the operation - e.g. both
         * GET and POST invocation.  If it only supports a subset, it must define
         * its own custom [[[OperationDefinition]]] with a 'base' of the original
         * OperationDefinition.  The custom definition would describe the
         * specific subset of functionality supported.
         */
        public String definition() {
            return getString(FhirPropertyNames.PROPERTY_DEFINITION);
        }

        /**
         * Documentation that describes anything special about the operation
         * behavior, possibly detailing different behavior for system, type and
         * instance-level invocation of the operation.
         */
        public String documentation() {
            return getString(FhirPropertyNames.PROPERTY_DOCUMENTATION);
        }

        public static final class Builder extends FhirObject.Builder<CapabilityStatementOperation, CapabilityStatementOperation.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder name(final String name) {
                b.add(FhirPropertyNames.PROPERTY_NAME, name);
                return this;
            }

            public Builder definition(final String definition) {
                b.add(FhirPropertyNames.PROPERTY_DEFINITION, definition);
                return this;
            }

            public Builder documentation(final String documentation) {
                b.add(FhirPropertyNames.PROPERTY_DOCUMENTATION, documentation);
                return this;
            }

            public CapabilityStatementOperation build() {
                return new CapabilityStatementOperation(b.build());
            }
        }
    }

    /**
     * A Capability Statement documents a set of capabilities (behaviors) of
     * a FHIR Server for a particular version of FHIR that may be used as a
     * statement of actual server functionality or a statement of required or
     * desired server implementation.
     */
    public static class CapabilityStatementResource extends FhirObject {
        public static final String RESOURCE_TYPE = "CapabilityStatementResource";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public CapabilityStatementResource(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * A type of resource exposed via the restful interface.
         */
        public String type() {
            return getString(FhirPropertyNames.PROPERTY_TYPE);
        }

        /**
         * A specification of the profile that describes the solution's overall
         * support for the resource, including any constraints on cardinality,
         * bindings, lengths or other limitations. See further discussion in
         * [Using Profiles](profiling.html#profile-uses).
         */
        public String profile() {
            return getString(FhirPropertyNames.PROPERTY_PROFILE);
        }

        /**
         * A list of profiles that represent different use cases supported by the
         * system. For a server, &quot;supported by the system&quot; means the system
         * hosts/produces a set of resources that are conformant to a particular
         * profile, and allows clients that use its services to search using this
         * profile and to find appropriate data. For a client, it means the
         * system will search by this profile and process data according to the
         * guidance implicit in the profile. See further discussion in [Using
         * Profiles](profiling.html#profile-uses).
         */
        public java.util.List<String> supportedProfile() {
            return getList(String.class, FhirPropertyNames.PROPERTY_SUPPORTED_PROFILE);
        }

        /**
         * Additional information about the resource type used by the system.
         */
        public String documentation() {
            return getString(FhirPropertyNames.PROPERTY_DOCUMENTATION);
        }

        /**
         * Identifies a restful operation supported by the solution.
         */
        public java.util.List<CapabilityStatementInteraction> interaction() {
            return getList(CapabilityStatementInteraction.class, FhirPropertyNames.PROPERTY_INTERACTION);
        }

        /**
         * This field is set to no-version to specify that the system does not
         * support (server) or use (client) versioning for this resource type. If
         * this has some other value, the server must at least correctly track
         * and populate the versionId meta-property on resources. If the value is
         * 'versioned-update', then the server supports all the versioning
         * features, including using e-tags for version integrity in the API.
         */
        public String versioning() {
            return getString(FhirPropertyNames.PROPERTY_VERSIONING);
        }

        /**
         * A flag for whether the server is able to return past versions as part
         * of the vRead operation.
         */
        public Boolean readHistory() {
            return data.getBoolean(FhirPropertyNames.PROPERTY_READ_HISTORY);
        }

        /**
         * A flag to indicate that the server allows or needs to allow the client
         * to create new identities on the server (that is, the client PUTs to a
         * location where there is no existing resource). Allowing this operation
         * means that the server allows the client to create new identities on
         * the server.
         */
        public Boolean updateCreate() {
            return data.getBoolean(FhirPropertyNames.PROPERTY_UPDATE_CREATE);
        }

        /**
         * A flag that indicates that the server supports conditional create.
         */
        public Boolean conditionalCreate() {
            return data.getBoolean(FhirPropertyNames.PROPERTY_CONDITIONAL_CREATE);
        }

        /**
         * A code that indicates how the server supports conditional read.
         */
        public String conditionalRead() {
            return getString(FhirPropertyNames.PROPERTY_CONDITIONAL_READ);
        }

        /**
         * A flag that indicates that the server supports conditional update.
         */
        public Boolean conditionalUpdate() {
            return data.getBoolean(FhirPropertyNames.PROPERTY_CONDITIONAL_UPDATE);
        }

        /**
         * A code that indicates how the server supports conditional delete.
         */
        public String conditionalDelete() {
            return getString(FhirPropertyNames.PROPERTY_CONDITIONAL_DELETE);
        }

        /**
         * A set of flags that defines how references are supported.
         */
        public java.util.List<String> referencePolicy() {
            return getList(String.class, FhirPropertyNames.PROPERTY_REFERENCE_POLICY);
        }

        /**
         * A list of _include values supported by the server.
         */
        public java.util.List<String> searchInclude() {
            return getList(String.class, FhirPropertyNames.PROPERTY_SEARCH_INCLUDE);
        }

        /**
         * A list of _revinclude (reverse include) values supported by the
         * server.
         */
        public java.util.List<String> searchRevInclude() {
            return getList(String.class, FhirPropertyNames.PROPERTY_SEARCH_REV_INCLUDE);
        }

        /**
         * Search parameters for implementations to support and/or make use of -
         * either references to ones defined in the specification, or additional
         * ones defined for/by the implementation.
         */
        public java.util.List<CapabilityStatementSearchParam> searchParam() {
            return getList(CapabilityStatementSearchParam.class, FhirPropertyNames.PROPERTY_SEARCH_PARAM);
        }

        /**
         * Definition of an operation or a named query together with its
         * parameters and their meaning and type. Consult the definition of the
         * operation for details about how to invoke the operation, and the
         * parameters.
         */
        public java.util.List<CapabilityStatementOperation> operation() {
            return getList(CapabilityStatementOperation.class, FhirPropertyNames.PROPERTY_OPERATION);
        }

        public static final class Builder extends FhirObject.Builder<CapabilityStatementResource, CapabilityStatementResource.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder type(final String type) {
                b.add(FhirPropertyNames.PROPERTY_TYPE, type);
                return this;
            }

            public Builder profile(final String profile) {
                b.add(FhirPropertyNames.PROPERTY_PROFILE, profile);
                return this;
            }

            public Builder supportedProfile(final java.util.List<String> supportedProfile) {
                b.add(FhirPropertyNames.PROPERTY_SUPPORTED_PROFILE, FhirObject.toStringArray(supportedProfile));
                return this;
            }

            public Builder documentation(final String documentation) {
                b.add(FhirPropertyNames.PROPERTY_DOCUMENTATION, documentation);
                return this;
            }

            public Builder interaction(final java.util.List<CapabilityStatementInteraction> interaction) {
                b.add(FhirPropertyNames.PROPERTY_INTERACTION, FhirObject.toArray(interaction));
                return this;
            }

            public Builder versioning(final String versioning) {
                b.add(FhirPropertyNames.PROPERTY_VERSIONING, versioning);
                return this;
            }

            public Builder readHistory(final Boolean readHistory) {
                b.add(FhirPropertyNames.PROPERTY_READ_HISTORY, readHistory);
                return this;
            }

            public Builder updateCreate(final Boolean updateCreate) {
                b.add(FhirPropertyNames.PROPERTY_UPDATE_CREATE, updateCreate);
                return this;
            }

            public Builder conditionalCreate(final Boolean conditionalCreate) {
                b.add(FhirPropertyNames.PROPERTY_CONDITIONAL_CREATE, conditionalCreate);
                return this;
            }

            public Builder conditionalRead(final String conditionalRead) {
                b.add(FhirPropertyNames.PROPERTY_CONDITIONAL_READ, conditionalRead);
                return this;
            }

            public Builder conditionalUpdate(final Boolean conditionalUpdate) {
                b.add(FhirPropertyNames.PROPERTY_CONDITIONAL_UPDATE, conditionalUpdate);
                return this;
            }

            public Builder conditionalDelete(final String conditionalDelete) {
                b.add(FhirPropertyNames.PROPERTY_CONDITIONAL_DELETE, conditionalDelete);
                return this;
            }

            public Builder referencePolicy(final java.util.List<String> referencePolicy) {
                b.add(FhirPropertyNames.PROPERTY_REFERENCE_POLICY, FhirObject.toStringArray(referencePolicy));
                return this;
            }

            public Builder searchInclude(final java.util.List<String> searchInclude) {
                b.add(FhirPropertyNames.PROPERTY_SEARCH_INCLUDE, FhirObject.toStringArray(searchInclude));
                return this;
            }

            public Builder searchRevInclude(final java.util.List<String> searchRevInclude) {
                b.add(FhirPropertyNames.PROPERTY_SEARCH_REV_INCLUDE, FhirObject.toStringArray(searchRevInclude));
                return this;
            }

            public Builder searchParam(final java.util.List<CapabilityStatementSearchParam> searchParam) {
                b.add(FhirPropertyNames.PROPERTY_SEARCH_PARAM, FhirObject.toArray(searchParam));
                return this;
            }

            public Builder operation(final java.util.List<CapabilityStatementOperation> operation) {
                b.add(FhirPropertyNames.PROPERTY_OPERATION, FhirObject.toArray(operation));
                return this;
            }

            public CapabilityStatementResource build() {
                return new CapabilityStatementResource(b.build());
            }
        }
    }

    /**
     * A Capability Statement documents a set of capabilities (behaviors) of
     * a FHIR Server for a particular version of FHIR that may be used as a
     * statement of actual server functionality or a statement of required or
     * desired server implementation.
     */
    public static class CapabilityStatementRest extends FhirObject {
        public static final String RESOURCE_TYPE = "CapabilityStatementRest";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public CapabilityStatementRest(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Identifies whether this portion of the statement is describing the
         * ability to initiate or receive restful operations.
         */
        public String mode() {
            return getString(FhirPropertyNames.PROPERTY_MODE);
        }

        /**
         * Information about the system's restful capabilities that apply across
         * all applications, such as security.
         */
        public String documentation() {
            return getString(FhirPropertyNames.PROPERTY_DOCUMENTATION);
        }

        /**
         * Information about security implementation from an interface
         * perspective - what a client needs to know.
         */
        public CapabilityStatementSecurity security() {
            return getObject(CapabilityStatementSecurity.class, FhirPropertyNames.PROPERTY_SECURITY);
        }

        /**
         * A specification of the restful capabilities of the solution for a
         * specific resource type.
         */
        public java.util.List<CapabilityStatementResource> resource() {
            return getList(CapabilityStatementResource.class, FhirPropertyNames.PROPERTY_RESOURCE);
        }

        /**
         * A specification of restful operations supported by the system.
         */
        public java.util.List<CapabilityStatementInteraction1> interaction() {
            return getList(CapabilityStatementInteraction1.class, FhirPropertyNames.PROPERTY_INTERACTION);
        }

        /**
         * Search parameters that are supported for searching all resources for
         * implementations to support and/or make use of - either references to
         * ones defined in the specification, or additional ones defined for/by
         * the implementation.
         */
        public java.util.List<CapabilityStatementSearchParam> searchParam() {
            return getList(CapabilityStatementSearchParam.class, FhirPropertyNames.PROPERTY_SEARCH_PARAM);
        }

        /**
         * Definition of an operation or a named query together with its
         * parameters and their meaning and type.
         */
        public java.util.List<CapabilityStatementOperation> operation() {
            return getList(CapabilityStatementOperation.class, FhirPropertyNames.PROPERTY_OPERATION);
        }

        /**
         * An absolute URI which is a reference to the definition of a
         * compartment that the system supports. The reference is to a
         * CompartmentDefinition resource by its canonical URL .
         */
        public java.util.List<String> compartment() {
            return getList(String.class, FhirPropertyNames.PROPERTY_COMPARTMENT);
        }

        public static final class Builder extends FhirObject.Builder<CapabilityStatementRest, CapabilityStatementRest.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder mode(final String mode) {
                b.add(FhirPropertyNames.PROPERTY_MODE, mode);
                return this;
            }

            public Builder documentation(final String documentation) {
                b.add(FhirPropertyNames.PROPERTY_DOCUMENTATION, documentation);
                return this;
            }

            public Builder security(final CapabilityStatementSecurity security) {
                b.add(FhirPropertyNames.PROPERTY_SECURITY, security);
                return this;
            }

            public Builder resource(final java.util.List<CapabilityStatementResource> resource) {
                b.add(FhirPropertyNames.PROPERTY_RESOURCE, FhirObject.toArray(resource));
                return this;
            }

            public Builder interaction(final java.util.List<CapabilityStatementInteraction1> interaction) {
                b.add(FhirPropertyNames.PROPERTY_INTERACTION, FhirObject.toArray(interaction));
                return this;
            }

            public Builder searchParam(final java.util.List<CapabilityStatementSearchParam> searchParam) {
                b.add(FhirPropertyNames.PROPERTY_SEARCH_PARAM, FhirObject.toArray(searchParam));
                return this;
            }

            public Builder operation(final java.util.List<CapabilityStatementOperation> operation) {
                b.add(FhirPropertyNames.PROPERTY_OPERATION, FhirObject.toArray(operation));
                return this;
            }

            public Builder compartment(final java.util.List<String> compartment) {
                b.add(FhirPropertyNames.PROPERTY_COMPARTMENT, FhirObject.toStringArray(compartment));
                return this;
            }

            public CapabilityStatementRest build() {
                return new CapabilityStatementRest(b.build());
            }
        }
    }

    /**
     * A Capability Statement documents a set of capabilities (behaviors) of
     * a FHIR Server for a particular version of FHIR that may be used as a
     * statement of actual server functionality or a statement of required or
     * desired server implementation.
     */
    public static class CapabilityStatementSearchParam extends FhirObject {
        public static final String RESOURCE_TYPE = "CapabilityStatementSearchParam";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public CapabilityStatementSearchParam(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * The name of the search parameter used in the interface.
         */
        public String name() {
            return getString(FhirPropertyNames.PROPERTY_NAME);
        }

        /**
         * An absolute URI that is a formal reference to where this parameter was
         * first defined, so that a client can be confident of the meaning of the
         * search parameter (a reference to [[[SearchParameter.url]]]). This
         * element SHALL be populated if the search parameter refers to a
         * SearchParameter defined by the FHIR core specification or externally
         * defined IGs.
         */
        public String definition() {
            return getString(FhirPropertyNames.PROPERTY_DEFINITION);
        }

        /**
         * The type of value a search parameter refers to, and how the content is
         * interpreted.
         */
        public String type() {
            return getString(FhirPropertyNames.PROPERTY_TYPE);
        }

        /**
         * This allows documentation of any distinct behaviors about how the
         * search parameter is used.  For example, text matching algorithms.
         */
        public String documentation() {
            return getString(FhirPropertyNames.PROPERTY_DOCUMENTATION);
        }

        public static final class Builder extends FhirObject.Builder<CapabilityStatementSearchParam, CapabilityStatementSearchParam.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder name(final String name) {
                b.add(FhirPropertyNames.PROPERTY_NAME, name);
                return this;
            }

            public Builder definition(final String definition) {
                b.add(FhirPropertyNames.PROPERTY_DEFINITION, definition);
                return this;
            }

            public Builder type(final String type) {
                b.add(FhirPropertyNames.PROPERTY_TYPE, type);
                return this;
            }

            public Builder documentation(final String documentation) {
                b.add(FhirPropertyNames.PROPERTY_DOCUMENTATION, documentation);
                return this;
            }

            public CapabilityStatementSearchParam build() {
                return new CapabilityStatementSearchParam(b.build());
            }
        }
    }

    /**
     * A Capability Statement documents a set of capabilities (behaviors) of
     * a FHIR Server for a particular version of FHIR that may be used as a
     * statement of actual server functionality or a statement of required or
     * desired server implementation.
     */
    public static class CapabilityStatementSecurity extends FhirObject {
        public static final String RESOURCE_TYPE = "CapabilityStatementSecurity";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public CapabilityStatementSecurity(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Server adds CORS headers when responding to requests - this enables
         * Javascript applications to use the server.
         */
        public Boolean cors() {
            return data.getBoolean(FhirPropertyNames.PROPERTY_CORS);
        }

        /**
         * Types of security services that are supported/required by the system.
         */
        public java.util.List<CodeableConcept> service() {
            return getList(CodeableConcept.class, FhirPropertyNames.PROPERTY_SERVICE);
        }

        /**
         * General description of how security works.
         */
        public String description() {
            return getString(FhirPropertyNames.PROPERTY_DESCRIPTION);
        }

        public static final class Builder extends FhirObject.Builder<CapabilityStatementSecurity, CapabilityStatementSecurity.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder cors(final Boolean cors) {
                b.add(FhirPropertyNames.PROPERTY_CORS, cors);
                return this;
            }

            public Builder service(final java.util.List<CodeableConcept> service) {
                b.add(FhirPropertyNames.PROPERTY_SERVICE, FhirObject.toArray(service));
                return this;
            }

            public Builder description(final String description) {
                b.add(FhirPropertyNames.PROPERTY_DESCRIPTION, description);
                return this;
            }

            public CapabilityStatementSecurity build() {
                return new CapabilityStatementSecurity(b.build());
            }
        }
    }

    /**
     * A Capability Statement documents a set of capabilities (behaviors) of
     * a FHIR Server for a particular version of FHIR that may be used as a
     * statement of actual server functionality or a statement of required or
     * desired server implementation.
     */
    public static class CapabilityStatementSoftware extends FhirObject {
        public static final String RESOURCE_TYPE = "CapabilityStatementSoftware";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public CapabilityStatementSoftware(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Name the software is known by.
         */
        public String name() {
            return getString(FhirPropertyNames.PROPERTY_NAME);
        }

        /**
         * The version identifier for the software covered by this statement.
         */
        public String version() {
            return getString(FhirPropertyNames.PROPERTY_VERSION);
        }

        /**
         * Date this version of the software was released.
         */
        public java.time.Instant releaseDate() {
            return getInstant(FhirPropertyNames.PROPERTY_RELEASE_DATE);
        }

        public static final class Builder extends FhirObject.Builder<CapabilityStatementSoftware, CapabilityStatementSoftware.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder name(final String name) {
                b.add(FhirPropertyNames.PROPERTY_NAME, name);
                return this;
            }

            public Builder version(final String version) {
                b.add(FhirPropertyNames.PROPERTY_VERSION, version);
                return this;
            }

            public Builder releaseDate(final java.time.Instant releaseDate) {
                b.add(FhirPropertyNames.PROPERTY_RELEASE_DATE, releaseDate.toString());
                return this;
            }

            public CapabilityStatementSoftware build() {
                return new CapabilityStatementSoftware(b.build());
            }
        }
    }

    /**
     * A Capability Statement documents a set of capabilities (behaviors) of
     * a FHIR Server for a particular version of FHIR that may be used as a
     * statement of actual server functionality or a statement of required or
     * desired server implementation.
     */
    public static class CapabilityStatementSupportedMessage extends FhirObject {
        public static final String RESOURCE_TYPE = "CapabilityStatementSupportedMessage";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public CapabilityStatementSupportedMessage(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * The mode of this event declaration - whether application is sender or
         * receiver.
         */
        public String mode() {
            return getString(FhirPropertyNames.PROPERTY_MODE);
        }

        /**
         * Points to a message definition that identifies the messaging event,
         * message structure, allowed responses, etc.
         */
        public String definition() {
            return getString(FhirPropertyNames.PROPERTY_DEFINITION);
        }

        public static final class Builder extends FhirObject.Builder<CapabilityStatementSupportedMessage, CapabilityStatementSupportedMessage.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder mode(final String mode) {
                b.add(FhirPropertyNames.PROPERTY_MODE, mode);
                return this;
            }

            public Builder definition(final String definition) {
                b.add(FhirPropertyNames.PROPERTY_DEFINITION, definition);
                return this;
            }

            public CapabilityStatementSupportedMessage build() {
                return new CapabilityStatementSupportedMessage(b.build());
            }
        }
    }
}
