/*
 * Generated by com.medplum.generator.Generator
 * Do not edit manually.
 */

package com.medplum.fhir.r4.types;

import jakarta.json.JsonObject;

import com.medplum.fhir.r4.FhirPropertyNames;

/**
 * Describes a required data item for evaluation in terms of the type of
 * data, and optional code or date-based filters of the data.
 */
public class DataRequirement extends FhirObject {
    public static final String RESOURCE_TYPE = "DataRequirement";

    public static Builder create() {
        return new Builder();
    }

    public static Builder create(final JsonObject data) {
        return new Builder(data);
    }

    public DataRequirement(final JsonObject data) {
        super(data);
    }

    /**
     * Unique id for the element within a resource (for internal references).
     * This may be any string value that does not contain spaces.
     */
    public String id() {
        return getString(FhirPropertyNames.PROPERTY_ID);
    }

    /**
     * May be used to represent additional information that is not part of
     * the basic definition of the element. To make the use of extensions
     * safe and manageable, there is a strict set of governance  applied to
     * the definition and use of extensions. Though any implementer can
     * define an extension, there is a set of requirements that SHALL be met
     * as part of the definition of the extension.
     */
    public java.util.List<Extension> extension() {
        return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
    }

    /**
     * The type of the required data, specified as the type name of a
     * resource. For profiles, this value is set to the type of the base
     * resource of the profile.
     */
    public String type() {
        return getString(FhirPropertyNames.PROPERTY_TYPE);
    }

    /**
     * The profile of the required data, specified as the uri of the profile
     * definition.
     */
    public java.util.List<String> profile() {
        return getList(String.class, FhirPropertyNames.PROPERTY_PROFILE);
    }

    /**
     * The intended subjects of the data requirement. If this element is not
     * provided, a Patient subject is assumed.
     */
    public CodeableConcept subjectCodeableConcept() {
        return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_SUBJECT_CODEABLE_CONCEPT);
    }

    /**
     * The intended subjects of the data requirement. If this element is not
     * provided, a Patient subject is assumed.
     */
    public Reference subjectReference() {
        return getObject(Reference.class, FhirPropertyNames.PROPERTY_SUBJECT_REFERENCE);
    }

    /**
     * Indicates that specific elements of the type are referenced by the
     * knowledge module and must be supported by the consumer in order to
     * obtain an effective evaluation. This does not mean that a value is
     * required for this element, only that the consuming system must
     * understand the element and be able to provide values for it if they
     * are available.
     *
     * The value of mustSupport SHALL be a FHIRPath resolveable on the type
     * of the DataRequirement. The path SHALL consist only of identifiers,
     * constant indexers, and .resolve() (see the [Simple FHIRPath
     * Profile](fhirpath.html#simple) for full details).
     */
    public java.util.List<String> mustSupport() {
        return getList(String.class, FhirPropertyNames.PROPERTY_MUST_SUPPORT);
    }

    /**
     * Code filters specify additional constraints on the data, specifying
     * the value set of interest for a particular element of the data. Each
     * code filter defines an additional constraint on the data, i.e. code
     * filters are AND'ed, not OR'ed.
     */
    public java.util.List<DataRequirementCodeFilter> codeFilter() {
        return getList(DataRequirementCodeFilter.class, FhirPropertyNames.PROPERTY_CODE_FILTER);
    }

    /**
     * Date filters specify additional constraints on the data in terms of
     * the applicable date range for specific elements. Each date filter
     * specifies an additional constraint on the data, i.e. date filters are
     * AND'ed, not OR'ed.
     */
    public java.util.List<DataRequirementDateFilter> dateFilter() {
        return getList(DataRequirementDateFilter.class, FhirPropertyNames.PROPERTY_DATE_FILTER);
    }

    /**
     * Specifies a maximum number of results that are required (uses the
     * _count search parameter).
     */
    public Integer limit() {
        return data.getInt(FhirPropertyNames.PROPERTY_LIMIT);
    }

    /**
     * Specifies the order of the results to be returned.
     */
    public java.util.List<DataRequirementSort> sort() {
        return getList(DataRequirementSort.class, FhirPropertyNames.PROPERTY_SORT);
    }

    public static final class Builder extends FhirObject.Builder<DataRequirement, DataRequirement.Builder> {

        private Builder() {
            super();
        }

        private Builder(final JsonObject data) {
            super(data);
        }

        public Builder id(final String id) {
            b.add(FhirPropertyNames.PROPERTY_ID, id);
            return this;
        }

        public Builder extension(final java.util.List<Extension> extension) {
            b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
            return this;
        }

        public Builder type(final String type) {
            b.add(FhirPropertyNames.PROPERTY_TYPE, type);
            return this;
        }

        public Builder profile(final java.util.List<String> profile) {
            b.add(FhirPropertyNames.PROPERTY_PROFILE, FhirObject.toStringArray(profile));
            return this;
        }

        public Builder subjectCodeableConcept(final CodeableConcept subjectCodeableConcept) {
            b.add(FhirPropertyNames.PROPERTY_SUBJECT_CODEABLE_CONCEPT, subjectCodeableConcept);
            return this;
        }

        public Builder subjectReference(final Reference subjectReference) {
            b.add(FhirPropertyNames.PROPERTY_SUBJECT_REFERENCE, subjectReference);
            return this;
        }

        public Builder mustSupport(final java.util.List<String> mustSupport) {
            b.add(FhirPropertyNames.PROPERTY_MUST_SUPPORT, FhirObject.toStringArray(mustSupport));
            return this;
        }

        public Builder codeFilter(final java.util.List<DataRequirementCodeFilter> codeFilter) {
            b.add(FhirPropertyNames.PROPERTY_CODE_FILTER, FhirObject.toArray(codeFilter));
            return this;
        }

        public Builder dateFilter(final java.util.List<DataRequirementDateFilter> dateFilter) {
            b.add(FhirPropertyNames.PROPERTY_DATE_FILTER, FhirObject.toArray(dateFilter));
            return this;
        }

        public Builder limit(final Integer limit) {
            b.add(FhirPropertyNames.PROPERTY_LIMIT, limit);
            return this;
        }

        public Builder sort(final java.util.List<DataRequirementSort> sort) {
            b.add(FhirPropertyNames.PROPERTY_SORT, FhirObject.toArray(sort));
            return this;
        }

        public DataRequirement build() {
            return new DataRequirement(b.build());
        }
    }

    /**
     * Describes a required data item for evaluation in terms of the type of
     * data, and optional code or date-based filters of the data.
     */
    public static class DataRequirementCodeFilter extends FhirObject {
        public static final String RESOURCE_TYPE = "DataRequirementCodeFilter";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public DataRequirementCodeFilter(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * The code-valued attribute of the filter. The specified path SHALL be a
         * FHIRPath resolveable on the specified type of the DataRequirement, and
         * SHALL consist only of identifiers, constant indexers, and .resolve().
         * The path is allowed to contain qualifiers (.) to traverse
         * sub-elements, as well as indexers ([x]) to traverse
         * multiple-cardinality sub-elements (see the [Simple FHIRPath
         * Profile](fhirpath.html#simple) for full details). Note that the index
         * must be an integer constant. The path must resolve to an element of
         * type code, Coding, or CodeableConcept.
         */
        public String path() {
            return getString(FhirPropertyNames.PROPERTY_PATH);
        }

        /**
         * A token parameter that refers to a search parameter defined on the
         * specified type of the DataRequirement, and which searches on elements
         * of type code, Coding, or CodeableConcept.
         */
        public String searchParam() {
            return getString(FhirPropertyNames.PROPERTY_SEARCH_PARAM);
        }

        /**
         * The valueset for the code filter. The valueSet and code elements are
         * additive. If valueSet is specified, the filter will return only those
         * data items for which the value of the code-valued element specified in
         * the path is a member of the specified valueset.
         */
        public String valueSet() {
            return getString(FhirPropertyNames.PROPERTY_VALUE_SET);
        }

        /**
         * The codes for the code filter. If values are given, the filter will
         * return only those data items for which the code-valued attribute
         * specified by the path has a value that is one of the specified codes.
         * If codes are specified in addition to a value set, the filter returns
         * items matching a code in the value set or one of the specified codes.
         */
        public java.util.List<Coding> code() {
            return getList(Coding.class, FhirPropertyNames.PROPERTY_CODE);
        }

        public static final class Builder extends FhirObject.Builder<DataRequirementCodeFilter, DataRequirementCodeFilter.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder path(final String path) {
                b.add(FhirPropertyNames.PROPERTY_PATH, path);
                return this;
            }

            public Builder searchParam(final String searchParam) {
                b.add(FhirPropertyNames.PROPERTY_SEARCH_PARAM, searchParam);
                return this;
            }

            public Builder valueSet(final String valueSet) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_SET, valueSet);
                return this;
            }

            public Builder code(final java.util.List<Coding> code) {
                b.add(FhirPropertyNames.PROPERTY_CODE, FhirObject.toArray(code));
                return this;
            }

            public DataRequirementCodeFilter build() {
                return new DataRequirementCodeFilter(b.build());
            }
        }
    }

    /**
     * Describes a required data item for evaluation in terms of the type of
     * data, and optional code or date-based filters of the data.
     */
    public static class DataRequirementDateFilter extends FhirObject {
        public static final String RESOURCE_TYPE = "DataRequirementDateFilter";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public DataRequirementDateFilter(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * The date-valued attribute of the filter. The specified path SHALL be a
         * FHIRPath resolveable on the specified type of the DataRequirement, and
         * SHALL consist only of identifiers, constant indexers, and .resolve().
         * The path is allowed to contain qualifiers (.) to traverse
         * sub-elements, as well as indexers ([x]) to traverse
         * multiple-cardinality sub-elements (see the [Simple FHIRPath
         * Profile](fhirpath.html#simple) for full details). Note that the index
         * must be an integer constant. The path must resolve to an element of
         * type date, dateTime, Period, Schedule, or Timing.
         */
        public String path() {
            return getString(FhirPropertyNames.PROPERTY_PATH);
        }

        /**
         * A date parameter that refers to a search parameter defined on the
         * specified type of the DataRequirement, and which searches on elements
         * of type date, dateTime, Period, Schedule, or Timing.
         */
        public String searchParam() {
            return getString(FhirPropertyNames.PROPERTY_SEARCH_PARAM);
        }

        /**
         * The value of the filter. If period is specified, the filter will
         * return only those data items that fall within the bounds determined by
         * the Period, inclusive of the period boundaries. If dateTime is
         * specified, the filter will return only those data items that are equal
         * to the specified dateTime. If a Duration is specified, the filter will
         * return only those data items that fall within Duration before now.
         */
        public String valueDateTime() {
            return getString(FhirPropertyNames.PROPERTY_VALUE_DATE_TIME);
        }

        /**
         * The value of the filter. If period is specified, the filter will
         * return only those data items that fall within the bounds determined by
         * the Period, inclusive of the period boundaries. If dateTime is
         * specified, the filter will return only those data items that are equal
         * to the specified dateTime. If a Duration is specified, the filter will
         * return only those data items that fall within Duration before now.
         */
        public Period valuePeriod() {
            return getObject(Period.class, FhirPropertyNames.PROPERTY_VALUE_PERIOD);
        }

        /**
         * The value of the filter. If period is specified, the filter will
         * return only those data items that fall within the bounds determined by
         * the Period, inclusive of the period boundaries. If dateTime is
         * specified, the filter will return only those data items that are equal
         * to the specified dateTime. If a Duration is specified, the filter will
         * return only those data items that fall within Duration before now.
         */
        public Duration valueDuration() {
            return getObject(Duration.class, FhirPropertyNames.PROPERTY_VALUE_DURATION);
        }

        public static final class Builder extends FhirObject.Builder<DataRequirementDateFilter, DataRequirementDateFilter.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder path(final String path) {
                b.add(FhirPropertyNames.PROPERTY_PATH, path);
                return this;
            }

            public Builder searchParam(final String searchParam) {
                b.add(FhirPropertyNames.PROPERTY_SEARCH_PARAM, searchParam);
                return this;
            }

            public Builder valueDateTime(final String valueDateTime) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_DATE_TIME, valueDateTime);
                return this;
            }

            public Builder valuePeriod(final Period valuePeriod) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_PERIOD, valuePeriod);
                return this;
            }

            public Builder valueDuration(final Duration valueDuration) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_DURATION, valueDuration);
                return this;
            }

            public DataRequirementDateFilter build() {
                return new DataRequirementDateFilter(b.build());
            }
        }
    }

    /**
     * Describes a required data item for evaluation in terms of the type of
     * data, and optional code or date-based filters of the data.
     */
    public static class DataRequirementSort extends FhirObject {
        public static final String RESOURCE_TYPE = "DataRequirementSort";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public DataRequirementSort(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * The attribute of the sort. The specified path must be resolvable from
         * the type of the required data. The path is allowed to contain
         * qualifiers (.) to traverse sub-elements, as well as indexers ([x]) to
         * traverse multiple-cardinality sub-elements. Note that the index must
         * be an integer constant.
         */
        public String path() {
            return getString(FhirPropertyNames.PROPERTY_PATH);
        }

        /**
         * The direction of the sort, ascending or descending.
         */
        public String direction() {
            return getString(FhirPropertyNames.PROPERTY_DIRECTION);
        }

        public static final class Builder extends FhirObject.Builder<DataRequirementSort, DataRequirementSort.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder path(final String path) {
                b.add(FhirPropertyNames.PROPERTY_PATH, path);
                return this;
            }

            public Builder direction(final String direction) {
                b.add(FhirPropertyNames.PROPERTY_DIRECTION, direction);
                return this;
            }

            public DataRequirementSort build() {
                return new DataRequirementSort(b.build());
            }
        }
    }
}
