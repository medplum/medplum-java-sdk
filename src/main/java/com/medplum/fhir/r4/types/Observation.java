/*
 * Generated by com.medplum.generator.Generator
 * Do not edit manually.
 */

package com.medplum.fhir.r4.types;

import jakarta.json.JsonObject;

import com.medplum.fhir.r4.FhirPropertyNames;

/**
 * Measurements and simple assertions made about a patient, device or
 * other subject.
 */
public class Observation extends DomainResource {
    public static final String RESOURCE_TYPE = "Observation";

    public static Builder create() {
        return new Builder();
    }

    public static Builder create(final JsonObject data) {
        return new Builder(data);
    }

    public Observation(final JsonObject data) {
        super(data);
    }

    /**
     * A unique identifier assigned to this observation.
     */
    public java.util.List<Identifier> identifier() {
        return getList(Identifier.class, FhirPropertyNames.PROPERTY_IDENTIFIER);
    }

    /**
     * A plan, proposal or order that is fulfilled in whole or in part by
     * this event.  For example, a MedicationRequest may require a patient to
     * have laboratory test performed before  it is dispensed.
     */
    public java.util.List<Reference> basedOn() {
        return getList(Reference.class, FhirPropertyNames.PROPERTY_BASED_ON);
    }

    /**
     * A larger event of which this particular Observation is a component or
     * step.  For example,  an observation as part of a procedure.
     */
    public java.util.List<Reference> partOf() {
        return getList(Reference.class, FhirPropertyNames.PROPERTY_PART_OF);
    }

    /**
     * The status of the result value.
     */
    public String status() {
        return getString(FhirPropertyNames.PROPERTY_STATUS);
    }

    /**
     * A code that classifies the general type of observation being made.
     */
    public java.util.List<CodeableConcept> category() {
        return getList(CodeableConcept.class, FhirPropertyNames.PROPERTY_CATEGORY);
    }

    /**
     * Describes what was observed. Sometimes this is called the observation
     * &quot;name&quot;.
     */
    public CodeableConcept code() {
        return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_CODE);
    }

    /**
     * The patient, or group of patients, location, or device this
     * observation is about and into whose record the observation is placed.
     * If the actual focus of the observation is different from the subject
     * (or a sample of, part, or region of the subject), the `focus` element
     * or the `code` itself specifies the actual focus of the observation.
     */
    public Reference subject() {
        return getObject(Reference.class, FhirPropertyNames.PROPERTY_SUBJECT);
    }

    /**
     * The actual focus of an observation when it is not the patient of
     * record representing something or someone associated with the patient
     * such as a spouse, parent, fetus, or donor. For example, fetus
     * observations in a mother's record.  The focus of an observation could
     * also be an existing condition,  an intervention, the subject's diet,
     * another observation of the subject,  or a body structure such as tumor
     * or implanted device.   An example use case would be using the
     * Observation resource to capture whether the mother is trained to
     * change her child's tracheostomy tube. In this example, the child is
     * the patient of record and the mother is the focus.
     */
    public java.util.List<Reference> focus() {
        return getList(Reference.class, FhirPropertyNames.PROPERTY_FOCUS);
    }

    /**
     * The healthcare event  (e.g. a patient and healthcare provider
     * interaction) during which this observation is made.
     */
    public Reference encounter() {
        return getObject(Reference.class, FhirPropertyNames.PROPERTY_ENCOUNTER);
    }

    /**
     * The time or time-period the observed value is asserted as being true.
     * For biological subjects - e.g. human patients - this is usually called
     * the &quot;physiologically relevant time&quot;. This is usually either the time
     * of the procedure or of specimen collection, but very often the source
     * of the date/time is not known, only the date/time itself.
     */
    public String effectiveDateTime() {
        return getString(FhirPropertyNames.PROPERTY_EFFECTIVE_DATE_TIME);
    }

    /**
     * The time or time-period the observed value is asserted as being true.
     * For biological subjects - e.g. human patients - this is usually called
     * the &quot;physiologically relevant time&quot;. This is usually either the time
     * of the procedure or of specimen collection, but very often the source
     * of the date/time is not known, only the date/time itself.
     */
    public Period effectivePeriod() {
        return getObject(Period.class, FhirPropertyNames.PROPERTY_EFFECTIVE_PERIOD);
    }

    /**
     * The time or time-period the observed value is asserted as being true.
     * For biological subjects - e.g. human patients - this is usually called
     * the &quot;physiologically relevant time&quot;. This is usually either the time
     * of the procedure or of specimen collection, but very often the source
     * of the date/time is not known, only the date/time itself.
     */
    public Timing effectiveTiming() {
        return getObject(Timing.class, FhirPropertyNames.PROPERTY_EFFECTIVE_TIMING);
    }

    /**
     * The time or time-period the observed value is asserted as being true.
     * For biological subjects - e.g. human patients - this is usually called
     * the &quot;physiologically relevant time&quot;. This is usually either the time
     * of the procedure or of specimen collection, but very often the source
     * of the date/time is not known, only the date/time itself.
     */
    public String effectiveInstant() {
        return getString(FhirPropertyNames.PROPERTY_EFFECTIVE_INSTANT);
    }

    /**
     * The date and time this version of the observation was made available
     * to providers, typically after the results have been reviewed and
     * verified.
     */
    public java.time.Instant issued() {
        return getInstant(FhirPropertyNames.PROPERTY_ISSUED);
    }

    /**
     * Who was responsible for asserting the observed value as &quot;true&quot;.
     */
    public java.util.List<Reference> performer() {
        return getList(Reference.class, FhirPropertyNames.PROPERTY_PERFORMER);
    }

    /**
     * The information determined as a result of making the observation, if
     * the information has a simple value.
     */
    public Quantity valueQuantity() {
        return getObject(Quantity.class, FhirPropertyNames.PROPERTY_VALUE_QUANTITY);
    }

    /**
     * The information determined as a result of making the observation, if
     * the information has a simple value.
     */
    public CodeableConcept valueCodeableConcept() {
        return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_VALUE_CODEABLE_CONCEPT);
    }

    /**
     * The information determined as a result of making the observation, if
     * the information has a simple value.
     */
    public String valueString() {
        return getString(FhirPropertyNames.PROPERTY_VALUE_STRING);
    }

    /**
     * The information determined as a result of making the observation, if
     * the information has a simple value.
     */
    public Boolean valueBoolean() {
        return data.getBoolean(FhirPropertyNames.PROPERTY_VALUE_BOOLEAN);
    }

    /**
     * The information determined as a result of making the observation, if
     * the information has a simple value.
     */
    public Integer valueInteger() {
        return data.getInt(FhirPropertyNames.PROPERTY_VALUE_INTEGER);
    }

    /**
     * The information determined as a result of making the observation, if
     * the information has a simple value.
     */
    public Range valueRange() {
        return getObject(Range.class, FhirPropertyNames.PROPERTY_VALUE_RANGE);
    }

    /**
     * The information determined as a result of making the observation, if
     * the information has a simple value.
     */
    public Ratio valueRatio() {
        return getObject(Ratio.class, FhirPropertyNames.PROPERTY_VALUE_RATIO);
    }

    /**
     * The information determined as a result of making the observation, if
     * the information has a simple value.
     */
    public SampledData valueSampledData() {
        return getObject(SampledData.class, FhirPropertyNames.PROPERTY_VALUE_SAMPLED_DATA);
    }

    /**
     * The information determined as a result of making the observation, if
     * the information has a simple value.
     */
    public String valueTime() {
        return getString(FhirPropertyNames.PROPERTY_VALUE_TIME);
    }

    /**
     * The information determined as a result of making the observation, if
     * the information has a simple value.
     */
    public String valueDateTime() {
        return getString(FhirPropertyNames.PROPERTY_VALUE_DATE_TIME);
    }

    /**
     * The information determined as a result of making the observation, if
     * the information has a simple value.
     */
    public Period valuePeriod() {
        return getObject(Period.class, FhirPropertyNames.PROPERTY_VALUE_PERIOD);
    }

    /**
     * Provides a reason why the expected value in the element
     * Observation.value[x] is missing.
     */
    public CodeableConcept dataAbsentReason() {
        return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_DATA_ABSENT_REASON);
    }

    /**
     * A categorical assessment of an observation value.  For example, high,
     * low, normal.
     */
    public java.util.List<CodeableConcept> interpretation() {
        return getList(CodeableConcept.class, FhirPropertyNames.PROPERTY_INTERPRETATION);
    }

    /**
     * Comments about the observation or the results.
     */
    public java.util.List<Annotation> note() {
        return getList(Annotation.class, FhirPropertyNames.PROPERTY_NOTE);
    }

    /**
     * Indicates the site on the subject's body where the observation was
     * made (i.e. the target site).
     */
    public CodeableConcept bodySite() {
        return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_BODY_SITE);
    }

    /**
     * Indicates the mechanism used to perform the observation.
     */
    public CodeableConcept method() {
        return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_METHOD);
    }

    /**
     * The specimen that was used when this observation was made.
     */
    public Reference specimen() {
        return getObject(Reference.class, FhirPropertyNames.PROPERTY_SPECIMEN);
    }

    /**
     * The device used to generate the observation data.
     */
    public Reference device() {
        return getObject(Reference.class, FhirPropertyNames.PROPERTY_DEVICE);
    }

    /**
     * Guidance on how to interpret the value by comparison to a normal or
     * recommended range.  Multiple reference ranges are interpreted as an
     * &quot;OR&quot;.   In other words, to represent two distinct target populations,
     * two `referenceRange` elements would be used.
     */
    public java.util.List<ObservationReferenceRange> referenceRange() {
        return getList(ObservationReferenceRange.class, FhirPropertyNames.PROPERTY_REFERENCE_RANGE);
    }

    /**
     * This observation is a group observation (e.g. a battery, a panel of
     * tests, a set of vital sign measurements) that includes the target as a
     * member of the group.
     */
    public java.util.List<Reference> hasMember() {
        return getList(Reference.class, FhirPropertyNames.PROPERTY_HAS_MEMBER);
    }

    /**
     * The target resource that represents a measurement from which this
     * observation value is derived. For example, a calculated anion gap or a
     * fetal measurement based on an ultrasound image.
     */
    public java.util.List<Reference> derivedFrom() {
        return getList(Reference.class, FhirPropertyNames.PROPERTY_DERIVED_FROM);
    }

    /**
     * Some observations have multiple component observations.  These
     * component observations are expressed as separate code value pairs that
     * share the same attributes.  Examples include systolic and diastolic
     * component observations for blood pressure measurement and multiple
     * component observations for genetics observations.
     */
    public java.util.List<ObservationComponent> component() {
        return getList(ObservationComponent.class, FhirPropertyNames.PROPERTY_COMPONENT);
    }

    public static final class Builder extends DomainResource.Builder<Observation, Observation.Builder> {

        private Builder() {
            super(RESOURCE_TYPE);
        }

        private Builder(final JsonObject data) {
            super(RESOURCE_TYPE, data);
        }

        public Builder identifier(final java.util.List<Identifier> identifier) {
            b.add(FhirPropertyNames.PROPERTY_IDENTIFIER, FhirObject.toArray(identifier));
            return this;
        }

        public Builder basedOn(final java.util.List<Reference> basedOn) {
            b.add(FhirPropertyNames.PROPERTY_BASED_ON, FhirObject.toArray(basedOn));
            return this;
        }

        public Builder partOf(final java.util.List<Reference> partOf) {
            b.add(FhirPropertyNames.PROPERTY_PART_OF, FhirObject.toArray(partOf));
            return this;
        }

        public Builder status(final String status) {
            b.add(FhirPropertyNames.PROPERTY_STATUS, status);
            return this;
        }

        public Builder category(final java.util.List<CodeableConcept> category) {
            b.add(FhirPropertyNames.PROPERTY_CATEGORY, FhirObject.toArray(category));
            return this;
        }

        public Builder code(final CodeableConcept code) {
            b.add(FhirPropertyNames.PROPERTY_CODE, code);
            return this;
        }

        public Builder subject(final Reference subject) {
            b.add(FhirPropertyNames.PROPERTY_SUBJECT, subject);
            return this;
        }

        public Builder focus(final java.util.List<Reference> focus) {
            b.add(FhirPropertyNames.PROPERTY_FOCUS, FhirObject.toArray(focus));
            return this;
        }

        public Builder encounter(final Reference encounter) {
            b.add(FhirPropertyNames.PROPERTY_ENCOUNTER, encounter);
            return this;
        }

        public Builder effectiveDateTime(final String effectiveDateTime) {
            b.add(FhirPropertyNames.PROPERTY_EFFECTIVE_DATE_TIME, effectiveDateTime);
            return this;
        }

        public Builder effectivePeriod(final Period effectivePeriod) {
            b.add(FhirPropertyNames.PROPERTY_EFFECTIVE_PERIOD, effectivePeriod);
            return this;
        }

        public Builder effectiveTiming(final Timing effectiveTiming) {
            b.add(FhirPropertyNames.PROPERTY_EFFECTIVE_TIMING, effectiveTiming);
            return this;
        }

        public Builder effectiveInstant(final String effectiveInstant) {
            b.add(FhirPropertyNames.PROPERTY_EFFECTIVE_INSTANT, effectiveInstant);
            return this;
        }

        public Builder issued(final java.time.Instant issued) {
            b.add(FhirPropertyNames.PROPERTY_ISSUED, issued.toString());
            return this;
        }

        public Builder performer(final java.util.List<Reference> performer) {
            b.add(FhirPropertyNames.PROPERTY_PERFORMER, FhirObject.toArray(performer));
            return this;
        }

        public Builder valueQuantity(final Quantity valueQuantity) {
            b.add(FhirPropertyNames.PROPERTY_VALUE_QUANTITY, valueQuantity);
            return this;
        }

        public Builder valueCodeableConcept(final CodeableConcept valueCodeableConcept) {
            b.add(FhirPropertyNames.PROPERTY_VALUE_CODEABLE_CONCEPT, valueCodeableConcept);
            return this;
        }

        public Builder valueString(final String valueString) {
            b.add(FhirPropertyNames.PROPERTY_VALUE_STRING, valueString);
            return this;
        }

        public Builder valueBoolean(final Boolean valueBoolean) {
            b.add(FhirPropertyNames.PROPERTY_VALUE_BOOLEAN, valueBoolean);
            return this;
        }

        public Builder valueInteger(final Integer valueInteger) {
            b.add(FhirPropertyNames.PROPERTY_VALUE_INTEGER, valueInteger);
            return this;
        }

        public Builder valueRange(final Range valueRange) {
            b.add(FhirPropertyNames.PROPERTY_VALUE_RANGE, valueRange);
            return this;
        }

        public Builder valueRatio(final Ratio valueRatio) {
            b.add(FhirPropertyNames.PROPERTY_VALUE_RATIO, valueRatio);
            return this;
        }

        public Builder valueSampledData(final SampledData valueSampledData) {
            b.add(FhirPropertyNames.PROPERTY_VALUE_SAMPLED_DATA, valueSampledData);
            return this;
        }

        public Builder valueTime(final String valueTime) {
            b.add(FhirPropertyNames.PROPERTY_VALUE_TIME, valueTime);
            return this;
        }

        public Builder valueDateTime(final String valueDateTime) {
            b.add(FhirPropertyNames.PROPERTY_VALUE_DATE_TIME, valueDateTime);
            return this;
        }

        public Builder valuePeriod(final Period valuePeriod) {
            b.add(FhirPropertyNames.PROPERTY_VALUE_PERIOD, valuePeriod);
            return this;
        }

        public Builder dataAbsentReason(final CodeableConcept dataAbsentReason) {
            b.add(FhirPropertyNames.PROPERTY_DATA_ABSENT_REASON, dataAbsentReason);
            return this;
        }

        public Builder interpretation(final java.util.List<CodeableConcept> interpretation) {
            b.add(FhirPropertyNames.PROPERTY_INTERPRETATION, FhirObject.toArray(interpretation));
            return this;
        }

        public Builder note(final java.util.List<Annotation> note) {
            b.add(FhirPropertyNames.PROPERTY_NOTE, FhirObject.toArray(note));
            return this;
        }

        public Builder bodySite(final CodeableConcept bodySite) {
            b.add(FhirPropertyNames.PROPERTY_BODY_SITE, bodySite);
            return this;
        }

        public Builder method(final CodeableConcept method) {
            b.add(FhirPropertyNames.PROPERTY_METHOD, method);
            return this;
        }

        public Builder specimen(final Reference specimen) {
            b.add(FhirPropertyNames.PROPERTY_SPECIMEN, specimen);
            return this;
        }

        public Builder device(final Reference device) {
            b.add(FhirPropertyNames.PROPERTY_DEVICE, device);
            return this;
        }

        public Builder referenceRange(final java.util.List<ObservationReferenceRange> referenceRange) {
            b.add(FhirPropertyNames.PROPERTY_REFERENCE_RANGE, FhirObject.toArray(referenceRange));
            return this;
        }

        public Builder hasMember(final java.util.List<Reference> hasMember) {
            b.add(FhirPropertyNames.PROPERTY_HAS_MEMBER, FhirObject.toArray(hasMember));
            return this;
        }

        public Builder derivedFrom(final java.util.List<Reference> derivedFrom) {
            b.add(FhirPropertyNames.PROPERTY_DERIVED_FROM, FhirObject.toArray(derivedFrom));
            return this;
        }

        public Builder component(final java.util.List<ObservationComponent> component) {
            b.add(FhirPropertyNames.PROPERTY_COMPONENT, FhirObject.toArray(component));
            return this;
        }

        public Observation build() {
            return new Observation(b.build());
        }
    }

    /**
     * Measurements and simple assertions made about a patient, device or
     * other subject.
     */
    public static class ObservationComponent extends FhirObject {
        public static final String RESOURCE_TYPE = "ObservationComponent";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public ObservationComponent(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Describes what was observed. Sometimes this is called the observation
         * &quot;code&quot;.
         */
        public CodeableConcept code() {
            return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_CODE);
        }

        /**
         * The information determined as a result of making the observation, if
         * the information has a simple value.
         */
        public Quantity valueQuantity() {
            return getObject(Quantity.class, FhirPropertyNames.PROPERTY_VALUE_QUANTITY);
        }

        /**
         * The information determined as a result of making the observation, if
         * the information has a simple value.
         */
        public CodeableConcept valueCodeableConcept() {
            return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_VALUE_CODEABLE_CONCEPT);
        }

        /**
         * The information determined as a result of making the observation, if
         * the information has a simple value.
         */
        public String valueString() {
            return getString(FhirPropertyNames.PROPERTY_VALUE_STRING);
        }

        /**
         * The information determined as a result of making the observation, if
         * the information has a simple value.
         */
        public Boolean valueBoolean() {
            return data.getBoolean(FhirPropertyNames.PROPERTY_VALUE_BOOLEAN);
        }

        /**
         * The information determined as a result of making the observation, if
         * the information has a simple value.
         */
        public Integer valueInteger() {
            return data.getInt(FhirPropertyNames.PROPERTY_VALUE_INTEGER);
        }

        /**
         * The information determined as a result of making the observation, if
         * the information has a simple value.
         */
        public Range valueRange() {
            return getObject(Range.class, FhirPropertyNames.PROPERTY_VALUE_RANGE);
        }

        /**
         * The information determined as a result of making the observation, if
         * the information has a simple value.
         */
        public Ratio valueRatio() {
            return getObject(Ratio.class, FhirPropertyNames.PROPERTY_VALUE_RATIO);
        }

        /**
         * The information determined as a result of making the observation, if
         * the information has a simple value.
         */
        public SampledData valueSampledData() {
            return getObject(SampledData.class, FhirPropertyNames.PROPERTY_VALUE_SAMPLED_DATA);
        }

        /**
         * The information determined as a result of making the observation, if
         * the information has a simple value.
         */
        public String valueTime() {
            return getString(FhirPropertyNames.PROPERTY_VALUE_TIME);
        }

        /**
         * The information determined as a result of making the observation, if
         * the information has a simple value.
         */
        public String valueDateTime() {
            return getString(FhirPropertyNames.PROPERTY_VALUE_DATE_TIME);
        }

        /**
         * The information determined as a result of making the observation, if
         * the information has a simple value.
         */
        public Period valuePeriod() {
            return getObject(Period.class, FhirPropertyNames.PROPERTY_VALUE_PERIOD);
        }

        /**
         * Provides a reason why the expected value in the element
         * Observation.component.value[x] is missing.
         */
        public CodeableConcept dataAbsentReason() {
            return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_DATA_ABSENT_REASON);
        }

        /**
         * A categorical assessment of an observation value.  For example, high,
         * low, normal.
         */
        public java.util.List<CodeableConcept> interpretation() {
            return getList(CodeableConcept.class, FhirPropertyNames.PROPERTY_INTERPRETATION);
        }

        /**
         * Guidance on how to interpret the value by comparison to a normal or
         * recommended range.
         */
        public java.util.List<ObservationReferenceRange> referenceRange() {
            return getList(ObservationReferenceRange.class, FhirPropertyNames.PROPERTY_REFERENCE_RANGE);
        }

        public static final class Builder extends FhirObject.Builder<ObservationComponent, ObservationComponent.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder code(final CodeableConcept code) {
                b.add(FhirPropertyNames.PROPERTY_CODE, code);
                return this;
            }

            public Builder valueQuantity(final Quantity valueQuantity) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_QUANTITY, valueQuantity);
                return this;
            }

            public Builder valueCodeableConcept(final CodeableConcept valueCodeableConcept) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_CODEABLE_CONCEPT, valueCodeableConcept);
                return this;
            }

            public Builder valueString(final String valueString) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_STRING, valueString);
                return this;
            }

            public Builder valueBoolean(final Boolean valueBoolean) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_BOOLEAN, valueBoolean);
                return this;
            }

            public Builder valueInteger(final Integer valueInteger) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_INTEGER, valueInteger);
                return this;
            }

            public Builder valueRange(final Range valueRange) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_RANGE, valueRange);
                return this;
            }

            public Builder valueRatio(final Ratio valueRatio) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_RATIO, valueRatio);
                return this;
            }

            public Builder valueSampledData(final SampledData valueSampledData) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_SAMPLED_DATA, valueSampledData);
                return this;
            }

            public Builder valueTime(final String valueTime) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_TIME, valueTime);
                return this;
            }

            public Builder valueDateTime(final String valueDateTime) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_DATE_TIME, valueDateTime);
                return this;
            }

            public Builder valuePeriod(final Period valuePeriod) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_PERIOD, valuePeriod);
                return this;
            }

            public Builder dataAbsentReason(final CodeableConcept dataAbsentReason) {
                b.add(FhirPropertyNames.PROPERTY_DATA_ABSENT_REASON, dataAbsentReason);
                return this;
            }

            public Builder interpretation(final java.util.List<CodeableConcept> interpretation) {
                b.add(FhirPropertyNames.PROPERTY_INTERPRETATION, FhirObject.toArray(interpretation));
                return this;
            }

            public Builder referenceRange(final java.util.List<ObservationReferenceRange> referenceRange) {
                b.add(FhirPropertyNames.PROPERTY_REFERENCE_RANGE, FhirObject.toArray(referenceRange));
                return this;
            }

            public ObservationComponent build() {
                return new ObservationComponent(b.build());
            }
        }
    }

    /**
     * Measurements and simple assertions made about a patient, device or
     * other subject.
     */
    public static class ObservationReferenceRange extends FhirObject {
        public static final String RESOURCE_TYPE = "ObservationReferenceRange";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public ObservationReferenceRange(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * The value of the low bound of the reference range.  The low bound of
         * the reference range endpoint is inclusive of the value (e.g.
         * reference range is &gt;=5 - &lt;=9). If the low bound is omitted,  it is
         * assumed to be meaningless (e.g. reference range is &lt;=2.3).
         */
        public Quantity low() {
            return getObject(Quantity.class, FhirPropertyNames.PROPERTY_LOW);
        }

        /**
         * The value of the high bound of the reference range.  The high bound of
         * the reference range endpoint is inclusive of the value (e.g.
         * reference range is &gt;=5 - &lt;=9). If the high bound is omitted,  it is
         * assumed to be meaningless (e.g. reference range is &gt;= 2.3).
         */
        public Quantity high() {
            return getObject(Quantity.class, FhirPropertyNames.PROPERTY_HIGH);
        }

        /**
         * Codes to indicate the what part of the targeted reference population
         * it applies to. For example, the normal or therapeutic range.
         */
        public CodeableConcept type() {
            return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_TYPE);
        }

        /**
         * Codes to indicate the target population this reference range applies
         * to.  For example, a reference range may be based on the normal
         * population or a particular sex or race.  Multiple `appliesTo`  are
         * interpreted as an &quot;AND&quot; of the target populations.  For example, to
         * represent a target population of African American females, both a code
         * of female and a code for African American would be used.
         */
        public java.util.List<CodeableConcept> appliesTo() {
            return getList(CodeableConcept.class, FhirPropertyNames.PROPERTY_APPLIES_TO);
        }

        /**
         * The age at which this reference range is applicable. This is a
         * neonatal age (e.g. number of weeks at term) if the meaning says so.
         */
        public Range age() {
            return getObject(Range.class, FhirPropertyNames.PROPERTY_AGE);
        }

        /**
         * Text based reference range in an observation which may be used when a
         * quantitative range is not appropriate for an observation.  An example
         * would be a reference value of &quot;Negative&quot; or a list or table of
         * &quot;normals&quot;.
         */
        public String text() {
            return getString(FhirPropertyNames.PROPERTY_TEXT);
        }

        public static final class Builder extends FhirObject.Builder<ObservationReferenceRange, ObservationReferenceRange.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder low(final Quantity low) {
                b.add(FhirPropertyNames.PROPERTY_LOW, low);
                return this;
            }

            public Builder high(final Quantity high) {
                b.add(FhirPropertyNames.PROPERTY_HIGH, high);
                return this;
            }

            public Builder type(final CodeableConcept type) {
                b.add(FhirPropertyNames.PROPERTY_TYPE, type);
                return this;
            }

            public Builder appliesTo(final java.util.List<CodeableConcept> appliesTo) {
                b.add(FhirPropertyNames.PROPERTY_APPLIES_TO, FhirObject.toArray(appliesTo));
                return this;
            }

            public Builder age(final Range age) {
                b.add(FhirPropertyNames.PROPERTY_AGE, age);
                return this;
            }

            public Builder text(final String text) {
                b.add(FhirPropertyNames.PROPERTY_TEXT, text);
                return this;
            }

            public ObservationReferenceRange build() {
                return new ObservationReferenceRange(b.build());
            }
        }
    }
}
