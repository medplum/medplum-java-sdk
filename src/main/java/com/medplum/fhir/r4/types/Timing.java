/*
 * Generated by com.medplum.generator.Generator
 * Do not edit manually.
 */

package com.medplum.fhir.r4.types;

import jakarta.json.JsonObject;

import com.medplum.fhir.r4.FhirPropertyNames;

/**
 * Specifies an event that may occur multiple times. Timing schedules are
 * used to record when things are planned, expected or requested to
 * occur. The most common usage is in dosage instructions for
 * medications. They are also used when planning care of various kinds,
 * and may be used for reporting the schedule to which past regular
 * activities were carried out.
 */
public class Timing extends FhirObject {
    public static final String RESOURCE_TYPE = "Timing";

    public static Builder create() {
        return new Builder();
    }

    public static Builder create(final JsonObject data) {
        return new Builder(data);
    }

    public Timing(final JsonObject data) {
        super(data);
    }

    /**
     * Unique id for the element within a resource (for internal references).
     * This may be any string value that does not contain spaces.
     */
    public String id() {
        return getString(FhirPropertyNames.PROPERTY_ID);
    }

    /**
     * May be used to represent additional information that is not part of
     * the basic definition of the element. To make the use of extensions
     * safe and manageable, there is a strict set of governance  applied to
     * the definition and use of extensions. Though any implementer can
     * define an extension, there is a set of requirements that SHALL be met
     * as part of the definition of the extension.
     */
    public java.util.List<Extension> extension() {
        return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
    }

    /**
     * May be used to represent additional information that is not part of
     * the basic definition of the element and that modifies the
     * understanding of the element in which it is contained and/or the
     * understanding of the containing element's descendants. Usually
     * modifier elements provide negation or qualification. To make the use
     * of extensions safe and manageable, there is a strict set of governance
     * applied to the definition and use of extensions. Though any
     * implementer can define an extension, there is a set of requirements
     * that SHALL be met as part of the definition of the extension.
     * Applications processing a resource are required to check for modifier
     * extensions.
     *
     * Modifier extensions SHALL NOT change the meaning of any elements on
     * Resource or DomainResource (including cannot change the meaning of
     * modifierExtension itself).
     */
    public java.util.List<Extension> modifierExtension() {
        return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
    }

    /**
     * Identifies specific times when the event occurs.
     */
    public java.util.List<java.time.Instant> event() {
        return getList(java.time.Instant.class, FhirPropertyNames.PROPERTY_EVENT);
    }

    /**
     * A set of rules that describe when the event is scheduled.
     */
    public TimingRepeat repeat() {
        return getObject(TimingRepeat.class, FhirPropertyNames.PROPERTY_REPEAT);
    }

    /**
     * A code for the timing schedule (or just text in code.text). Some codes
     * such as BID are ubiquitous, but many institutions define their own
     * additional codes. If a code is provided, the code is understood to be
     * a complete statement of whatever is specified in the structured timing
     * data, and either the code or the data may be used to interpret the
     * Timing, with the exception that .repeat.bounds still applies over the
     * code (and is not contained in the code).
     */
    public CodeableConcept code() {
        return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_CODE);
    }

    public static final class Builder extends FhirObject.Builder<Timing, Timing.Builder> {

        private Builder() {
            super();
        }

        private Builder(final JsonObject data) {
            super(data);
        }

        public Builder id(final String id) {
            b.add(FhirPropertyNames.PROPERTY_ID, id);
            return this;
        }

        public Builder extension(final java.util.List<Extension> extension) {
            b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
            return this;
        }

        public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
            b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
            return this;
        }

        public Builder event(final java.util.List<java.time.Instant> event) {
            b.add(FhirPropertyNames.PROPERTY_EVENT, FhirObject.toInstantArray(event));
            return this;
        }

        public Builder repeat(final TimingRepeat repeat) {
            b.add(FhirPropertyNames.PROPERTY_REPEAT, repeat);
            return this;
        }

        public Builder code(final CodeableConcept code) {
            b.add(FhirPropertyNames.PROPERTY_CODE, code);
            return this;
        }

        public Timing build() {
            return new Timing(b.build());
        }
    }

    /**
     * Specifies an event that may occur multiple times. Timing schedules are
     * used to record when things are planned, expected or requested to
     * occur. The most common usage is in dosage instructions for
     * medications. They are also used when planning care of various kinds,
     * and may be used for reporting the schedule to which past regular
     * activities were carried out.
     */
    public static class TimingRepeat extends FhirObject {
        public static final String RESOURCE_TYPE = "TimingRepeat";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public TimingRepeat(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Either a duration for the length of the timing schedule, a range of
         * possible length, or outer bounds for start and/or end limits of the
         * timing schedule.
         */
        public Duration boundsDuration() {
            return getObject(Duration.class, FhirPropertyNames.PROPERTY_BOUNDS_DURATION);
        }

        /**
         * Either a duration for the length of the timing schedule, a range of
         * possible length, or outer bounds for start and/or end limits of the
         * timing schedule.
         */
        public Range boundsRange() {
            return getObject(Range.class, FhirPropertyNames.PROPERTY_BOUNDS_RANGE);
        }

        /**
         * Either a duration for the length of the timing schedule, a range of
         * possible length, or outer bounds for start and/or end limits of the
         * timing schedule.
         */
        public Period boundsPeriod() {
            return getObject(Period.class, FhirPropertyNames.PROPERTY_BOUNDS_PERIOD);
        }

        /**
         * A total count of the desired number of repetitions across the duration
         * of the entire timing specification. If countMax is present, this
         * element indicates the lower bound of the allowed range of count
         * values.
         */
        public Integer count() {
            return data.getInt(FhirPropertyNames.PROPERTY_COUNT);
        }

        /**
         * If present, indicates that the count is a range - so to perform the
         * action between [count] and [countMax] times.
         */
        public Integer countMax() {
            return data.getInt(FhirPropertyNames.PROPERTY_COUNT_MAX);
        }

        /**
         * How long this thing happens for when it happens. If durationMax is
         * present, this element indicates the lower bound of the allowed range
         * of the duration.
         */
        public Double duration() {
            return data.getJsonNumber(FhirPropertyNames.PROPERTY_DURATION).doubleValue();
        }

        /**
         * If present, indicates that the duration is a range - so to perform the
         * action between [duration] and [durationMax] time length.
         */
        public Double durationMax() {
            return data.getJsonNumber(FhirPropertyNames.PROPERTY_DURATION_MAX).doubleValue();
        }

        /**
         * The units of time for the duration, in UCUM units.
         */
        public String durationUnit() {
            return getString(FhirPropertyNames.PROPERTY_DURATION_UNIT);
        }

        /**
         * The number of times to repeat the action within the specified period.
         * If frequencyMax is present, this element indicates the lower bound of
         * the allowed range of the frequency.
         */
        public Integer frequency() {
            return data.getInt(FhirPropertyNames.PROPERTY_FREQUENCY);
        }

        /**
         * If present, indicates that the frequency is a range - so to repeat
         * between [frequency] and [frequencyMax] times within the period or
         * period range.
         */
        public Integer frequencyMax() {
            return data.getInt(FhirPropertyNames.PROPERTY_FREQUENCY_MAX);
        }

        /**
         * Indicates the duration of time over which repetitions are to occur;
         * e.g. to express &quot;3 times per day&quot;, 3 would be the frequency and &quot;1
         * day&quot; would be the period. If periodMax is present, this element
         * indicates the lower bound of the allowed range of the period length.
         */
        public Double period() {
            return data.getJsonNumber(FhirPropertyNames.PROPERTY_PERIOD).doubleValue();
        }

        /**
         * If present, indicates that the period is a range from [period] to
         * [periodMax], allowing expressing concepts such as &quot;do this once every
         * 3-5 days.
         */
        public Double periodMax() {
            return data.getJsonNumber(FhirPropertyNames.PROPERTY_PERIOD_MAX).doubleValue();
        }

        /**
         * The units of time for the period in UCUM units.
         */
        public String periodUnit() {
            return getString(FhirPropertyNames.PROPERTY_PERIOD_UNIT);
        }

        /**
         * If one or more days of week is provided, then the action happens only
         * on the specified day(s).
         */
        public java.util.List<String> dayOfWeek() {
            return getList(String.class, FhirPropertyNames.PROPERTY_DAY_OF_WEEK);
        }

        /**
         * Specified time of day for action to take place.
         */
        public java.util.List<java.time.Instant> timeOfDay() {
            return getList(java.time.Instant.class, FhirPropertyNames.PROPERTY_TIME_OF_DAY);
        }

        /**
         * An approximate time period during the day, potentially linked to an
         * event of daily living that indicates when the action should occur.
         */
        public java.util.List<String> when() {
            return getList(String.class, FhirPropertyNames.PROPERTY_WHEN);
        }

        /**
         * The number of minutes from the event. If the event code does not
         * indicate whether the minutes is before or after the event, then the
         * offset is assumed to be after the event.
         */
        public Integer offset() {
            return data.getInt(FhirPropertyNames.PROPERTY_OFFSET);
        }

        public static final class Builder extends FhirObject.Builder<TimingRepeat, TimingRepeat.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder boundsDuration(final Duration boundsDuration) {
                b.add(FhirPropertyNames.PROPERTY_BOUNDS_DURATION, boundsDuration);
                return this;
            }

            public Builder boundsRange(final Range boundsRange) {
                b.add(FhirPropertyNames.PROPERTY_BOUNDS_RANGE, boundsRange);
                return this;
            }

            public Builder boundsPeriod(final Period boundsPeriod) {
                b.add(FhirPropertyNames.PROPERTY_BOUNDS_PERIOD, boundsPeriod);
                return this;
            }

            public Builder count(final Integer count) {
                b.add(FhirPropertyNames.PROPERTY_COUNT, count);
                return this;
            }

            public Builder countMax(final Integer countMax) {
                b.add(FhirPropertyNames.PROPERTY_COUNT_MAX, countMax);
                return this;
            }

            public Builder duration(final Double duration) {
                b.add(FhirPropertyNames.PROPERTY_DURATION, duration);
                return this;
            }

            public Builder durationMax(final Double durationMax) {
                b.add(FhirPropertyNames.PROPERTY_DURATION_MAX, durationMax);
                return this;
            }

            public Builder durationUnit(final String durationUnit) {
                b.add(FhirPropertyNames.PROPERTY_DURATION_UNIT, durationUnit);
                return this;
            }

            public Builder frequency(final Integer frequency) {
                b.add(FhirPropertyNames.PROPERTY_FREQUENCY, frequency);
                return this;
            }

            public Builder frequencyMax(final Integer frequencyMax) {
                b.add(FhirPropertyNames.PROPERTY_FREQUENCY_MAX, frequencyMax);
                return this;
            }

            public Builder period(final Double period) {
                b.add(FhirPropertyNames.PROPERTY_PERIOD, period);
                return this;
            }

            public Builder periodMax(final Double periodMax) {
                b.add(FhirPropertyNames.PROPERTY_PERIOD_MAX, periodMax);
                return this;
            }

            public Builder periodUnit(final String periodUnit) {
                b.add(FhirPropertyNames.PROPERTY_PERIOD_UNIT, periodUnit);
                return this;
            }

            public Builder dayOfWeek(final java.util.List<String> dayOfWeek) {
                b.add(FhirPropertyNames.PROPERTY_DAY_OF_WEEK, FhirObject.toStringArray(dayOfWeek));
                return this;
            }

            public Builder timeOfDay(final java.util.List<java.time.Instant> timeOfDay) {
                b.add(FhirPropertyNames.PROPERTY_TIME_OF_DAY, FhirObject.toInstantArray(timeOfDay));
                return this;
            }

            public Builder when(final java.util.List<String> when) {
                b.add(FhirPropertyNames.PROPERTY_WHEN, FhirObject.toStringArray(when));
                return this;
            }

            public Builder offset(final Integer offset) {
                b.add(FhirPropertyNames.PROPERTY_OFFSET, offset);
                return this;
            }

            public TimingRepeat build() {
                return new TimingRepeat(b.build());
            }
        }
    }
}
