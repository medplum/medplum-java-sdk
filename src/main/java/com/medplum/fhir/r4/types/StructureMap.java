/*
 * Generated by com.medplum.generator.Generator
 * Do not edit manually.
 */

package com.medplum.fhir.r4.types;

import jakarta.json.JsonObject;

import com.medplum.fhir.r4.FhirPropertyNames;

/**
 * A Map of relationships between 2 structures that can be used to
 * transform data.
 */
public class StructureMap extends DomainResource {
    public static final String RESOURCE_TYPE = "StructureMap";

    public static Builder create() {
        return new Builder();
    }

    public static Builder create(final JsonObject data) {
        return new Builder(data);
    }

    public StructureMap(final JsonObject data) {
        super(data);
    }

    /**
     * An absolute URI that is used to identify this structure map when it is
     * referenced in a specification, model, design or an instance; also
     * called its canonical identifier. This SHOULD be globally unique and
     * SHOULD be a literal address at which at which an authoritative
     * instance of this structure map is (or will be) published. This URL can
     * be the target of a canonical reference. It SHALL remain the same when
     * the structure map is stored on different servers.
     */
    public java.net.URI url() {
        return getUri(FhirPropertyNames.PROPERTY_URL);
    }

    /**
     * A formal identifier that is used to identify this structure map when
     * it is represented in other formats, or referenced in a specification,
     * model, design or an instance.
     */
    public java.util.List<Identifier> identifier() {
        return getList(Identifier.class, FhirPropertyNames.PROPERTY_IDENTIFIER);
    }

    /**
     * The identifier that is used to identify this version of the structure
     * map when it is referenced in a specification, model, design or
     * instance. This is an arbitrary value managed by the structure map
     * author and is not expected to be globally unique. For example, it
     * might be a timestamp (e.g. yyyymmdd) if a managed version is not
     * available. There is also no expectation that versions can be placed in
     * a lexicographical sequence.
     */
    public String version() {
        return getString(FhirPropertyNames.PROPERTY_VERSION);
    }

    /**
     * A natural language name identifying the structure map. This name
     * should be usable as an identifier for the module by machine processing
     * applications such as code generation.
     */
    public String name() {
        return getString(FhirPropertyNames.PROPERTY_NAME);
    }

    /**
     * A short, descriptive, user-friendly title for the structure map.
     */
    public String title() {
        return getString(FhirPropertyNames.PROPERTY_TITLE);
    }

    /**
     * The status of this structure map. Enables tracking the life-cycle of
     * the content.
     */
    public String status() {
        return getString(FhirPropertyNames.PROPERTY_STATUS);
    }

    /**
     * A Boolean value to indicate that this structure map is authored for
     * testing purposes (or education/evaluation/marketing) and is not
     * intended to be used for genuine usage.
     */
    public Boolean experimental() {
        return data.getBoolean(FhirPropertyNames.PROPERTY_EXPERIMENTAL);
    }

    /**
     * The date  (and optionally time) when the structure map was published.
     * The date must change when the business version changes and it must
     * change if the status code changes. In addition, it should change when
     * the substantive content of the structure map changes.
     */
    public java.time.Instant date() {
        return getInstant(FhirPropertyNames.PROPERTY_DATE);
    }

    /**
     * The name of the organization or individual that published the
     * structure map.
     */
    public String publisher() {
        return getString(FhirPropertyNames.PROPERTY_PUBLISHER);
    }

    /**
     * Contact details to assist a user in finding and communicating with the
     * publisher.
     */
    public java.util.List<ContactDetail> contact() {
        return getList(ContactDetail.class, FhirPropertyNames.PROPERTY_CONTACT);
    }

    /**
     * A free text natural language description of the structure map from a
     * consumer's perspective.
     */
    public String description() {
        return getString(FhirPropertyNames.PROPERTY_DESCRIPTION);
    }

    /**
     * The content was developed with a focus and intent of supporting the
     * contexts that are listed. These contexts may be general categories
     * (gender, age, ...) or may be references to specific programs
     * (insurance plans, studies, ...) and may be used to assist with
     * indexing and searching for appropriate structure map instances.
     */
    public java.util.List<UsageContext> useContext() {
        return getList(UsageContext.class, FhirPropertyNames.PROPERTY_USE_CONTEXT);
    }

    /**
     * A legal or geographic region in which the structure map is intended to
     * be used.
     */
    public java.util.List<CodeableConcept> jurisdiction() {
        return getList(CodeableConcept.class, FhirPropertyNames.PROPERTY_JURISDICTION);
    }

    /**
     * Explanation of why this structure map is needed and why it has been
     * designed as it has.
     */
    public String purpose() {
        return getString(FhirPropertyNames.PROPERTY_PURPOSE);
    }

    /**
     * A copyright statement relating to the structure map and/or its
     * contents. Copyright statements are generally legal restrictions on the
     * use and publishing of the structure map.
     */
    public String copyright() {
        return getString(FhirPropertyNames.PROPERTY_COPYRIGHT);
    }

    /**
     * A structure definition used by this map. The structure definition may
     * describe instances that are converted, or the instances that are
     * produced.
     */
    public java.util.List<StructureMapStructure> structure() {
        return getList(StructureMapStructure.class, FhirPropertyNames.PROPERTY_STRUCTURE);
    }

    /**
     * Other maps used by this map (canonical URLs).
     */
    public java.util.List<String> importValue() {
        return getList(String.class, FhirPropertyNames.PROPERTY_IMPORT);
    }

    /**
     * Organizes the mapping into manageable chunks for human review/ease of
     * maintenance.
     */
    public java.util.List<StructureMapGroup> group() {
        return getList(StructureMapGroup.class, FhirPropertyNames.PROPERTY_GROUP);
    }

    public static final class Builder extends DomainResource.Builder<StructureMap, StructureMap.Builder> {

        private Builder() {
            super(RESOURCE_TYPE);
        }

        private Builder(final JsonObject data) {
            super(RESOURCE_TYPE, data);
        }

        public Builder url(final java.net.URI url) {
            b.add(FhirPropertyNames.PROPERTY_URL, url.toString());
            return this;
        }

        public Builder identifier(final java.util.List<Identifier> identifier) {
            b.add(FhirPropertyNames.PROPERTY_IDENTIFIER, FhirObject.toArray(identifier));
            return this;
        }

        public Builder version(final String version) {
            b.add(FhirPropertyNames.PROPERTY_VERSION, version);
            return this;
        }

        public Builder name(final String name) {
            b.add(FhirPropertyNames.PROPERTY_NAME, name);
            return this;
        }

        public Builder title(final String title) {
            b.add(FhirPropertyNames.PROPERTY_TITLE, title);
            return this;
        }

        public Builder status(final String status) {
            b.add(FhirPropertyNames.PROPERTY_STATUS, status);
            return this;
        }

        public Builder experimental(final Boolean experimental) {
            b.add(FhirPropertyNames.PROPERTY_EXPERIMENTAL, experimental);
            return this;
        }

        public Builder date(final java.time.Instant date) {
            b.add(FhirPropertyNames.PROPERTY_DATE, date.toString());
            return this;
        }

        public Builder publisher(final String publisher) {
            b.add(FhirPropertyNames.PROPERTY_PUBLISHER, publisher);
            return this;
        }

        public Builder contact(final java.util.List<ContactDetail> contact) {
            b.add(FhirPropertyNames.PROPERTY_CONTACT, FhirObject.toArray(contact));
            return this;
        }

        public Builder description(final String description) {
            b.add(FhirPropertyNames.PROPERTY_DESCRIPTION, description);
            return this;
        }

        public Builder useContext(final java.util.List<UsageContext> useContext) {
            b.add(FhirPropertyNames.PROPERTY_USE_CONTEXT, FhirObject.toArray(useContext));
            return this;
        }

        public Builder jurisdiction(final java.util.List<CodeableConcept> jurisdiction) {
            b.add(FhirPropertyNames.PROPERTY_JURISDICTION, FhirObject.toArray(jurisdiction));
            return this;
        }

        public Builder purpose(final String purpose) {
            b.add(FhirPropertyNames.PROPERTY_PURPOSE, purpose);
            return this;
        }

        public Builder copyright(final String copyright) {
            b.add(FhirPropertyNames.PROPERTY_COPYRIGHT, copyright);
            return this;
        }

        public Builder structure(final java.util.List<StructureMapStructure> structure) {
            b.add(FhirPropertyNames.PROPERTY_STRUCTURE, FhirObject.toArray(structure));
            return this;
        }

        public Builder importValue(final java.util.List<String> importValue) {
            b.add(FhirPropertyNames.PROPERTY_IMPORT, FhirObject.toStringArray(importValue));
            return this;
        }

        public Builder group(final java.util.List<StructureMapGroup> group) {
            b.add(FhirPropertyNames.PROPERTY_GROUP, FhirObject.toArray(group));
            return this;
        }

        public StructureMap build() {
            return new StructureMap(b.build());
        }
    }

    /**
     * A Map of relationships between 2 structures that can be used to
     * transform data.
     */
    public static class StructureMapDependent extends FhirObject {
        public static final String RESOURCE_TYPE = "StructureMapDependent";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public StructureMapDependent(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Name of a rule or group to apply.
         */
        public String name() {
            return getString(FhirPropertyNames.PROPERTY_NAME);
        }

        /**
         * Variable to pass to the rule or group.
         */
        public java.util.List<String> variable() {
            return getList(String.class, FhirPropertyNames.PROPERTY_VARIABLE);
        }

        public static final class Builder extends FhirObject.Builder<StructureMapDependent, StructureMapDependent.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder name(final String name) {
                b.add(FhirPropertyNames.PROPERTY_NAME, name);
                return this;
            }

            public Builder variable(final java.util.List<String> variable) {
                b.add(FhirPropertyNames.PROPERTY_VARIABLE, FhirObject.toStringArray(variable));
                return this;
            }

            public StructureMapDependent build() {
                return new StructureMapDependent(b.build());
            }
        }
    }

    /**
     * A Map of relationships between 2 structures that can be used to
     * transform data.
     */
    public static class StructureMapGroup extends FhirObject {
        public static final String RESOURCE_TYPE = "StructureMapGroup";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public StructureMapGroup(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * A unique name for the group for the convenience of human readers.
         */
        public String name() {
            return getString(FhirPropertyNames.PROPERTY_NAME);
        }

        /**
         * Another group that this group adds rules to.
         */
        public String extendsValue() {
            return getString(FhirPropertyNames.PROPERTY_EXTENDS);
        }

        /**
         * If this is the default rule set to apply for the source type or this
         * combination of types.
         */
        public String typeMode() {
            return getString(FhirPropertyNames.PROPERTY_TYPE_MODE);
        }

        /**
         * Additional supporting documentation that explains the purpose of the
         * group and the types of mappings within it.
         */
        public String documentation() {
            return getString(FhirPropertyNames.PROPERTY_DOCUMENTATION);
        }

        /**
         * A name assigned to an instance of data. The instance must be provided
         * when the mapping is invoked.
         */
        public java.util.List<StructureMapInput> input() {
            return getList(StructureMapInput.class, FhirPropertyNames.PROPERTY_INPUT);
        }

        /**
         * Transform Rule from source to target.
         */
        public java.util.List<StructureMapRule> rule() {
            return getList(StructureMapRule.class, FhirPropertyNames.PROPERTY_RULE);
        }

        public static final class Builder extends FhirObject.Builder<StructureMapGroup, StructureMapGroup.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder name(final String name) {
                b.add(FhirPropertyNames.PROPERTY_NAME, name);
                return this;
            }

            public Builder extendsValue(final String extendsValue) {
                b.add(FhirPropertyNames.PROPERTY_EXTENDS, extendsValue);
                return this;
            }

            public Builder typeMode(final String typeMode) {
                b.add(FhirPropertyNames.PROPERTY_TYPE_MODE, typeMode);
                return this;
            }

            public Builder documentation(final String documentation) {
                b.add(FhirPropertyNames.PROPERTY_DOCUMENTATION, documentation);
                return this;
            }

            public Builder input(final java.util.List<StructureMapInput> input) {
                b.add(FhirPropertyNames.PROPERTY_INPUT, FhirObject.toArray(input));
                return this;
            }

            public Builder rule(final java.util.List<StructureMapRule> rule) {
                b.add(FhirPropertyNames.PROPERTY_RULE, FhirObject.toArray(rule));
                return this;
            }

            public StructureMapGroup build() {
                return new StructureMapGroup(b.build());
            }
        }
    }

    /**
     * A Map of relationships between 2 structures that can be used to
     * transform data.
     */
    public static class StructureMapInput extends FhirObject {
        public static final String RESOURCE_TYPE = "StructureMapInput";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public StructureMapInput(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Name for this instance of data.
         */
        public String name() {
            return getString(FhirPropertyNames.PROPERTY_NAME);
        }

        /**
         * Type for this instance of data.
         */
        public String type() {
            return getString(FhirPropertyNames.PROPERTY_TYPE);
        }

        /**
         * Mode for this instance of data.
         */
        public String mode() {
            return getString(FhirPropertyNames.PROPERTY_MODE);
        }

        /**
         * Documentation for this instance of data.
         */
        public String documentation() {
            return getString(FhirPropertyNames.PROPERTY_DOCUMENTATION);
        }

        public static final class Builder extends FhirObject.Builder<StructureMapInput, StructureMapInput.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder name(final String name) {
                b.add(FhirPropertyNames.PROPERTY_NAME, name);
                return this;
            }

            public Builder type(final String type) {
                b.add(FhirPropertyNames.PROPERTY_TYPE, type);
                return this;
            }

            public Builder mode(final String mode) {
                b.add(FhirPropertyNames.PROPERTY_MODE, mode);
                return this;
            }

            public Builder documentation(final String documentation) {
                b.add(FhirPropertyNames.PROPERTY_DOCUMENTATION, documentation);
                return this;
            }

            public StructureMapInput build() {
                return new StructureMapInput(b.build());
            }
        }
    }

    /**
     * A Map of relationships between 2 structures that can be used to
     * transform data.
     */
    public static class StructureMapParameter extends FhirObject {
        public static final String RESOURCE_TYPE = "StructureMapParameter";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public StructureMapParameter(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Parameter value - variable or literal.
         */
        public String valueId() {
            return getString(FhirPropertyNames.PROPERTY_VALUE_ID);
        }

        /**
         * Parameter value - variable or literal.
         */
        public String valueString() {
            return getString(FhirPropertyNames.PROPERTY_VALUE_STRING);
        }

        /**
         * Parameter value - variable or literal.
         */
        public Boolean valueBoolean() {
            return data.getBoolean(FhirPropertyNames.PROPERTY_VALUE_BOOLEAN);
        }

        /**
         * Parameter value - variable or literal.
         */
        public Integer valueInteger() {
            return data.getInt(FhirPropertyNames.PROPERTY_VALUE_INTEGER);
        }

        /**
         * Parameter value - variable or literal.
         */
        public Integer valueDecimal() {
            return data.getInt(FhirPropertyNames.PROPERTY_VALUE_DECIMAL);
        }

        public static final class Builder extends FhirObject.Builder<StructureMapParameter, StructureMapParameter.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder valueId(final String valueId) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_ID, valueId);
                return this;
            }

            public Builder valueString(final String valueString) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_STRING, valueString);
                return this;
            }

            public Builder valueBoolean(final Boolean valueBoolean) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_BOOLEAN, valueBoolean);
                return this;
            }

            public Builder valueInteger(final Integer valueInteger) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_INTEGER, valueInteger);
                return this;
            }

            public Builder valueDecimal(final Integer valueDecimal) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_DECIMAL, valueDecimal);
                return this;
            }

            public StructureMapParameter build() {
                return new StructureMapParameter(b.build());
            }
        }
    }

    /**
     * A Map of relationships between 2 structures that can be used to
     * transform data.
     */
    public static class StructureMapRule extends FhirObject {
        public static final String RESOURCE_TYPE = "StructureMapRule";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public StructureMapRule(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Name of the rule for internal references.
         */
        public String name() {
            return getString(FhirPropertyNames.PROPERTY_NAME);
        }

        /**
         * Source inputs to the mapping.
         */
        public java.util.List<StructureMapSource> source() {
            return getList(StructureMapSource.class, FhirPropertyNames.PROPERTY_SOURCE);
        }

        /**
         * Content to create because of this mapping rule.
         */
        public java.util.List<StructureMapTarget> target() {
            return getList(StructureMapTarget.class, FhirPropertyNames.PROPERTY_TARGET);
        }

        /**
         * Rules contained in this rule.
         */
        public java.util.List<StructureMapRule> rule() {
            return getList(StructureMapRule.class, FhirPropertyNames.PROPERTY_RULE);
        }

        /**
         * Which other rules to apply in the context of this rule.
         */
        public java.util.List<StructureMapDependent> dependent() {
            return getList(StructureMapDependent.class, FhirPropertyNames.PROPERTY_DEPENDENT);
        }

        /**
         * Documentation for this instance of data.
         */
        public String documentation() {
            return getString(FhirPropertyNames.PROPERTY_DOCUMENTATION);
        }

        public static final class Builder extends FhirObject.Builder<StructureMapRule, StructureMapRule.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder name(final String name) {
                b.add(FhirPropertyNames.PROPERTY_NAME, name);
                return this;
            }

            public Builder source(final java.util.List<StructureMapSource> source) {
                b.add(FhirPropertyNames.PROPERTY_SOURCE, FhirObject.toArray(source));
                return this;
            }

            public Builder target(final java.util.List<StructureMapTarget> target) {
                b.add(FhirPropertyNames.PROPERTY_TARGET, FhirObject.toArray(target));
                return this;
            }

            public Builder rule(final java.util.List<StructureMapRule> rule) {
                b.add(FhirPropertyNames.PROPERTY_RULE, FhirObject.toArray(rule));
                return this;
            }

            public Builder dependent(final java.util.List<StructureMapDependent> dependent) {
                b.add(FhirPropertyNames.PROPERTY_DEPENDENT, FhirObject.toArray(dependent));
                return this;
            }

            public Builder documentation(final String documentation) {
                b.add(FhirPropertyNames.PROPERTY_DOCUMENTATION, documentation);
                return this;
            }

            public StructureMapRule build() {
                return new StructureMapRule(b.build());
            }
        }
    }

    /**
     * A Map of relationships between 2 structures that can be used to
     * transform data.
     */
    public static class StructureMapSource extends FhirObject {
        public static final String RESOURCE_TYPE = "StructureMapSource";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public StructureMapSource(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Type or variable this rule applies to.
         */
        public String context() {
            return getString(FhirPropertyNames.PROPERTY_CONTEXT);
        }

        /**
         * Specified minimum cardinality for the element. This is optional; if
         * present, it acts an implicit check on the input content.
         */
        public Integer min() {
            return data.getInt(FhirPropertyNames.PROPERTY_MIN);
        }

        /**
         * Specified maximum cardinality for the element - a number or a &quot;*&quot;.
         * This is optional; if present, it acts an implicit check on the input
         * content (* just serves as documentation; it's the default value).
         */
        public String max() {
            return getString(FhirPropertyNames.PROPERTY_MAX);
        }

        /**
         * Specified type for the element. This works as a condition on the
         * mapping - use for polymorphic elements.
         */
        public String type() {
            return getString(FhirPropertyNames.PROPERTY_TYPE);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public String defaultValueBase64Binary() {
            return getString(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_BASE64_BINARY);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Boolean defaultValueBoolean() {
            return data.getBoolean(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_BOOLEAN);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public String defaultValueCanonical() {
            return getString(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_CANONICAL);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public String defaultValueCode() {
            return getString(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_CODE);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public String defaultValueDate() {
            return getString(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_DATE);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public String defaultValueDateTime() {
            return getString(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_DATE_TIME);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Integer defaultValueDecimal() {
            return data.getInt(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_DECIMAL);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public String defaultValueId() {
            return getString(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_ID);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public String defaultValueInstant() {
            return getString(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_INSTANT);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Integer defaultValueInteger() {
            return data.getInt(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_INTEGER);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public String defaultValueMarkdown() {
            return getString(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_MARKDOWN);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public String defaultValueOid() {
            return getString(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_OID);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Integer defaultValuePositiveInt() {
            return data.getInt(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_POSITIVE_INT);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public String defaultValueString() {
            return getString(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_STRING);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public String defaultValueTime() {
            return getString(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_TIME);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Integer defaultValueUnsignedInt() {
            return data.getInt(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_UNSIGNED_INT);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public String defaultValueUri() {
            return getString(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_URI);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public String defaultValueUrl() {
            return getString(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_URL);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public String defaultValueUuid() {
            return getString(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_UUID);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Address defaultValueAddress() {
            return getObject(Address.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_ADDRESS);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Age defaultValueAge() {
            return getObject(Age.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_AGE);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Annotation defaultValueAnnotation() {
            return getObject(Annotation.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_ANNOTATION);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Attachment defaultValueAttachment() {
            return getObject(Attachment.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_ATTACHMENT);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public CodeableConcept defaultValueCodeableConcept() {
            return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_CODEABLE_CONCEPT);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Coding defaultValueCoding() {
            return getObject(Coding.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_CODING);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public ContactPoint defaultValueContactPoint() {
            return getObject(ContactPoint.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_CONTACT_POINT);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Count defaultValueCount() {
            return getObject(Count.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_COUNT);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Distance defaultValueDistance() {
            return getObject(Distance.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_DISTANCE);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Duration defaultValueDuration() {
            return getObject(Duration.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_DURATION);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public HumanName defaultValueHumanName() {
            return getObject(HumanName.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_HUMAN_NAME);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Identifier defaultValueIdentifier() {
            return getObject(Identifier.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_IDENTIFIER);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Money defaultValueMoney() {
            return getObject(Money.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_MONEY);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Period defaultValuePeriod() {
            return getObject(Period.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_PERIOD);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Quantity defaultValueQuantity() {
            return getObject(Quantity.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_QUANTITY);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Range defaultValueRange() {
            return getObject(Range.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_RANGE);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Ratio defaultValueRatio() {
            return getObject(Ratio.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_RATIO);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Reference defaultValueReference() {
            return getObject(Reference.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_REFERENCE);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public SampledData defaultValueSampledData() {
            return getObject(SampledData.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_SAMPLED_DATA);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Signature defaultValueSignature() {
            return getObject(Signature.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_SIGNATURE);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Timing defaultValueTiming() {
            return getObject(Timing.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_TIMING);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public ContactDetail defaultValueContactDetail() {
            return getObject(ContactDetail.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_CONTACT_DETAIL);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Contributor defaultValueContributor() {
            return getObject(Contributor.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_CONTRIBUTOR);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public DataRequirement defaultValueDataRequirement() {
            return getObject(DataRequirement.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_DATA_REQUIREMENT);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Expression defaultValueExpression() {
            return getObject(Expression.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_EXPRESSION);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public ParameterDefinition defaultValueParameterDefinition() {
            return getObject(ParameterDefinition.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_PARAMETER_DEFINITION);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public RelatedArtifact defaultValueRelatedArtifact() {
            return getObject(RelatedArtifact.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_RELATED_ARTIFACT);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public TriggerDefinition defaultValueTriggerDefinition() {
            return getObject(TriggerDefinition.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_TRIGGER_DEFINITION);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public UsageContext defaultValueUsageContext() {
            return getObject(UsageContext.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_USAGE_CONTEXT);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Dosage defaultValueDosage() {
            return getObject(Dosage.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_DOSAGE);
        }

        /**
         * A value to use if there is no existing value in the source object.
         */
        public Meta defaultValueMeta() {
            return getObject(Meta.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_META);
        }

        /**
         * Optional field for this source.
         */
        public String element() {
            return getString(FhirPropertyNames.PROPERTY_ELEMENT);
        }

        /**
         * How to handle the list mode for this element.
         */
        public String listMode() {
            return getString(FhirPropertyNames.PROPERTY_LIST_MODE);
        }

        /**
         * Named context for field, if a field is specified.
         */
        public String variable() {
            return getString(FhirPropertyNames.PROPERTY_VARIABLE);
        }

        /**
         * FHIRPath expression  - must be true or the rule does not apply.
         */
        public String condition() {
            return getString(FhirPropertyNames.PROPERTY_CONDITION);
        }

        /**
         * FHIRPath expression  - must be true or the mapping engine throws an
         * error instead of completing.
         */
        public String check() {
            return getString(FhirPropertyNames.PROPERTY_CHECK);
        }

        /**
         * A FHIRPath expression which specifies a message to put in the
         * transform log when content matching the source rule is found.
         */
        public String logMessage() {
            return getString(FhirPropertyNames.PROPERTY_LOG_MESSAGE);
        }

        public static final class Builder extends FhirObject.Builder<StructureMapSource, StructureMapSource.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder context(final String context) {
                b.add(FhirPropertyNames.PROPERTY_CONTEXT, context);
                return this;
            }

            public Builder min(final Integer min) {
                b.add(FhirPropertyNames.PROPERTY_MIN, min);
                return this;
            }

            public Builder max(final String max) {
                b.add(FhirPropertyNames.PROPERTY_MAX, max);
                return this;
            }

            public Builder type(final String type) {
                b.add(FhirPropertyNames.PROPERTY_TYPE, type);
                return this;
            }

            public Builder defaultValueBase64Binary(final String defaultValueBase64Binary) {
                b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_BASE64_BINARY, defaultValueBase64Binary);
                return this;
            }

            public Builder defaultValueBoolean(final Boolean defaultValueBoolean) {
                b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_BOOLEAN, defaultValueBoolean);
                return this;
            }

            public Builder defaultValueCanonical(final String defaultValueCanonical) {
                b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_CANONICAL, defaultValueCanonical);
                return this;
            }

            public Builder defaultValueCode(final String defaultValueCode) {
                b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_CODE, defaultValueCode);
                return this;
            }

            public Builder defaultValueDate(final String defaultValueDate) {
                b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_DATE, defaultValueDate);
                return this;
            }

            public Builder defaultValueDateTime(final String defaultValueDateTime) {
                b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_DATE_TIME, defaultValueDateTime);
                return this;
            }

            public Builder defaultValueDecimal(final Integer defaultValueDecimal) {
                b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_DECIMAL, defaultValueDecimal);
                return this;
            }

            public Builder defaultValueId(final String defaultValueId) {
                b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_ID, defaultValueId);
                return this;
            }

            public Builder defaultValueInstant(final String defaultValueInstant) {
                b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_INSTANT, defaultValueInstant);
                return this;
            }

            public Builder defaultValueInteger(final Integer defaultValueInteger) {
                b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_INTEGER, defaultValueInteger);
                return this;
            }

            public Builder defaultValueMarkdown(final String defaultValueMarkdown) {
                b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_MARKDOWN, defaultValueMarkdown);
                return this;
            }

            public Builder defaultValueOid(final String defaultValueOid) {
                b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_OID, defaultValueOid);
                return this;
            }

            public Builder defaultValuePositiveInt(final Integer defaultValuePositiveInt) {
                b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_POSITIVE_INT, defaultValuePositiveInt);
                return this;
            }

            public Builder defaultValueString(final String defaultValueString) {
                b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_STRING, defaultValueString);
                return this;
            }

            public Builder defaultValueTime(final String defaultValueTime) {
                b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_TIME, defaultValueTime);
                return this;
            }

            public Builder defaultValueUnsignedInt(final Integer defaultValueUnsignedInt) {
                b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_UNSIGNED_INT, defaultValueUnsignedInt);
                return this;
            }

            public Builder defaultValueUri(final String defaultValueUri) {
                b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_URI, defaultValueUri);
                return this;
            }

            public Builder defaultValueUrl(final String defaultValueUrl) {
                b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_URL, defaultValueUrl);
                return this;
            }

            public Builder defaultValueUuid(final String defaultValueUuid) {
                b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_UUID, defaultValueUuid);
                return this;
            }

            public Builder defaultValueAddress(final Address defaultValueAddress) {
                b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_ADDRESS, defaultValueAddress);
                return this;
            }

            public Builder defaultValueAge(final Age defaultValueAge) {
                b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_AGE, defaultValueAge);
                return this;
            }

            public Builder defaultValueAnnotation(final Annotation defaultValueAnnotation) {
                b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_ANNOTATION, defaultValueAnnotation);
                return this;
            }

            public Builder defaultValueAttachment(final Attachment defaultValueAttachment) {
                b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_ATTACHMENT, defaultValueAttachment);
                return this;
            }

            public Builder defaultValueCodeableConcept(final CodeableConcept defaultValueCodeableConcept) {
                b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_CODEABLE_CONCEPT, defaultValueCodeableConcept);
                return this;
            }

            public Builder defaultValueCoding(final Coding defaultValueCoding) {
                b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_CODING, defaultValueCoding);
                return this;
            }

            public Builder defaultValueContactPoint(final ContactPoint defaultValueContactPoint) {
                b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_CONTACT_POINT, defaultValueContactPoint);
                return this;
            }

            public Builder defaultValueCount(final Count defaultValueCount) {
                b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_COUNT, defaultValueCount);
                return this;
            }

            public Builder defaultValueDistance(final Distance defaultValueDistance) {
                b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_DISTANCE, defaultValueDistance);
                return this;
            }

            public Builder defaultValueDuration(final Duration defaultValueDuration) {
                b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_DURATION, defaultValueDuration);
                return this;
            }

            public Builder defaultValueHumanName(final HumanName defaultValueHumanName) {
                b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_HUMAN_NAME, defaultValueHumanName);
                return this;
            }

            public Builder defaultValueIdentifier(final Identifier defaultValueIdentifier) {
                b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_IDENTIFIER, defaultValueIdentifier);
                return this;
            }

            public Builder defaultValueMoney(final Money defaultValueMoney) {
                b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_MONEY, defaultValueMoney);
                return this;
            }

            public Builder defaultValuePeriod(final Period defaultValuePeriod) {
                b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_PERIOD, defaultValuePeriod);
                return this;
            }

            public Builder defaultValueQuantity(final Quantity defaultValueQuantity) {
                b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_QUANTITY, defaultValueQuantity);
                return this;
            }

            public Builder defaultValueRange(final Range defaultValueRange) {
                b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_RANGE, defaultValueRange);
                return this;
            }

            public Builder defaultValueRatio(final Ratio defaultValueRatio) {
                b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_RATIO, defaultValueRatio);
                return this;
            }

            public Builder defaultValueReference(final Reference defaultValueReference) {
                b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_REFERENCE, defaultValueReference);
                return this;
            }

            public Builder defaultValueSampledData(final SampledData defaultValueSampledData) {
                b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_SAMPLED_DATA, defaultValueSampledData);
                return this;
            }

            public Builder defaultValueSignature(final Signature defaultValueSignature) {
                b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_SIGNATURE, defaultValueSignature);
                return this;
            }

            public Builder defaultValueTiming(final Timing defaultValueTiming) {
                b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_TIMING, defaultValueTiming);
                return this;
            }

            public Builder defaultValueContactDetail(final ContactDetail defaultValueContactDetail) {
                b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_CONTACT_DETAIL, defaultValueContactDetail);
                return this;
            }

            public Builder defaultValueContributor(final Contributor defaultValueContributor) {
                b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_CONTRIBUTOR, defaultValueContributor);
                return this;
            }

            public Builder defaultValueDataRequirement(final DataRequirement defaultValueDataRequirement) {
                b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_DATA_REQUIREMENT, defaultValueDataRequirement);
                return this;
            }

            public Builder defaultValueExpression(final Expression defaultValueExpression) {
                b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_EXPRESSION, defaultValueExpression);
                return this;
            }

            public Builder defaultValueParameterDefinition(final ParameterDefinition defaultValueParameterDefinition) {
                b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_PARAMETER_DEFINITION, defaultValueParameterDefinition);
                return this;
            }

            public Builder defaultValueRelatedArtifact(final RelatedArtifact defaultValueRelatedArtifact) {
                b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_RELATED_ARTIFACT, defaultValueRelatedArtifact);
                return this;
            }

            public Builder defaultValueTriggerDefinition(final TriggerDefinition defaultValueTriggerDefinition) {
                b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_TRIGGER_DEFINITION, defaultValueTriggerDefinition);
                return this;
            }

            public Builder defaultValueUsageContext(final UsageContext defaultValueUsageContext) {
                b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_USAGE_CONTEXT, defaultValueUsageContext);
                return this;
            }

            public Builder defaultValueDosage(final Dosage defaultValueDosage) {
                b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_DOSAGE, defaultValueDosage);
                return this;
            }

            public Builder defaultValueMeta(final Meta defaultValueMeta) {
                b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_META, defaultValueMeta);
                return this;
            }

            public Builder element(final String element) {
                b.add(FhirPropertyNames.PROPERTY_ELEMENT, element);
                return this;
            }

            public Builder listMode(final String listMode) {
                b.add(FhirPropertyNames.PROPERTY_LIST_MODE, listMode);
                return this;
            }

            public Builder variable(final String variable) {
                b.add(FhirPropertyNames.PROPERTY_VARIABLE, variable);
                return this;
            }

            public Builder condition(final String condition) {
                b.add(FhirPropertyNames.PROPERTY_CONDITION, condition);
                return this;
            }

            public Builder check(final String check) {
                b.add(FhirPropertyNames.PROPERTY_CHECK, check);
                return this;
            }

            public Builder logMessage(final String logMessage) {
                b.add(FhirPropertyNames.PROPERTY_LOG_MESSAGE, logMessage);
                return this;
            }

            public StructureMapSource build() {
                return new StructureMapSource(b.build());
            }
        }
    }

    /**
     * A Map of relationships between 2 structures that can be used to
     * transform data.
     */
    public static class StructureMapStructure extends FhirObject {
        public static final String RESOURCE_TYPE = "StructureMapStructure";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public StructureMapStructure(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * The canonical reference to the structure.
         */
        public String url() {
            return getString(FhirPropertyNames.PROPERTY_URL);
        }

        /**
         * How the referenced structure is used in this mapping.
         */
        public String mode() {
            return getString(FhirPropertyNames.PROPERTY_MODE);
        }

        /**
         * The name used for this type in the map.
         */
        public String alias() {
            return getString(FhirPropertyNames.PROPERTY_ALIAS);
        }

        /**
         * Documentation that describes how the structure is used in the mapping.
         */
        public String documentation() {
            return getString(FhirPropertyNames.PROPERTY_DOCUMENTATION);
        }

        public static final class Builder extends FhirObject.Builder<StructureMapStructure, StructureMapStructure.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder url(final String url) {
                b.add(FhirPropertyNames.PROPERTY_URL, url);
                return this;
            }

            public Builder mode(final String mode) {
                b.add(FhirPropertyNames.PROPERTY_MODE, mode);
                return this;
            }

            public Builder alias(final String alias) {
                b.add(FhirPropertyNames.PROPERTY_ALIAS, alias);
                return this;
            }

            public Builder documentation(final String documentation) {
                b.add(FhirPropertyNames.PROPERTY_DOCUMENTATION, documentation);
                return this;
            }

            public StructureMapStructure build() {
                return new StructureMapStructure(b.build());
            }
        }
    }

    /**
     * A Map of relationships between 2 structures that can be used to
     * transform data.
     */
    public static class StructureMapTarget extends FhirObject {
        public static final String RESOURCE_TYPE = "StructureMapTarget";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public StructureMapTarget(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Type or variable this rule applies to.
         */
        public String context() {
            return getString(FhirPropertyNames.PROPERTY_CONTEXT);
        }

        /**
         * How to interpret the context.
         */
        public String contextType() {
            return getString(FhirPropertyNames.PROPERTY_CONTEXT_TYPE);
        }

        /**
         * Field to create in the context.
         */
        public String element() {
            return getString(FhirPropertyNames.PROPERTY_ELEMENT);
        }

        /**
         * Named context for field, if desired, and a field is specified.
         */
        public String variable() {
            return getString(FhirPropertyNames.PROPERTY_VARIABLE);
        }

        /**
         * If field is a list, how to manage the list.
         */
        public java.util.List<String> listMode() {
            return getList(String.class, FhirPropertyNames.PROPERTY_LIST_MODE);
        }

        /**
         * Internal rule reference for shared list items.
         */
        public String listRuleId() {
            return getString(FhirPropertyNames.PROPERTY_LIST_RULE_ID);
        }

        /**
         * How the data is copied / created.
         */
        public String transform() {
            return getString(FhirPropertyNames.PROPERTY_TRANSFORM);
        }

        /**
         * Parameters to the transform.
         */
        public java.util.List<StructureMapParameter> parameter() {
            return getList(StructureMapParameter.class, FhirPropertyNames.PROPERTY_PARAMETER);
        }

        public static final class Builder extends FhirObject.Builder<StructureMapTarget, StructureMapTarget.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder context(final String context) {
                b.add(FhirPropertyNames.PROPERTY_CONTEXT, context);
                return this;
            }

            public Builder contextType(final String contextType) {
                b.add(FhirPropertyNames.PROPERTY_CONTEXT_TYPE, contextType);
                return this;
            }

            public Builder element(final String element) {
                b.add(FhirPropertyNames.PROPERTY_ELEMENT, element);
                return this;
            }

            public Builder variable(final String variable) {
                b.add(FhirPropertyNames.PROPERTY_VARIABLE, variable);
                return this;
            }

            public Builder listMode(final java.util.List<String> listMode) {
                b.add(FhirPropertyNames.PROPERTY_LIST_MODE, FhirObject.toStringArray(listMode));
                return this;
            }

            public Builder listRuleId(final String listRuleId) {
                b.add(FhirPropertyNames.PROPERTY_LIST_RULE_ID, listRuleId);
                return this;
            }

            public Builder transform(final String transform) {
                b.add(FhirPropertyNames.PROPERTY_TRANSFORM, transform);
                return this;
            }

            public Builder parameter(final java.util.List<StructureMapParameter> parameter) {
                b.add(FhirPropertyNames.PROPERTY_PARAMETER, FhirObject.toArray(parameter));
                return this;
            }

            public StructureMapTarget build() {
                return new StructureMapTarget(b.build());
            }
        }
    }
}
