/*
 * Generated by com.medplum.generator.Generator
 * Do not edit manually.
 */

package com.medplum.fhir.r4.types;

import jakarta.json.JsonObject;

import com.medplum.fhir.r4.FhirPropertyNames;

/**
 * Raw data describing a biological sequence.
 */
public class MolecularSequence extends DomainResource {
    public static final String RESOURCE_TYPE = "MolecularSequence";

    public static Builder create() {
        return new Builder();
    }

    public static Builder create(final JsonObject data) {
        return new Builder(data);
    }

    public MolecularSequence(final JsonObject data) {
        super(data);
    }

    /**
     * A unique identifier for this particular sequence instance. This is a
     * FHIR-defined id.
     */
    public java.util.List<Identifier> identifier() {
        return getList(Identifier.class, FhirPropertyNames.PROPERTY_IDENTIFIER);
    }

    /**
     * Amino Acid Sequence/ DNA Sequence / RNA Sequence.
     */
    public String type() {
        return getString(FhirPropertyNames.PROPERTY_TYPE);
    }

    /**
     * Whether the sequence is numbered starting at 0 (0-based numbering or
     * coordinates, inclusive start, exclusive end) or starting at 1 (1-based
     * numbering, inclusive start and inclusive end).
     */
    public Integer coordinateSystem() {
        return data.getInt(FhirPropertyNames.PROPERTY_COORDINATE_SYSTEM);
    }

    /**
     * The patient whose sequencing results are described by this resource.
     */
    public Reference patient() {
        return getObject(Reference.class, FhirPropertyNames.PROPERTY_PATIENT);
    }

    /**
     * Specimen used for sequencing.
     */
    public Reference specimen() {
        return getObject(Reference.class, FhirPropertyNames.PROPERTY_SPECIMEN);
    }

    /**
     * The method for sequencing, for example, chip information.
     */
    public Reference device() {
        return getObject(Reference.class, FhirPropertyNames.PROPERTY_DEVICE);
    }

    /**
     * The organization or lab that should be responsible for this result.
     */
    public Reference performer() {
        return getObject(Reference.class, FhirPropertyNames.PROPERTY_PERFORMER);
    }

    /**
     * The number of copies of the sequence of interest. (RNASeq).
     */
    public Quantity quantity() {
        return getObject(Quantity.class, FhirPropertyNames.PROPERTY_QUANTITY);
    }

    /**
     * A sequence that is used as a reference to describe variants that are
     * present in a sequence analyzed.
     */
    public MolecularSequenceReferenceSeq referenceSeq() {
        return getObject(MolecularSequenceReferenceSeq.class, FhirPropertyNames.PROPERTY_REFERENCE_SEQ);
    }

    /**
     * The definition of variant here originates from Sequence ontology
     * ([variant_of](http://www.sequenceontology.org/browser/current_svn/term/variant_of)).
     * This element can represent amino acid or nucleic sequence
     * change(including insertion,deletion,SNP,etc.)  It can represent some
     * complex mutation or segment variation with the assist of CIGAR string.
     */
    public java.util.List<MolecularSequenceVariant> variant() {
        return getList(MolecularSequenceVariant.class, FhirPropertyNames.PROPERTY_VARIANT);
    }

    /**
     * Sequence that was observed. It is the result marked by referenceSeq
     * along with variant records on referenceSeq. This shall start from
     * referenceSeq.windowStart and end by referenceSeq.windowEnd.
     */
    public String observedSeq() {
        return getString(FhirPropertyNames.PROPERTY_OBSERVED_SEQ);
    }

    /**
     * An experimental feature attribute that defines the quality of the
     * feature in a quantitative way, such as a phred quality score
     * ([SO:0001686](http://www.sequenceontology.org/browser/current_svn/term/SO:0001686)).
     */
    public java.util.List<MolecularSequenceQuality> quality() {
        return getList(MolecularSequenceQuality.class, FhirPropertyNames.PROPERTY_QUALITY);
    }

    /**
     * Coverage (read depth or depth) is the average number of reads
     * representing a given nucleotide in the reconstructed sequence.
     */
    public Integer readCoverage() {
        return data.getInt(FhirPropertyNames.PROPERTY_READ_COVERAGE);
    }

    /**
     * Configurations of the external repository. The repository shall store
     * target's observedSeq or records related with target's observedSeq.
     */
    public java.util.List<MolecularSequenceRepository> repository() {
        return getList(MolecularSequenceRepository.class, FhirPropertyNames.PROPERTY_REPOSITORY);
    }

    /**
     * Pointer to next atomic sequence which at most contains one variant.
     */
    public java.util.List<Reference> pointer() {
        return getList(Reference.class, FhirPropertyNames.PROPERTY_POINTER);
    }

    /**
     * Information about chromosome structure variation.
     */
    public java.util.List<MolecularSequenceStructureVariant> structureVariant() {
        return getList(MolecularSequenceStructureVariant.class, FhirPropertyNames.PROPERTY_STRUCTURE_VARIANT);
    }

    public static final class Builder extends DomainResource.Builder<MolecularSequence, MolecularSequence.Builder> {

        private Builder() {
            super(RESOURCE_TYPE);
        }

        private Builder(final JsonObject data) {
            super(RESOURCE_TYPE, data);
        }

        public Builder identifier(final java.util.List<Identifier> identifier) {
            b.add(FhirPropertyNames.PROPERTY_IDENTIFIER, FhirObject.toArray(identifier));
            return this;
        }

        public Builder type(final String type) {
            b.add(FhirPropertyNames.PROPERTY_TYPE, type);
            return this;
        }

        public Builder coordinateSystem(final Integer coordinateSystem) {
            b.add(FhirPropertyNames.PROPERTY_COORDINATE_SYSTEM, coordinateSystem);
            return this;
        }

        public Builder patient(final Reference patient) {
            b.add(FhirPropertyNames.PROPERTY_PATIENT, patient);
            return this;
        }

        public Builder specimen(final Reference specimen) {
            b.add(FhirPropertyNames.PROPERTY_SPECIMEN, specimen);
            return this;
        }

        public Builder device(final Reference device) {
            b.add(FhirPropertyNames.PROPERTY_DEVICE, device);
            return this;
        }

        public Builder performer(final Reference performer) {
            b.add(FhirPropertyNames.PROPERTY_PERFORMER, performer);
            return this;
        }

        public Builder quantity(final Quantity quantity) {
            b.add(FhirPropertyNames.PROPERTY_QUANTITY, quantity);
            return this;
        }

        public Builder referenceSeq(final MolecularSequenceReferenceSeq referenceSeq) {
            b.add(FhirPropertyNames.PROPERTY_REFERENCE_SEQ, referenceSeq);
            return this;
        }

        public Builder variant(final java.util.List<MolecularSequenceVariant> variant) {
            b.add(FhirPropertyNames.PROPERTY_VARIANT, FhirObject.toArray(variant));
            return this;
        }

        public Builder observedSeq(final String observedSeq) {
            b.add(FhirPropertyNames.PROPERTY_OBSERVED_SEQ, observedSeq);
            return this;
        }

        public Builder quality(final java.util.List<MolecularSequenceQuality> quality) {
            b.add(FhirPropertyNames.PROPERTY_QUALITY, FhirObject.toArray(quality));
            return this;
        }

        public Builder readCoverage(final Integer readCoverage) {
            b.add(FhirPropertyNames.PROPERTY_READ_COVERAGE, readCoverage);
            return this;
        }

        public Builder repository(final java.util.List<MolecularSequenceRepository> repository) {
            b.add(FhirPropertyNames.PROPERTY_REPOSITORY, FhirObject.toArray(repository));
            return this;
        }

        public Builder pointer(final java.util.List<Reference> pointer) {
            b.add(FhirPropertyNames.PROPERTY_POINTER, FhirObject.toArray(pointer));
            return this;
        }

        public Builder structureVariant(final java.util.List<MolecularSequenceStructureVariant> structureVariant) {
            b.add(FhirPropertyNames.PROPERTY_STRUCTURE_VARIANT, FhirObject.toArray(structureVariant));
            return this;
        }

        public MolecularSequence build() {
            return new MolecularSequence(b.build());
        }
    }

    /**
     * Raw data describing a biological sequence.
     */
    public static class MolecularSequenceInner extends FhirObject {
        public static final String RESOURCE_TYPE = "MolecularSequenceInner";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public MolecularSequenceInner(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Structural variant inner start. If the coordinate system is either
         * 0-based or 1-based, then start position is inclusive.
         */
        public Integer start() {
            return data.getInt(FhirPropertyNames.PROPERTY_START);
        }

        /**
         * Structural variant inner end. If the coordinate system is 0-based then
         * end is exclusive and does not include the last position. If the
         * coordinate system is 1-base, then end is inclusive and includes the
         * last position.
         */
        public Integer end() {
            return data.getInt(FhirPropertyNames.PROPERTY_END);
        }

        public static final class Builder extends FhirObject.Builder<MolecularSequenceInner, MolecularSequenceInner.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder start(final Integer start) {
                b.add(FhirPropertyNames.PROPERTY_START, start);
                return this;
            }

            public Builder end(final Integer end) {
                b.add(FhirPropertyNames.PROPERTY_END, end);
                return this;
            }

            public MolecularSequenceInner build() {
                return new MolecularSequenceInner(b.build());
            }
        }
    }

    /**
     * Raw data describing a biological sequence.
     */
    public static class MolecularSequenceOuter extends FhirObject {
        public static final String RESOURCE_TYPE = "MolecularSequenceOuter";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public MolecularSequenceOuter(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Structural variant outer start. If the coordinate system is either
         * 0-based or 1-based, then start position is inclusive.
         */
        public Integer start() {
            return data.getInt(FhirPropertyNames.PROPERTY_START);
        }

        /**
         * Structural variant outer end. If the coordinate system is 0-based then
         * end is exclusive and does not include the last position. If the
         * coordinate system is 1-base, then end is inclusive and includes the
         * last position.
         */
        public Integer end() {
            return data.getInt(FhirPropertyNames.PROPERTY_END);
        }

        public static final class Builder extends FhirObject.Builder<MolecularSequenceOuter, MolecularSequenceOuter.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder start(final Integer start) {
                b.add(FhirPropertyNames.PROPERTY_START, start);
                return this;
            }

            public Builder end(final Integer end) {
                b.add(FhirPropertyNames.PROPERTY_END, end);
                return this;
            }

            public MolecularSequenceOuter build() {
                return new MolecularSequenceOuter(b.build());
            }
        }
    }

    /**
     * Raw data describing a biological sequence.
     */
    public static class MolecularSequenceQuality extends FhirObject {
        public static final String RESOURCE_TYPE = "MolecularSequenceQuality";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public MolecularSequenceQuality(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * INDEL / SNP / Undefined variant.
         */
        public String type() {
            return getString(FhirPropertyNames.PROPERTY_TYPE);
        }

        /**
         * Gold standard sequence used for comparing against.
         */
        public CodeableConcept standardSequence() {
            return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_STANDARD_SEQUENCE);
        }

        /**
         * Start position of the sequence. If the coordinate system is either
         * 0-based or 1-based, then start position is inclusive.
         */
        public Integer start() {
            return data.getInt(FhirPropertyNames.PROPERTY_START);
        }

        /**
         * End position of the sequence. If the coordinate system is 0-based then
         * end is exclusive and does not include the last position. If the
         * coordinate system is 1-base, then end is inclusive and includes the
         * last position.
         */
        public Integer end() {
            return data.getInt(FhirPropertyNames.PROPERTY_END);
        }

        /**
         * The score of an experimentally derived feature such as a p-value
         * ([SO:0001685](http://www.sequenceontology.org/browser/current_svn/term/SO:0001685)).
         */
        public Quantity score() {
            return getObject(Quantity.class, FhirPropertyNames.PROPERTY_SCORE);
        }

        /**
         * Which method is used to get sequence quality.
         */
        public CodeableConcept method() {
            return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_METHOD);
        }

        /**
         * True positives, from the perspective of the truth data, i.e. the
         * number of sites in the Truth Call Set for which there are paths
         * through the Query Call Set that are consistent with all of the alleles
         * at this site, and for which there is an accurate genotype call for the
         * event.
         */
        public Double truthTP() {
            return data.getJsonNumber(FhirPropertyNames.PROPERTY_TRUTH_T_P).doubleValue();
        }

        /**
         * True positives, from the perspective of the query data, i.e. the
         * number of sites in the Query Call Set for which there are paths
         * through the Truth Call Set that are consistent with all of the alleles
         * at this site, and for which there is an accurate genotype call for the
         * event.
         */
        public Double queryTP() {
            return data.getJsonNumber(FhirPropertyNames.PROPERTY_QUERY_T_P).doubleValue();
        }

        /**
         * False negatives, i.e. the number of sites in the Truth Call Set for
         * which there is no path through the Query Call Set that is consistent
         * with all of the alleles at this site, or sites for which there is an
         * inaccurate genotype call for the event. Sites with correct variant but
         * incorrect genotype are counted here.
         */
        public Double truthFN() {
            return data.getJsonNumber(FhirPropertyNames.PROPERTY_TRUTH_F_N).doubleValue();
        }

        /**
         * False positives, i.e. the number of sites in the Query Call Set for
         * which there is no path through the Truth Call Set that is consistent
         * with this site. Sites with correct variant but incorrect genotype are
         * counted here.
         */
        public Double queryFP() {
            return data.getJsonNumber(FhirPropertyNames.PROPERTY_QUERY_F_P).doubleValue();
        }

        /**
         * The number of false positives where the non-REF alleles in the Truth
         * and Query Call Sets match (i.e. cases where the truth is 1/1 and the
         * query is 0/1 or similar).
         */
        public Double gtFP() {
            return data.getJsonNumber(FhirPropertyNames.PROPERTY_GT_F_P).doubleValue();
        }

        /**
         * QUERY.TP / (QUERY.TP + QUERY.FP).
         */
        public Double precision() {
            return data.getJsonNumber(FhirPropertyNames.PROPERTY_PRECISION).doubleValue();
        }

        /**
         * TRUTH.TP / (TRUTH.TP + TRUTH.FN).
         */
        public Double recall() {
            return data.getJsonNumber(FhirPropertyNames.PROPERTY_RECALL).doubleValue();
        }

        /**
         * Harmonic mean of Recall and Precision, computed as: 2 * precision *
         * recall / (precision + recall).
         */
        public Double fScore() {
            return data.getJsonNumber(FhirPropertyNames.PROPERTY_F_SCORE).doubleValue();
        }

        /**
         * Receiver Operator Characteristic (ROC) Curve  to give
         * sensitivity/specificity tradeoff.
         */
        public MolecularSequenceRoc roc() {
            return getObject(MolecularSequenceRoc.class, FhirPropertyNames.PROPERTY_ROC);
        }

        public static final class Builder extends FhirObject.Builder<MolecularSequenceQuality, MolecularSequenceQuality.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder type(final String type) {
                b.add(FhirPropertyNames.PROPERTY_TYPE, type);
                return this;
            }

            public Builder standardSequence(final CodeableConcept standardSequence) {
                b.add(FhirPropertyNames.PROPERTY_STANDARD_SEQUENCE, standardSequence);
                return this;
            }

            public Builder start(final Integer start) {
                b.add(FhirPropertyNames.PROPERTY_START, start);
                return this;
            }

            public Builder end(final Integer end) {
                b.add(FhirPropertyNames.PROPERTY_END, end);
                return this;
            }

            public Builder score(final Quantity score) {
                b.add(FhirPropertyNames.PROPERTY_SCORE, score);
                return this;
            }

            public Builder method(final CodeableConcept method) {
                b.add(FhirPropertyNames.PROPERTY_METHOD, method);
                return this;
            }

            public Builder truthTP(final Double truthTP) {
                b.add(FhirPropertyNames.PROPERTY_TRUTH_T_P, truthTP);
                return this;
            }

            public Builder queryTP(final Double queryTP) {
                b.add(FhirPropertyNames.PROPERTY_QUERY_T_P, queryTP);
                return this;
            }

            public Builder truthFN(final Double truthFN) {
                b.add(FhirPropertyNames.PROPERTY_TRUTH_F_N, truthFN);
                return this;
            }

            public Builder queryFP(final Double queryFP) {
                b.add(FhirPropertyNames.PROPERTY_QUERY_F_P, queryFP);
                return this;
            }

            public Builder gtFP(final Double gtFP) {
                b.add(FhirPropertyNames.PROPERTY_GT_F_P, gtFP);
                return this;
            }

            public Builder precision(final Double precision) {
                b.add(FhirPropertyNames.PROPERTY_PRECISION, precision);
                return this;
            }

            public Builder recall(final Double recall) {
                b.add(FhirPropertyNames.PROPERTY_RECALL, recall);
                return this;
            }

            public Builder fScore(final Double fScore) {
                b.add(FhirPropertyNames.PROPERTY_F_SCORE, fScore);
                return this;
            }

            public Builder roc(final MolecularSequenceRoc roc) {
                b.add(FhirPropertyNames.PROPERTY_ROC, roc);
                return this;
            }

            public MolecularSequenceQuality build() {
                return new MolecularSequenceQuality(b.build());
            }
        }
    }

    /**
     * Raw data describing a biological sequence.
     */
    public static class MolecularSequenceReferenceSeq extends FhirObject {
        public static final String RESOURCE_TYPE = "MolecularSequenceReferenceSeq";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public MolecularSequenceReferenceSeq(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Structural unit composed of a nucleic acid molecule which controls its
         * own replication through the interaction of specific proteins at one or
         * more origins of replication
         * ([SO:0000340](http://www.sequenceontology.org/browser/current_svn/term/SO:0000340)).
         */
        public CodeableConcept chromosome() {
            return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_CHROMOSOME);
        }

        /**
         * The Genome Build used for reference, following GRCh build versions
         * e.g. 'GRCh 37'.  Version number must be included if a versioned
         * release of a primary build was used.
         */
        public String genomeBuild() {
            return getString(FhirPropertyNames.PROPERTY_GENOME_BUILD);
        }

        /**
         * A relative reference to a DNA strand based on gene orientation. The
         * strand that contains the open reading frame of the gene is the &quot;sense&quot;
         * strand, and the opposite complementary strand is the &quot;antisense&quot;
         * strand.
         */
        public String orientation() {
            return getString(FhirPropertyNames.PROPERTY_ORIENTATION);
        }

        /**
         * Reference identifier of reference sequence submitted to NCBI. It must
         * match the type in the MolecularSequence.type field. For example, the
         * prefix, &ldquo;NG_&rdquo; identifies reference sequence for genes, &ldquo;NM_&rdquo; for
         * messenger RNA transcripts, and &ldquo;NP_&rdquo; for amino acid sequences.
         */
        public CodeableConcept referenceSeqId() {
            return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_REFERENCE_SEQ_ID);
        }

        /**
         * A pointer to another MolecularSequence entity as reference sequence.
         */
        public Reference referenceSeqPointer() {
            return getObject(Reference.class, FhirPropertyNames.PROPERTY_REFERENCE_SEQ_POINTER);
        }

        /**
         * A string like &quot;ACGT&quot;.
         */
        public String referenceSeqString() {
            return getString(FhirPropertyNames.PROPERTY_REFERENCE_SEQ_STRING);
        }

        /**
         * An absolute reference to a strand. The Watson strand is the strand
         * whose 5'-end is on the short arm of the chromosome, and the Crick
         * strand as the one whose 5'-end is on the long arm.
         */
        public String strand() {
            return getString(FhirPropertyNames.PROPERTY_STRAND);
        }

        /**
         * Start position of the window on the reference sequence. If the
         * coordinate system is either 0-based or 1-based, then start position is
         * inclusive.
         */
        public Integer windowStart() {
            return data.getInt(FhirPropertyNames.PROPERTY_WINDOW_START);
        }

        /**
         * End position of the window on the reference sequence. If the
         * coordinate system is 0-based then end is exclusive and does not
         * include the last position. If the coordinate system is 1-base, then
         * end is inclusive and includes the last position.
         */
        public Integer windowEnd() {
            return data.getInt(FhirPropertyNames.PROPERTY_WINDOW_END);
        }

        public static final class Builder extends FhirObject.Builder<MolecularSequenceReferenceSeq, MolecularSequenceReferenceSeq.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder chromosome(final CodeableConcept chromosome) {
                b.add(FhirPropertyNames.PROPERTY_CHROMOSOME, chromosome);
                return this;
            }

            public Builder genomeBuild(final String genomeBuild) {
                b.add(FhirPropertyNames.PROPERTY_GENOME_BUILD, genomeBuild);
                return this;
            }

            public Builder orientation(final String orientation) {
                b.add(FhirPropertyNames.PROPERTY_ORIENTATION, orientation);
                return this;
            }

            public Builder referenceSeqId(final CodeableConcept referenceSeqId) {
                b.add(FhirPropertyNames.PROPERTY_REFERENCE_SEQ_ID, referenceSeqId);
                return this;
            }

            public Builder referenceSeqPointer(final Reference referenceSeqPointer) {
                b.add(FhirPropertyNames.PROPERTY_REFERENCE_SEQ_POINTER, referenceSeqPointer);
                return this;
            }

            public Builder referenceSeqString(final String referenceSeqString) {
                b.add(FhirPropertyNames.PROPERTY_REFERENCE_SEQ_STRING, referenceSeqString);
                return this;
            }

            public Builder strand(final String strand) {
                b.add(FhirPropertyNames.PROPERTY_STRAND, strand);
                return this;
            }

            public Builder windowStart(final Integer windowStart) {
                b.add(FhirPropertyNames.PROPERTY_WINDOW_START, windowStart);
                return this;
            }

            public Builder windowEnd(final Integer windowEnd) {
                b.add(FhirPropertyNames.PROPERTY_WINDOW_END, windowEnd);
                return this;
            }

            public MolecularSequenceReferenceSeq build() {
                return new MolecularSequenceReferenceSeq(b.build());
            }
        }
    }

    /**
     * Raw data describing a biological sequence.
     */
    public static class MolecularSequenceRepository extends FhirObject {
        public static final String RESOURCE_TYPE = "MolecularSequenceRepository";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public MolecularSequenceRepository(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Click and see / RESTful API / Need login to see / RESTful API with
         * authentication / Other ways to see resource.
         */
        public String type() {
            return getString(FhirPropertyNames.PROPERTY_TYPE);
        }

        /**
         * URI of an external repository which contains further details about the
         * genetics data.
         */
        public java.net.URI url() {
            return getUri(FhirPropertyNames.PROPERTY_URL);
        }

        /**
         * URI of an external repository which contains further details about the
         * genetics data.
         */
        public String name() {
            return getString(FhirPropertyNames.PROPERTY_NAME);
        }

        /**
         * Id of the variant in this external repository. The server will
         * understand how to use this id to call for more info about datasets in
         * external repository.
         */
        public String datasetId() {
            return getString(FhirPropertyNames.PROPERTY_DATASET_ID);
        }

        /**
         * Id of the variantset in this external repository. The server will
         * understand how to use this id to call for more info about variantsets
         * in external repository.
         */
        public String variantsetId() {
            return getString(FhirPropertyNames.PROPERTY_VARIANTSET_ID);
        }

        /**
         * Id of the read in this external repository.
         */
        public String readsetId() {
            return getString(FhirPropertyNames.PROPERTY_READSET_ID);
        }

        public static final class Builder extends FhirObject.Builder<MolecularSequenceRepository, MolecularSequenceRepository.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder type(final String type) {
                b.add(FhirPropertyNames.PROPERTY_TYPE, type);
                return this;
            }

            public Builder url(final java.net.URI url) {
                b.add(FhirPropertyNames.PROPERTY_URL, url.toString());
                return this;
            }

            public Builder name(final String name) {
                b.add(FhirPropertyNames.PROPERTY_NAME, name);
                return this;
            }

            public Builder datasetId(final String datasetId) {
                b.add(FhirPropertyNames.PROPERTY_DATASET_ID, datasetId);
                return this;
            }

            public Builder variantsetId(final String variantsetId) {
                b.add(FhirPropertyNames.PROPERTY_VARIANTSET_ID, variantsetId);
                return this;
            }

            public Builder readsetId(final String readsetId) {
                b.add(FhirPropertyNames.PROPERTY_READSET_ID, readsetId);
                return this;
            }

            public MolecularSequenceRepository build() {
                return new MolecularSequenceRepository(b.build());
            }
        }
    }

    /**
     * Raw data describing a biological sequence.
     */
    public static class MolecularSequenceRoc extends FhirObject {
        public static final String RESOURCE_TYPE = "MolecularSequenceRoc";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public MolecularSequenceRoc(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Invidual data point representing the GQ (genotype quality) score
         * threshold.
         */
        public java.util.List<Integer> score() {
            return getList(Integer.class, FhirPropertyNames.PROPERTY_SCORE);
        }

        /**
         * The number of true positives if the GQ score threshold was set to
         * &quot;score&quot; field value.
         */
        public java.util.List<Integer> numTP() {
            return getList(Integer.class, FhirPropertyNames.PROPERTY_NUM_T_P);
        }

        /**
         * The number of false positives if the GQ score threshold was set to
         * &quot;score&quot; field value.
         */
        public java.util.List<Integer> numFP() {
            return getList(Integer.class, FhirPropertyNames.PROPERTY_NUM_F_P);
        }

        /**
         * The number of false negatives if the GQ score threshold was set to
         * &quot;score&quot; field value.
         */
        public java.util.List<Integer> numFN() {
            return getList(Integer.class, FhirPropertyNames.PROPERTY_NUM_F_N);
        }

        /**
         * Calculated precision if the GQ score threshold was set to &quot;score&quot;
         * field value.
         */
        public java.util.List<Double> precision() {
            return getList(Double.class, FhirPropertyNames.PROPERTY_PRECISION);
        }

        /**
         * Calculated sensitivity if the GQ score threshold was set to &quot;score&quot;
         * field value.
         */
        public java.util.List<Double> sensitivity() {
            return getList(Double.class, FhirPropertyNames.PROPERTY_SENSITIVITY);
        }

        /**
         * Calculated fScore if the GQ score threshold was set to &quot;score&quot; field
         * value.
         */
        public java.util.List<Double> fMeasure() {
            return getList(Double.class, FhirPropertyNames.PROPERTY_F_MEASURE);
        }

        public static final class Builder extends FhirObject.Builder<MolecularSequenceRoc, MolecularSequenceRoc.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder score(final java.util.List<Integer> score) {
                b.add(FhirPropertyNames.PROPERTY_SCORE, FhirObject.toIntegerArray(score));
                return this;
            }

            public Builder numTP(final java.util.List<Integer> numTP) {
                b.add(FhirPropertyNames.PROPERTY_NUM_T_P, FhirObject.toIntegerArray(numTP));
                return this;
            }

            public Builder numFP(final java.util.List<Integer> numFP) {
                b.add(FhirPropertyNames.PROPERTY_NUM_F_P, FhirObject.toIntegerArray(numFP));
                return this;
            }

            public Builder numFN(final java.util.List<Integer> numFN) {
                b.add(FhirPropertyNames.PROPERTY_NUM_F_N, FhirObject.toIntegerArray(numFN));
                return this;
            }

            public Builder precision(final java.util.List<Double> precision) {
                b.add(FhirPropertyNames.PROPERTY_PRECISION, FhirObject.toDoubleArray(precision));
                return this;
            }

            public Builder sensitivity(final java.util.List<Double> sensitivity) {
                b.add(FhirPropertyNames.PROPERTY_SENSITIVITY, FhirObject.toDoubleArray(sensitivity));
                return this;
            }

            public Builder fMeasure(final java.util.List<Double> fMeasure) {
                b.add(FhirPropertyNames.PROPERTY_F_MEASURE, FhirObject.toDoubleArray(fMeasure));
                return this;
            }

            public MolecularSequenceRoc build() {
                return new MolecularSequenceRoc(b.build());
            }
        }
    }

    /**
     * Raw data describing a biological sequence.
     */
    public static class MolecularSequenceStructureVariant extends FhirObject {
        public static final String RESOURCE_TYPE = "MolecularSequenceStructureVariant";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public MolecularSequenceStructureVariant(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Information about chromosome structure variation DNA change type.
         */
        public CodeableConcept variantType() {
            return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_VARIANT_TYPE);
        }

        /**
         * Used to indicate if the outer and inner start-end values have the same
         * meaning.
         */
        public Boolean exact() {
            return data.getBoolean(FhirPropertyNames.PROPERTY_EXACT);
        }

        /**
         * Length of the variant chromosome.
         */
        public Integer length() {
            return data.getInt(FhirPropertyNames.PROPERTY_LENGTH);
        }

        /**
         * Structural variant outer.
         */
        public MolecularSequenceOuter outer() {
            return getObject(MolecularSequenceOuter.class, FhirPropertyNames.PROPERTY_OUTER);
        }

        /**
         * Structural variant inner.
         */
        public MolecularSequenceInner inner() {
            return getObject(MolecularSequenceInner.class, FhirPropertyNames.PROPERTY_INNER);
        }

        public static final class Builder extends FhirObject.Builder<MolecularSequenceStructureVariant, MolecularSequenceStructureVariant.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder variantType(final CodeableConcept variantType) {
                b.add(FhirPropertyNames.PROPERTY_VARIANT_TYPE, variantType);
                return this;
            }

            public Builder exact(final Boolean exact) {
                b.add(FhirPropertyNames.PROPERTY_EXACT, exact);
                return this;
            }

            public Builder length(final Integer length) {
                b.add(FhirPropertyNames.PROPERTY_LENGTH, length);
                return this;
            }

            public Builder outer(final MolecularSequenceOuter outer) {
                b.add(FhirPropertyNames.PROPERTY_OUTER, outer);
                return this;
            }

            public Builder inner(final MolecularSequenceInner inner) {
                b.add(FhirPropertyNames.PROPERTY_INNER, inner);
                return this;
            }

            public MolecularSequenceStructureVariant build() {
                return new MolecularSequenceStructureVariant(b.build());
            }
        }
    }

    /**
     * Raw data describing a biological sequence.
     */
    public static class MolecularSequenceVariant extends FhirObject {
        public static final String RESOURCE_TYPE = "MolecularSequenceVariant";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public MolecularSequenceVariant(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Start position of the variant on the  reference sequence. If the
         * coordinate system is either 0-based or 1-based, then start position is
         * inclusive.
         */
        public Integer start() {
            return data.getInt(FhirPropertyNames.PROPERTY_START);
        }

        /**
         * End position of the variant on the reference sequence. If the
         * coordinate system is 0-based then end is exclusive and does not
         * include the last position. If the coordinate system is 1-base, then
         * end is inclusive and includes the last position.
         */
        public Integer end() {
            return data.getInt(FhirPropertyNames.PROPERTY_END);
        }

        /**
         * An allele is one of a set of coexisting sequence variants of a gene
         * ([SO:0001023](http://www.sequenceontology.org/browser/current_svn/term/SO:0001023)).
         * Nucleotide(s)/amino acids from start position of sequence to stop
         * position of sequence on the positive (+) strand of the observed
         * sequence. When the sequence  type is DNA, it should be the sequence on
         * the positive (+) strand. This will lay in the range between
         * variant.start and variant.end.
         */
        public String observedAllele() {
            return getString(FhirPropertyNames.PROPERTY_OBSERVED_ALLELE);
        }

        /**
         * An allele is one of a set of coexisting sequence variants of a gene
         * ([SO:0001023](http://www.sequenceontology.org/browser/current_svn/term/SO:0001023)).
         * Nucleotide(s)/amino acids from start position of sequence to stop
         * position of sequence on the positive (+) strand of the reference
         * sequence. When the sequence  type is DNA, it should be the sequence on
         * the positive (+) strand. This will lay in the range between
         * variant.start and variant.end.
         */
        public String referenceAllele() {
            return getString(FhirPropertyNames.PROPERTY_REFERENCE_ALLELE);
        }

        /**
         * Extended CIGAR string for aligning the sequence with reference bases.
         * See detailed documentation
         * [here](http://support.illumina.com/help/SequencingAnalysisWorkflow/Content/Vault/Informatics/Sequencing_Analysis/CASAVA/swSEQ_mCA_ExtendedCIGARFormat.htm).
         */
        public String cigar() {
            return getString(FhirPropertyNames.PROPERTY_CIGAR);
        }

        /**
         * A pointer to an Observation containing variant information.
         */
        public Reference variantPointer() {
            return getObject(Reference.class, FhirPropertyNames.PROPERTY_VARIANT_POINTER);
        }

        public static final class Builder extends FhirObject.Builder<MolecularSequenceVariant, MolecularSequenceVariant.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder start(final Integer start) {
                b.add(FhirPropertyNames.PROPERTY_START, start);
                return this;
            }

            public Builder end(final Integer end) {
                b.add(FhirPropertyNames.PROPERTY_END, end);
                return this;
            }

            public Builder observedAllele(final String observedAllele) {
                b.add(FhirPropertyNames.PROPERTY_OBSERVED_ALLELE, observedAllele);
                return this;
            }

            public Builder referenceAllele(final String referenceAllele) {
                b.add(FhirPropertyNames.PROPERTY_REFERENCE_ALLELE, referenceAllele);
                return this;
            }

            public Builder cigar(final String cigar) {
                b.add(FhirPropertyNames.PROPERTY_CIGAR, cigar);
                return this;
            }

            public Builder variantPointer(final Reference variantPointer) {
                b.add(FhirPropertyNames.PROPERTY_VARIANT_POINTER, variantPointer);
                return this;
            }

            public MolecularSequenceVariant build() {
                return new MolecularSequenceVariant(b.build());
            }
        }
    }
}
