/*
 * Generated by com.medplum.generator.Generator
 * Do not edit manually.
 */

package com.medplum.fhir.r4.types;

import jakarta.json.JsonObject;

import com.medplum.fhir.r4.FhirPropertyNames;

/**
 * An interaction between a patient and healthcare provider(s) for the
 * purpose of providing healthcare service(s) or assessing the health
 * status of a patient.
 */
public class Encounter extends DomainResource {
    public static final String RESOURCE_TYPE = "Encounter";

    public static Builder create() {
        return new Builder();
    }

    public static Builder create(final JsonObject data) {
        return new Builder(data);
    }

    public Encounter(final JsonObject data) {
        super(data);
    }

    /**
     * Identifier(s) by which this encounter is known.
     */
    public java.util.List<Identifier> identifier() {
        return getList(Identifier.class, FhirPropertyNames.PROPERTY_IDENTIFIER);
    }

    /**
     * planned | arrived | triaged | in-progress | onleave | finished |
     * cancelled +.
     */
    public String status() {
        return getString(FhirPropertyNames.PROPERTY_STATUS);
    }

    /**
     * The status history permits the encounter resource to contain the
     * status history without needing to read through the historical versions
     * of the resource, or even have the server store them.
     */
    public java.util.List<EncounterStatusHistory> statusHistory() {
        return getList(EncounterStatusHistory.class, FhirPropertyNames.PROPERTY_STATUS_HISTORY);
    }

    /**
     * Concepts representing classification of patient encounter such as
     * ambulatory (outpatient), inpatient, emergency, home health or others
     * due to local variations.
     */
    public Coding classValue() {
        return getObject(Coding.class, FhirPropertyNames.PROPERTY_CLASS);
    }

    /**
     * The class history permits the tracking of the encounters transitions
     * without needing to go  through the resource history.  This would be
     * used for a case where an admission starts of as an emergency
     * encounter, then transitions into an inpatient scenario. Doing this and
     * not restarting a new encounter ensures that any lab/diagnostic results
     * can more easily follow the patient and not require re-processing and
     * not get lost or cancelled during a kind of discharge from emergency to
     * inpatient.
     */
    public java.util.List<EncounterClassHistory> classHistory() {
        return getList(EncounterClassHistory.class, FhirPropertyNames.PROPERTY_CLASS_HISTORY);
    }

    /**
     * Specific type of encounter (e.g. e-mail consultation, surgical
     * day-care, skilled nursing, rehabilitation).
     */
    public java.util.List<CodeableConcept> type() {
        return getList(CodeableConcept.class, FhirPropertyNames.PROPERTY_TYPE);
    }

    /**
     * Broad categorization of the service that is to be provided (e.g.
     * cardiology).
     */
    public CodeableConcept serviceType() {
        return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_SERVICE_TYPE);
    }

    /**
     * Indicates the urgency of the encounter.
     */
    public CodeableConcept priority() {
        return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_PRIORITY);
    }

    /**
     * The patient or group present at the encounter.
     */
    public Reference subject() {
        return getObject(Reference.class, FhirPropertyNames.PROPERTY_SUBJECT);
    }

    /**
     * Where a specific encounter should be classified as a part of a
     * specific episode(s) of care this field should be used. This
     * association can facilitate grouping of related encounters together for
     * a specific purpose, such as government reporting, issue tracking,
     * association via a common problem.  The association is recorded on the
     * encounter as these are typically created after the episode of care and
     * grouped on entry rather than editing the episode of care to append
     * another encounter to it (the episode of care could span years).
     */
    public java.util.List<Reference> episodeOfCare() {
        return getList(Reference.class, FhirPropertyNames.PROPERTY_EPISODE_OF_CARE);
    }

    /**
     * The request this encounter satisfies (e.g. incoming referral or
     * procedure request).
     */
    public java.util.List<Reference> basedOn() {
        return getList(Reference.class, FhirPropertyNames.PROPERTY_BASED_ON);
    }

    /**
     * The list of people responsible for providing the service.
     */
    public java.util.List<EncounterParticipant> participant() {
        return getList(EncounterParticipant.class, FhirPropertyNames.PROPERTY_PARTICIPANT);
    }

    /**
     * The appointment that scheduled this encounter.
     */
    public java.util.List<Reference> appointment() {
        return getList(Reference.class, FhirPropertyNames.PROPERTY_APPOINTMENT);
    }

    /**
     * The start and end time of the encounter.
     */
    public Period period() {
        return getObject(Period.class, FhirPropertyNames.PROPERTY_PERIOD);
    }

    /**
     * Quantity of time the encounter lasted. This excludes the time during
     * leaves of absence.
     */
    public Duration length() {
        return getObject(Duration.class, FhirPropertyNames.PROPERTY_LENGTH);
    }

    /**
     * Reason the encounter takes place, expressed as a code. For admissions,
     * this can be used for a coded admission diagnosis.
     */
    public java.util.List<CodeableConcept> reasonCode() {
        return getList(CodeableConcept.class, FhirPropertyNames.PROPERTY_REASON_CODE);
    }

    /**
     * Reason the encounter takes place, expressed as a code. For admissions,
     * this can be used for a coded admission diagnosis.
     */
    public java.util.List<Reference> reasonReference() {
        return getList(Reference.class, FhirPropertyNames.PROPERTY_REASON_REFERENCE);
    }

    /**
     * The list of diagnosis relevant to this encounter.
     */
    public java.util.List<EncounterDiagnosis> diagnosis() {
        return getList(EncounterDiagnosis.class, FhirPropertyNames.PROPERTY_DIAGNOSIS);
    }

    /**
     * The set of accounts that may be used for billing for this Encounter.
     */
    public java.util.List<Reference> account() {
        return getList(Reference.class, FhirPropertyNames.PROPERTY_ACCOUNT);
    }

    /**
     * Details about the admission to a healthcare service.
     */
    public EncounterHospitalization hospitalization() {
        return getObject(EncounterHospitalization.class, FhirPropertyNames.PROPERTY_HOSPITALIZATION);
    }

    /**
     * List of locations where  the patient has been during this encounter.
     */
    public java.util.List<EncounterLocation> location() {
        return getList(EncounterLocation.class, FhirPropertyNames.PROPERTY_LOCATION);
    }

    /**
     * The organization that is primarily responsible for this Encounter's
     * services. This MAY be the same as the organization on the Patient
     * record, however it could be different, such as if the actor performing
     * the services was from an external organization (which may be billed
     * seperately) for an external consultation.  Refer to the example bundle
     * showing an abbreviated set of Encounters for a colonoscopy.
     */
    public Reference serviceProvider() {
        return getObject(Reference.class, FhirPropertyNames.PROPERTY_SERVICE_PROVIDER);
    }

    /**
     * Another Encounter of which this encounter is a part of
     * (administratively or in time).
     */
    public Reference partOf() {
        return getObject(Reference.class, FhirPropertyNames.PROPERTY_PART_OF);
    }

    public static final class Builder extends DomainResource.Builder<Encounter, Encounter.Builder> {

        private Builder() {
            super(RESOURCE_TYPE);
        }

        private Builder(final JsonObject data) {
            super(RESOURCE_TYPE, data);
        }

        public Builder identifier(final java.util.List<Identifier> identifier) {
            b.add(FhirPropertyNames.PROPERTY_IDENTIFIER, FhirObject.toArray(identifier));
            return this;
        }

        public Builder status(final String status) {
            b.add(FhirPropertyNames.PROPERTY_STATUS, status);
            return this;
        }

        public Builder statusHistory(final java.util.List<EncounterStatusHistory> statusHistory) {
            b.add(FhirPropertyNames.PROPERTY_STATUS_HISTORY, FhirObject.toArray(statusHistory));
            return this;
        }

        public Builder classValue(final Coding classValue) {
            b.add(FhirPropertyNames.PROPERTY_CLASS, classValue);
            return this;
        }

        public Builder classHistory(final java.util.List<EncounterClassHistory> classHistory) {
            b.add(FhirPropertyNames.PROPERTY_CLASS_HISTORY, FhirObject.toArray(classHistory));
            return this;
        }

        public Builder type(final java.util.List<CodeableConcept> type) {
            b.add(FhirPropertyNames.PROPERTY_TYPE, FhirObject.toArray(type));
            return this;
        }

        public Builder serviceType(final CodeableConcept serviceType) {
            b.add(FhirPropertyNames.PROPERTY_SERVICE_TYPE, serviceType);
            return this;
        }

        public Builder priority(final CodeableConcept priority) {
            b.add(FhirPropertyNames.PROPERTY_PRIORITY, priority);
            return this;
        }

        public Builder subject(final Reference subject) {
            b.add(FhirPropertyNames.PROPERTY_SUBJECT, subject);
            return this;
        }

        public Builder episodeOfCare(final java.util.List<Reference> episodeOfCare) {
            b.add(FhirPropertyNames.PROPERTY_EPISODE_OF_CARE, FhirObject.toArray(episodeOfCare));
            return this;
        }

        public Builder basedOn(final java.util.List<Reference> basedOn) {
            b.add(FhirPropertyNames.PROPERTY_BASED_ON, FhirObject.toArray(basedOn));
            return this;
        }

        public Builder participant(final java.util.List<EncounterParticipant> participant) {
            b.add(FhirPropertyNames.PROPERTY_PARTICIPANT, FhirObject.toArray(participant));
            return this;
        }

        public Builder appointment(final java.util.List<Reference> appointment) {
            b.add(FhirPropertyNames.PROPERTY_APPOINTMENT, FhirObject.toArray(appointment));
            return this;
        }

        public Builder period(final Period period) {
            b.add(FhirPropertyNames.PROPERTY_PERIOD, period);
            return this;
        }

        public Builder length(final Duration length) {
            b.add(FhirPropertyNames.PROPERTY_LENGTH, length);
            return this;
        }

        public Builder reasonCode(final java.util.List<CodeableConcept> reasonCode) {
            b.add(FhirPropertyNames.PROPERTY_REASON_CODE, FhirObject.toArray(reasonCode));
            return this;
        }

        public Builder reasonReference(final java.util.List<Reference> reasonReference) {
            b.add(FhirPropertyNames.PROPERTY_REASON_REFERENCE, FhirObject.toArray(reasonReference));
            return this;
        }

        public Builder diagnosis(final java.util.List<EncounterDiagnosis> diagnosis) {
            b.add(FhirPropertyNames.PROPERTY_DIAGNOSIS, FhirObject.toArray(diagnosis));
            return this;
        }

        public Builder account(final java.util.List<Reference> account) {
            b.add(FhirPropertyNames.PROPERTY_ACCOUNT, FhirObject.toArray(account));
            return this;
        }

        public Builder hospitalization(final EncounterHospitalization hospitalization) {
            b.add(FhirPropertyNames.PROPERTY_HOSPITALIZATION, hospitalization);
            return this;
        }

        public Builder location(final java.util.List<EncounterLocation> location) {
            b.add(FhirPropertyNames.PROPERTY_LOCATION, FhirObject.toArray(location));
            return this;
        }

        public Builder serviceProvider(final Reference serviceProvider) {
            b.add(FhirPropertyNames.PROPERTY_SERVICE_PROVIDER, serviceProvider);
            return this;
        }

        public Builder partOf(final Reference partOf) {
            b.add(FhirPropertyNames.PROPERTY_PART_OF, partOf);
            return this;
        }

        public Encounter build() {
            return new Encounter(b.build());
        }
    }

    /**
     * An interaction between a patient and healthcare provider(s) for the
     * purpose of providing healthcare service(s) or assessing the health
     * status of a patient.
     */
    public static class EncounterClassHistory extends FhirObject {
        public static final String RESOURCE_TYPE = "EncounterClassHistory";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public EncounterClassHistory(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * inpatient | outpatient | ambulatory | emergency +.
         */
        public Coding classValue() {
            return getObject(Coding.class, FhirPropertyNames.PROPERTY_CLASS);
        }

        /**
         * The time that the episode was in the specified class.
         */
        public Period period() {
            return getObject(Period.class, FhirPropertyNames.PROPERTY_PERIOD);
        }

        public static final class Builder extends FhirObject.Builder<EncounterClassHistory, EncounterClassHistory.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder classValue(final Coding classValue) {
                b.add(FhirPropertyNames.PROPERTY_CLASS, classValue);
                return this;
            }

            public Builder period(final Period period) {
                b.add(FhirPropertyNames.PROPERTY_PERIOD, period);
                return this;
            }

            public EncounterClassHistory build() {
                return new EncounterClassHistory(b.build());
            }
        }
    }

    /**
     * An interaction between a patient and healthcare provider(s) for the
     * purpose of providing healthcare service(s) or assessing the health
     * status of a patient.
     */
    public static class EncounterDiagnosis extends FhirObject {
        public static final String RESOURCE_TYPE = "EncounterDiagnosis";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public EncounterDiagnosis(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Reason the encounter takes place, as specified using information from
         * another resource. For admissions, this is the admission diagnosis. The
         * indication will typically be a Condition (with other resources
         * referenced in the evidence.detail), or a Procedure.
         */
        public Reference condition() {
            return getObject(Reference.class, FhirPropertyNames.PROPERTY_CONDITION);
        }

        /**
         * Role that this diagnosis has within the encounter (e.g. admission,
         * billing, discharge &hellip;).
         */
        public CodeableConcept use() {
            return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_USE);
        }

        /**
         * Ranking of the diagnosis (for each role type).
         */
        public Integer rank() {
            return data.getInt(FhirPropertyNames.PROPERTY_RANK);
        }

        public static final class Builder extends FhirObject.Builder<EncounterDiagnosis, EncounterDiagnosis.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder condition(final Reference condition) {
                b.add(FhirPropertyNames.PROPERTY_CONDITION, condition);
                return this;
            }

            public Builder use(final CodeableConcept use) {
                b.add(FhirPropertyNames.PROPERTY_USE, use);
                return this;
            }

            public Builder rank(final Integer rank) {
                b.add(FhirPropertyNames.PROPERTY_RANK, rank);
                return this;
            }

            public EncounterDiagnosis build() {
                return new EncounterDiagnosis(b.build());
            }
        }
    }

    /**
     * An interaction between a patient and healthcare provider(s) for the
     * purpose of providing healthcare service(s) or assessing the health
     * status of a patient.
     */
    public static class EncounterHospitalization extends FhirObject {
        public static final String RESOURCE_TYPE = "EncounterHospitalization";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public EncounterHospitalization(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Pre-admission identifier.
         */
        public Identifier preAdmissionIdentifier() {
            return getObject(Identifier.class, FhirPropertyNames.PROPERTY_PRE_ADMISSION_IDENTIFIER);
        }

        /**
         * The location/organization from which the patient came before
         * admission.
         */
        public Reference origin() {
            return getObject(Reference.class, FhirPropertyNames.PROPERTY_ORIGIN);
        }

        /**
         * From where patient was admitted (physician referral, transfer).
         */
        public CodeableConcept admitSource() {
            return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_ADMIT_SOURCE);
        }

        /**
         * Whether this hospitalization is a readmission and why if known.
         */
        public CodeableConcept reAdmission() {
            return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_RE_ADMISSION);
        }

        /**
         * Diet preferences reported by the patient.
         */
        public java.util.List<CodeableConcept> dietPreference() {
            return getList(CodeableConcept.class, FhirPropertyNames.PROPERTY_DIET_PREFERENCE);
        }

        /**
         * Special courtesies (VIP, board member).
         */
        public java.util.List<CodeableConcept> specialCourtesy() {
            return getList(CodeableConcept.class, FhirPropertyNames.PROPERTY_SPECIAL_COURTESY);
        }

        /**
         * Any special requests that have been made for this hospitalization
         * encounter, such as the provision of specific equipment or other
         * things.
         */
        public java.util.List<CodeableConcept> specialArrangement() {
            return getList(CodeableConcept.class, FhirPropertyNames.PROPERTY_SPECIAL_ARRANGEMENT);
        }

        /**
         * Location/organization to which the patient is discharged.
         */
        public Reference destination() {
            return getObject(Reference.class, FhirPropertyNames.PROPERTY_DESTINATION);
        }

        /**
         * Category or kind of location after discharge.
         */
        public CodeableConcept dischargeDisposition() {
            return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_DISCHARGE_DISPOSITION);
        }

        public static final class Builder extends FhirObject.Builder<EncounterHospitalization, EncounterHospitalization.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder preAdmissionIdentifier(final Identifier preAdmissionIdentifier) {
                b.add(FhirPropertyNames.PROPERTY_PRE_ADMISSION_IDENTIFIER, preAdmissionIdentifier);
                return this;
            }

            public Builder origin(final Reference origin) {
                b.add(FhirPropertyNames.PROPERTY_ORIGIN, origin);
                return this;
            }

            public Builder admitSource(final CodeableConcept admitSource) {
                b.add(FhirPropertyNames.PROPERTY_ADMIT_SOURCE, admitSource);
                return this;
            }

            public Builder reAdmission(final CodeableConcept reAdmission) {
                b.add(FhirPropertyNames.PROPERTY_RE_ADMISSION, reAdmission);
                return this;
            }

            public Builder dietPreference(final java.util.List<CodeableConcept> dietPreference) {
                b.add(FhirPropertyNames.PROPERTY_DIET_PREFERENCE, FhirObject.toArray(dietPreference));
                return this;
            }

            public Builder specialCourtesy(final java.util.List<CodeableConcept> specialCourtesy) {
                b.add(FhirPropertyNames.PROPERTY_SPECIAL_COURTESY, FhirObject.toArray(specialCourtesy));
                return this;
            }

            public Builder specialArrangement(final java.util.List<CodeableConcept> specialArrangement) {
                b.add(FhirPropertyNames.PROPERTY_SPECIAL_ARRANGEMENT, FhirObject.toArray(specialArrangement));
                return this;
            }

            public Builder destination(final Reference destination) {
                b.add(FhirPropertyNames.PROPERTY_DESTINATION, destination);
                return this;
            }

            public Builder dischargeDisposition(final CodeableConcept dischargeDisposition) {
                b.add(FhirPropertyNames.PROPERTY_DISCHARGE_DISPOSITION, dischargeDisposition);
                return this;
            }

            public EncounterHospitalization build() {
                return new EncounterHospitalization(b.build());
            }
        }
    }

    /**
     * An interaction between a patient and healthcare provider(s) for the
     * purpose of providing healthcare service(s) or assessing the health
     * status of a patient.
     */
    public static class EncounterLocation extends FhirObject {
        public static final String RESOURCE_TYPE = "EncounterLocation";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public EncounterLocation(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * The location where the encounter takes place.
         */
        public Reference location() {
            return getObject(Reference.class, FhirPropertyNames.PROPERTY_LOCATION);
        }

        /**
         * The status of the participants' presence at the specified location
         * during the period specified. If the participant is no longer at the
         * location, then the period will have an end date/time.
         */
        public String status() {
            return getString(FhirPropertyNames.PROPERTY_STATUS);
        }

        /**
         * This will be used to specify the required levels (bed/ward/room/etc.)
         * desired to be recorded to simplify either messaging or query.
         */
        public CodeableConcept physicalType() {
            return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_PHYSICAL_TYPE);
        }

        /**
         * Time period during which the patient was present at the location.
         */
        public Period period() {
            return getObject(Period.class, FhirPropertyNames.PROPERTY_PERIOD);
        }

        public static final class Builder extends FhirObject.Builder<EncounterLocation, EncounterLocation.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder location(final Reference location) {
                b.add(FhirPropertyNames.PROPERTY_LOCATION, location);
                return this;
            }

            public Builder status(final String status) {
                b.add(FhirPropertyNames.PROPERTY_STATUS, status);
                return this;
            }

            public Builder physicalType(final CodeableConcept physicalType) {
                b.add(FhirPropertyNames.PROPERTY_PHYSICAL_TYPE, physicalType);
                return this;
            }

            public Builder period(final Period period) {
                b.add(FhirPropertyNames.PROPERTY_PERIOD, period);
                return this;
            }

            public EncounterLocation build() {
                return new EncounterLocation(b.build());
            }
        }
    }

    /**
     * An interaction between a patient and healthcare provider(s) for the
     * purpose of providing healthcare service(s) or assessing the health
     * status of a patient.
     */
    public static class EncounterParticipant extends FhirObject {
        public static final String RESOURCE_TYPE = "EncounterParticipant";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public EncounterParticipant(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Role of participant in encounter.
         */
        public java.util.List<CodeableConcept> type() {
            return getList(CodeableConcept.class, FhirPropertyNames.PROPERTY_TYPE);
        }

        /**
         * The period of time that the specified participant participated in the
         * encounter. These can overlap or be sub-sets of the overall encounter's
         * period.
         */
        public Period period() {
            return getObject(Period.class, FhirPropertyNames.PROPERTY_PERIOD);
        }

        /**
         * Persons involved in the encounter other than the patient.
         */
        public Reference individual() {
            return getObject(Reference.class, FhirPropertyNames.PROPERTY_INDIVIDUAL);
        }

        public static final class Builder extends FhirObject.Builder<EncounterParticipant, EncounterParticipant.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder type(final java.util.List<CodeableConcept> type) {
                b.add(FhirPropertyNames.PROPERTY_TYPE, FhirObject.toArray(type));
                return this;
            }

            public Builder period(final Period period) {
                b.add(FhirPropertyNames.PROPERTY_PERIOD, period);
                return this;
            }

            public Builder individual(final Reference individual) {
                b.add(FhirPropertyNames.PROPERTY_INDIVIDUAL, individual);
                return this;
            }

            public EncounterParticipant build() {
                return new EncounterParticipant(b.build());
            }
        }
    }

    /**
     * An interaction between a patient and healthcare provider(s) for the
     * purpose of providing healthcare service(s) or assessing the health
     * status of a patient.
     */
    public static class EncounterStatusHistory extends FhirObject {
        public static final String RESOURCE_TYPE = "EncounterStatusHistory";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public EncounterStatusHistory(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * planned | arrived | triaged | in-progress | onleave | finished |
         * cancelled +.
         */
        public String status() {
            return getString(FhirPropertyNames.PROPERTY_STATUS);
        }

        /**
         * The time that the episode was in the specified status.
         */
        public Period period() {
            return getObject(Period.class, FhirPropertyNames.PROPERTY_PERIOD);
        }

        public static final class Builder extends FhirObject.Builder<EncounterStatusHistory, EncounterStatusHistory.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder status(final String status) {
                b.add(FhirPropertyNames.PROPERTY_STATUS, status);
                return this;
            }

            public Builder period(final Period period) {
                b.add(FhirPropertyNames.PROPERTY_PERIOD, period);
                return this;
            }

            public EncounterStatusHistory build() {
                return new EncounterStatusHistory(b.build());
            }
        }
    }
}
