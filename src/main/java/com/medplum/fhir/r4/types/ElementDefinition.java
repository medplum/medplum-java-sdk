/*
 * Generated by com.medplum.generator.Generator
 * Do not edit manually.
 */

package com.medplum.fhir.r4.types;

import jakarta.json.JsonObject;

import com.medplum.fhir.r4.FhirPropertyNames;

/**
 * Captures constraints on each element within the resource, profile, or
 * extension.
 */
public class ElementDefinition extends FhirObject {
    public static final String RESOURCE_TYPE = "ElementDefinition";

    public static Builder create() {
        return new Builder();
    }

    public static Builder create(final JsonObject data) {
        return new Builder(data);
    }

    public ElementDefinition(final JsonObject data) {
        super(data);
    }

    /**
     * Unique id for the element within a resource (for internal references).
     * This may be any string value that does not contain spaces.
     */
    public String id() {
        return getString(FhirPropertyNames.PROPERTY_ID);
    }

    /**
     * May be used to represent additional information that is not part of
     * the basic definition of the element. To make the use of extensions
     * safe and manageable, there is a strict set of governance  applied to
     * the definition and use of extensions. Though any implementer can
     * define an extension, there is a set of requirements that SHALL be met
     * as part of the definition of the extension.
     */
    public java.util.List<Extension> extension() {
        return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
    }

    /**
     * May be used to represent additional information that is not part of
     * the basic definition of the element and that modifies the
     * understanding of the element in which it is contained and/or the
     * understanding of the containing element's descendants. Usually
     * modifier elements provide negation or qualification. To make the use
     * of extensions safe and manageable, there is a strict set of governance
     * applied to the definition and use of extensions. Though any
     * implementer can define an extension, there is a set of requirements
     * that SHALL be met as part of the definition of the extension.
     * Applications processing a resource are required to check for modifier
     * extensions.
     *
     * Modifier extensions SHALL NOT change the meaning of any elements on
     * Resource or DomainResource (including cannot change the meaning of
     * modifierExtension itself).
     */
    public java.util.List<Extension> modifierExtension() {
        return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
    }

    /**
     * The path identifies the element and is expressed as a &quot;.&quot;-separated
     * list of ancestor elements, beginning with the name of the resource or
     * extension.
     */
    public String path() {
        return getString(FhirPropertyNames.PROPERTY_PATH);
    }

    /**
     * Codes that define how this element is represented in instances, when
     * the deviation varies from the normal case.
     */
    public java.util.List<String> representation() {
        return getList(String.class, FhirPropertyNames.PROPERTY_REPRESENTATION);
    }

    /**
     * The name of this element definition slice, when slicing is working.
     * The name must be a token with no dots or spaces. This is a unique name
     * referring to a specific set of constraints applied to this element,
     * used to provide a name to different slices of the same element.
     */
    public String sliceName() {
        return getString(FhirPropertyNames.PROPERTY_SLICE_NAME);
    }

    /**
     * If true, indicates that this slice definition is constraining a slice
     * definition with the same name in an inherited profile. If false, the
     * slice is not overriding any slice in an inherited profile. If missing,
     * the slice might or might not be overriding a slice in an inherited
     * profile, depending on the sliceName.
     */
    public Boolean sliceIsConstraining() {
        return data.getBoolean(FhirPropertyNames.PROPERTY_SLICE_IS_CONSTRAINING);
    }

    /**
     * A single preferred label which is the text to display beside the
     * element indicating its meaning or to use to prompt for the element in
     * a user display or form.
     */
    public String label() {
        return getString(FhirPropertyNames.PROPERTY_LABEL);
    }

    /**
     * A code that has the same meaning as the element in a particular
     * terminology.
     */
    public java.util.List<Coding> code() {
        return getList(Coding.class, FhirPropertyNames.PROPERTY_CODE);
    }

    /**
     * Indicates that the element is sliced into a set of alternative
     * definitions (i.e. in a structure definition, there are multiple
     * different constraints on a single element in the base resource).
     * Slicing can be used in any resource that has cardinality ..* on the
     * base resource, or any resource with a choice of types. The set of
     * slices is any elements that come after this in the element sequence
     * that have the same path, until a shorter path occurs (the shorter path
     * terminates the set).
     */
    public ElementDefinitionSlicing slicing() {
        return getObject(ElementDefinitionSlicing.class, FhirPropertyNames.PROPERTY_SLICING);
    }

    /**
     * A concise description of what this element means (e.g. for use in
     * autogenerated summaries).
     */
    public String shortValue() {
        return getString(FhirPropertyNames.PROPERTY_SHORT);
    }

    /**
     * Provides a complete explanation of the meaning of the data element for
     * human readability.  For the case of elements derived from existing
     * elements (e.g. constraints), the definition SHALL be consistent with
     * the base definition, but convey the meaning of the element in the
     * particular context of use of the resource. (Note: The text you are
     * reading is specified in ElementDefinition.definition).
     */
    public String definition() {
        return getString(FhirPropertyNames.PROPERTY_DEFINITION);
    }

    /**
     * Explanatory notes and implementation guidance about the data element,
     * including notes about how to use the data properly, exceptions to
     * proper use, etc. (Note: The text you are reading is specified in
     * ElementDefinition.comment).
     */
    public String comment() {
        return getString(FhirPropertyNames.PROPERTY_COMMENT);
    }

    /**
     * This element is for traceability of why the element was created and
     * why the constraints exist as they do. This may be used to point to
     * source materials or specifications that drove the structure of this
     * element.
     */
    public String requirements() {
        return getString(FhirPropertyNames.PROPERTY_REQUIREMENTS);
    }

    /**
     * Identifies additional names by which this element might also be known.
     */
    public java.util.List<String> alias() {
        return getList(String.class, FhirPropertyNames.PROPERTY_ALIAS);
    }

    /**
     * The minimum number of times this element SHALL appear in the instance.
     */
    public Integer min() {
        return data.getInt(FhirPropertyNames.PROPERTY_MIN);
    }

    /**
     * The maximum number of times this element is permitted to appear in the
     * instance.
     */
    public String max() {
        return getString(FhirPropertyNames.PROPERTY_MAX);
    }

    /**
     * Information about the base definition of the element, provided to make
     * it unnecessary for tools to trace the deviation of the element through
     * the derived and related profiles. When the element definition is not
     * the original definition of an element - i.g. either in a constraint on
     * another type, or for elements from a super type in a snap shot - then
     * the information in provided in the element definition may be different
     * to the base definition. On the original definition of the element, it
     * will be same.
     */
    public ElementDefinitionBase base() {
        return getObject(ElementDefinitionBase.class, FhirPropertyNames.PROPERTY_BASE);
    }

    /**
     * Identifies an element defined elsewhere in the definition whose
     * content rules should be applied to the current element.
     * ContentReferences bring across all the rules that are in the
     * ElementDefinition for the element, including definitions, cardinality
     * constraints, bindings, invariants etc.
     */
    public java.net.URI contentReference() {
        return getUri(FhirPropertyNames.PROPERTY_CONTENT_REFERENCE);
    }

    /**
     * The data type or resource that the value of this element is permitted
     * to be.
     */
    public java.util.List<ElementDefinitionType> type() {
        return getList(ElementDefinitionType.class, FhirPropertyNames.PROPERTY_TYPE);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public String defaultValueBase64Binary() {
        return getString(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_BASE64_BINARY);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Boolean defaultValueBoolean() {
        return data.getBoolean(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_BOOLEAN);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public String defaultValueCanonical() {
        return getString(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_CANONICAL);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public String defaultValueCode() {
        return getString(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_CODE);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public String defaultValueDate() {
        return getString(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_DATE);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public String defaultValueDateTime() {
        return getString(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_DATE_TIME);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Integer defaultValueDecimal() {
        return data.getInt(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_DECIMAL);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public String defaultValueId() {
        return getString(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_ID);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public String defaultValueInstant() {
        return getString(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_INSTANT);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Integer defaultValueInteger() {
        return data.getInt(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_INTEGER);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public String defaultValueMarkdown() {
        return getString(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_MARKDOWN);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public String defaultValueOid() {
        return getString(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_OID);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Integer defaultValuePositiveInt() {
        return data.getInt(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_POSITIVE_INT);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public String defaultValueString() {
        return getString(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_STRING);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public String defaultValueTime() {
        return getString(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_TIME);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Integer defaultValueUnsignedInt() {
        return data.getInt(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_UNSIGNED_INT);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public String defaultValueUri() {
        return getString(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_URI);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public String defaultValueUrl() {
        return getString(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_URL);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public String defaultValueUuid() {
        return getString(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_UUID);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Address defaultValueAddress() {
        return getObject(Address.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_ADDRESS);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Age defaultValueAge() {
        return getObject(Age.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_AGE);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Annotation defaultValueAnnotation() {
        return getObject(Annotation.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_ANNOTATION);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Attachment defaultValueAttachment() {
        return getObject(Attachment.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_ATTACHMENT);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public CodeableConcept defaultValueCodeableConcept() {
        return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_CODEABLE_CONCEPT);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Coding defaultValueCoding() {
        return getObject(Coding.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_CODING);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public ContactPoint defaultValueContactPoint() {
        return getObject(ContactPoint.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_CONTACT_POINT);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Count defaultValueCount() {
        return getObject(Count.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_COUNT);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Distance defaultValueDistance() {
        return getObject(Distance.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_DISTANCE);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Duration defaultValueDuration() {
        return getObject(Duration.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_DURATION);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public HumanName defaultValueHumanName() {
        return getObject(HumanName.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_HUMAN_NAME);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Identifier defaultValueIdentifier() {
        return getObject(Identifier.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_IDENTIFIER);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Money defaultValueMoney() {
        return getObject(Money.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_MONEY);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Period defaultValuePeriod() {
        return getObject(Period.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_PERIOD);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Quantity defaultValueQuantity() {
        return getObject(Quantity.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_QUANTITY);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Range defaultValueRange() {
        return getObject(Range.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_RANGE);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Ratio defaultValueRatio() {
        return getObject(Ratio.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_RATIO);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Reference defaultValueReference() {
        return getObject(Reference.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_REFERENCE);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public SampledData defaultValueSampledData() {
        return getObject(SampledData.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_SAMPLED_DATA);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Signature defaultValueSignature() {
        return getObject(Signature.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_SIGNATURE);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Timing defaultValueTiming() {
        return getObject(Timing.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_TIMING);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public ContactDetail defaultValueContactDetail() {
        return getObject(ContactDetail.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_CONTACT_DETAIL);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Contributor defaultValueContributor() {
        return getObject(Contributor.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_CONTRIBUTOR);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public DataRequirement defaultValueDataRequirement() {
        return getObject(DataRequirement.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_DATA_REQUIREMENT);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Expression defaultValueExpression() {
        return getObject(Expression.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_EXPRESSION);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public ParameterDefinition defaultValueParameterDefinition() {
        return getObject(ParameterDefinition.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_PARAMETER_DEFINITION);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public RelatedArtifact defaultValueRelatedArtifact() {
        return getObject(RelatedArtifact.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_RELATED_ARTIFACT);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public TriggerDefinition defaultValueTriggerDefinition() {
        return getObject(TriggerDefinition.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_TRIGGER_DEFINITION);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public UsageContext defaultValueUsageContext() {
        return getObject(UsageContext.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_USAGE_CONTEXT);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Dosage defaultValueDosage() {
        return getObject(Dosage.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_DOSAGE);
    }

    /**
     * The value that should be used if there is no value stated in the
     * instance (e.g. 'if not otherwise specified, the abstract is false').
     */
    public Meta defaultValueMeta() {
        return getObject(Meta.class, FhirPropertyNames.PROPERTY_DEFAULT_VALUE_META);
    }

    /**
     * The Implicit meaning that is to be understood when this element is
     * missing (e.g. 'when this element is missing, the period is ongoing').
     */
    public String meaningWhenMissing() {
        return getString(FhirPropertyNames.PROPERTY_MEANING_WHEN_MISSING);
    }

    /**
     * If present, indicates that the order of the repeating element has
     * meaning and describes what that meaning is.  If absent, it means that
     * the order of the element has no meaning.
     */
    public String orderMeaning() {
        return getString(FhirPropertyNames.PROPERTY_ORDER_MEANING);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public String fixedBase64Binary() {
        return getString(FhirPropertyNames.PROPERTY_FIXED_BASE64_BINARY);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Boolean fixedBoolean() {
        return data.getBoolean(FhirPropertyNames.PROPERTY_FIXED_BOOLEAN);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public String fixedCanonical() {
        return getString(FhirPropertyNames.PROPERTY_FIXED_CANONICAL);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public String fixedCode() {
        return getString(FhirPropertyNames.PROPERTY_FIXED_CODE);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public String fixedDate() {
        return getString(FhirPropertyNames.PROPERTY_FIXED_DATE);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public String fixedDateTime() {
        return getString(FhirPropertyNames.PROPERTY_FIXED_DATE_TIME);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Integer fixedDecimal() {
        return data.getInt(FhirPropertyNames.PROPERTY_FIXED_DECIMAL);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public String fixedId() {
        return getString(FhirPropertyNames.PROPERTY_FIXED_ID);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public String fixedInstant() {
        return getString(FhirPropertyNames.PROPERTY_FIXED_INSTANT);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Integer fixedInteger() {
        return data.getInt(FhirPropertyNames.PROPERTY_FIXED_INTEGER);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public String fixedMarkdown() {
        return getString(FhirPropertyNames.PROPERTY_FIXED_MARKDOWN);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public String fixedOid() {
        return getString(FhirPropertyNames.PROPERTY_FIXED_OID);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Integer fixedPositiveInt() {
        return data.getInt(FhirPropertyNames.PROPERTY_FIXED_POSITIVE_INT);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public String fixedString() {
        return getString(FhirPropertyNames.PROPERTY_FIXED_STRING);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public String fixedTime() {
        return getString(FhirPropertyNames.PROPERTY_FIXED_TIME);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Integer fixedUnsignedInt() {
        return data.getInt(FhirPropertyNames.PROPERTY_FIXED_UNSIGNED_INT);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public String fixedUri() {
        return getString(FhirPropertyNames.PROPERTY_FIXED_URI);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public String fixedUrl() {
        return getString(FhirPropertyNames.PROPERTY_FIXED_URL);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public String fixedUuid() {
        return getString(FhirPropertyNames.PROPERTY_FIXED_UUID);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Address fixedAddress() {
        return getObject(Address.class, FhirPropertyNames.PROPERTY_FIXED_ADDRESS);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Age fixedAge() {
        return getObject(Age.class, FhirPropertyNames.PROPERTY_FIXED_AGE);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Annotation fixedAnnotation() {
        return getObject(Annotation.class, FhirPropertyNames.PROPERTY_FIXED_ANNOTATION);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Attachment fixedAttachment() {
        return getObject(Attachment.class, FhirPropertyNames.PROPERTY_FIXED_ATTACHMENT);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public CodeableConcept fixedCodeableConcept() {
        return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_FIXED_CODEABLE_CONCEPT);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Coding fixedCoding() {
        return getObject(Coding.class, FhirPropertyNames.PROPERTY_FIXED_CODING);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public ContactPoint fixedContactPoint() {
        return getObject(ContactPoint.class, FhirPropertyNames.PROPERTY_FIXED_CONTACT_POINT);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Count fixedCount() {
        return getObject(Count.class, FhirPropertyNames.PROPERTY_FIXED_COUNT);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Distance fixedDistance() {
        return getObject(Distance.class, FhirPropertyNames.PROPERTY_FIXED_DISTANCE);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Duration fixedDuration() {
        return getObject(Duration.class, FhirPropertyNames.PROPERTY_FIXED_DURATION);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public HumanName fixedHumanName() {
        return getObject(HumanName.class, FhirPropertyNames.PROPERTY_FIXED_HUMAN_NAME);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Identifier fixedIdentifier() {
        return getObject(Identifier.class, FhirPropertyNames.PROPERTY_FIXED_IDENTIFIER);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Money fixedMoney() {
        return getObject(Money.class, FhirPropertyNames.PROPERTY_FIXED_MONEY);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Period fixedPeriod() {
        return getObject(Period.class, FhirPropertyNames.PROPERTY_FIXED_PERIOD);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Quantity fixedQuantity() {
        return getObject(Quantity.class, FhirPropertyNames.PROPERTY_FIXED_QUANTITY);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Range fixedRange() {
        return getObject(Range.class, FhirPropertyNames.PROPERTY_FIXED_RANGE);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Ratio fixedRatio() {
        return getObject(Ratio.class, FhirPropertyNames.PROPERTY_FIXED_RATIO);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Reference fixedReference() {
        return getObject(Reference.class, FhirPropertyNames.PROPERTY_FIXED_REFERENCE);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public SampledData fixedSampledData() {
        return getObject(SampledData.class, FhirPropertyNames.PROPERTY_FIXED_SAMPLED_DATA);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Signature fixedSignature() {
        return getObject(Signature.class, FhirPropertyNames.PROPERTY_FIXED_SIGNATURE);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Timing fixedTiming() {
        return getObject(Timing.class, FhirPropertyNames.PROPERTY_FIXED_TIMING);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public ContactDetail fixedContactDetail() {
        return getObject(ContactDetail.class, FhirPropertyNames.PROPERTY_FIXED_CONTACT_DETAIL);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Contributor fixedContributor() {
        return getObject(Contributor.class, FhirPropertyNames.PROPERTY_FIXED_CONTRIBUTOR);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public DataRequirement fixedDataRequirement() {
        return getObject(DataRequirement.class, FhirPropertyNames.PROPERTY_FIXED_DATA_REQUIREMENT);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Expression fixedExpression() {
        return getObject(Expression.class, FhirPropertyNames.PROPERTY_FIXED_EXPRESSION);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public ParameterDefinition fixedParameterDefinition() {
        return getObject(ParameterDefinition.class, FhirPropertyNames.PROPERTY_FIXED_PARAMETER_DEFINITION);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public RelatedArtifact fixedRelatedArtifact() {
        return getObject(RelatedArtifact.class, FhirPropertyNames.PROPERTY_FIXED_RELATED_ARTIFACT);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public TriggerDefinition fixedTriggerDefinition() {
        return getObject(TriggerDefinition.class, FhirPropertyNames.PROPERTY_FIXED_TRIGGER_DEFINITION);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public UsageContext fixedUsageContext() {
        return getObject(UsageContext.class, FhirPropertyNames.PROPERTY_FIXED_USAGE_CONTEXT);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Dosage fixedDosage() {
        return getObject(Dosage.class, FhirPropertyNames.PROPERTY_FIXED_DOSAGE);
    }

    /**
     * Specifies a value that SHALL be exactly the value  for this element in
     * the instance. For purposes of comparison, non-significant whitespace
     * is ignored, and all values must be an exact match (case and accent
     * sensitive). Missing elements/attributes must also be missing.
     */
    public Meta fixedMeta() {
        return getObject(Meta.class, FhirPropertyNames.PROPERTY_FIXED_META);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public String patternBase64Binary() {
        return getString(FhirPropertyNames.PROPERTY_PATTERN_BASE64_BINARY);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Boolean patternBoolean() {
        return data.getBoolean(FhirPropertyNames.PROPERTY_PATTERN_BOOLEAN);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public String patternCanonical() {
        return getString(FhirPropertyNames.PROPERTY_PATTERN_CANONICAL);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public String patternCode() {
        return getString(FhirPropertyNames.PROPERTY_PATTERN_CODE);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public String patternDate() {
        return getString(FhirPropertyNames.PROPERTY_PATTERN_DATE);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public String patternDateTime() {
        return getString(FhirPropertyNames.PROPERTY_PATTERN_DATE_TIME);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Integer patternDecimal() {
        return data.getInt(FhirPropertyNames.PROPERTY_PATTERN_DECIMAL);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public String patternId() {
        return getString(FhirPropertyNames.PROPERTY_PATTERN_ID);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public String patternInstant() {
        return getString(FhirPropertyNames.PROPERTY_PATTERN_INSTANT);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Integer patternInteger() {
        return data.getInt(FhirPropertyNames.PROPERTY_PATTERN_INTEGER);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public String patternMarkdown() {
        return getString(FhirPropertyNames.PROPERTY_PATTERN_MARKDOWN);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public String patternOid() {
        return getString(FhirPropertyNames.PROPERTY_PATTERN_OID);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Integer patternPositiveInt() {
        return data.getInt(FhirPropertyNames.PROPERTY_PATTERN_POSITIVE_INT);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public String patternString() {
        return getString(FhirPropertyNames.PROPERTY_PATTERN_STRING);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public String patternTime() {
        return getString(FhirPropertyNames.PROPERTY_PATTERN_TIME);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Integer patternUnsignedInt() {
        return data.getInt(FhirPropertyNames.PROPERTY_PATTERN_UNSIGNED_INT);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public String patternUri() {
        return getString(FhirPropertyNames.PROPERTY_PATTERN_URI);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public String patternUrl() {
        return getString(FhirPropertyNames.PROPERTY_PATTERN_URL);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public String patternUuid() {
        return getString(FhirPropertyNames.PROPERTY_PATTERN_UUID);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Address patternAddress() {
        return getObject(Address.class, FhirPropertyNames.PROPERTY_PATTERN_ADDRESS);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Age patternAge() {
        return getObject(Age.class, FhirPropertyNames.PROPERTY_PATTERN_AGE);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Annotation patternAnnotation() {
        return getObject(Annotation.class, FhirPropertyNames.PROPERTY_PATTERN_ANNOTATION);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Attachment patternAttachment() {
        return getObject(Attachment.class, FhirPropertyNames.PROPERTY_PATTERN_ATTACHMENT);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public CodeableConcept patternCodeableConcept() {
        return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_PATTERN_CODEABLE_CONCEPT);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Coding patternCoding() {
        return getObject(Coding.class, FhirPropertyNames.PROPERTY_PATTERN_CODING);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public ContactPoint patternContactPoint() {
        return getObject(ContactPoint.class, FhirPropertyNames.PROPERTY_PATTERN_CONTACT_POINT);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Count patternCount() {
        return getObject(Count.class, FhirPropertyNames.PROPERTY_PATTERN_COUNT);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Distance patternDistance() {
        return getObject(Distance.class, FhirPropertyNames.PROPERTY_PATTERN_DISTANCE);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Duration patternDuration() {
        return getObject(Duration.class, FhirPropertyNames.PROPERTY_PATTERN_DURATION);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public HumanName patternHumanName() {
        return getObject(HumanName.class, FhirPropertyNames.PROPERTY_PATTERN_HUMAN_NAME);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Identifier patternIdentifier() {
        return getObject(Identifier.class, FhirPropertyNames.PROPERTY_PATTERN_IDENTIFIER);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Money patternMoney() {
        return getObject(Money.class, FhirPropertyNames.PROPERTY_PATTERN_MONEY);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Period patternPeriod() {
        return getObject(Period.class, FhirPropertyNames.PROPERTY_PATTERN_PERIOD);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Quantity patternQuantity() {
        return getObject(Quantity.class, FhirPropertyNames.PROPERTY_PATTERN_QUANTITY);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Range patternRange() {
        return getObject(Range.class, FhirPropertyNames.PROPERTY_PATTERN_RANGE);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Ratio patternRatio() {
        return getObject(Ratio.class, FhirPropertyNames.PROPERTY_PATTERN_RATIO);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Reference patternReference() {
        return getObject(Reference.class, FhirPropertyNames.PROPERTY_PATTERN_REFERENCE);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public SampledData patternSampledData() {
        return getObject(SampledData.class, FhirPropertyNames.PROPERTY_PATTERN_SAMPLED_DATA);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Signature patternSignature() {
        return getObject(Signature.class, FhirPropertyNames.PROPERTY_PATTERN_SIGNATURE);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Timing patternTiming() {
        return getObject(Timing.class, FhirPropertyNames.PROPERTY_PATTERN_TIMING);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public ContactDetail patternContactDetail() {
        return getObject(ContactDetail.class, FhirPropertyNames.PROPERTY_PATTERN_CONTACT_DETAIL);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Contributor patternContributor() {
        return getObject(Contributor.class, FhirPropertyNames.PROPERTY_PATTERN_CONTRIBUTOR);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public DataRequirement patternDataRequirement() {
        return getObject(DataRequirement.class, FhirPropertyNames.PROPERTY_PATTERN_DATA_REQUIREMENT);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Expression patternExpression() {
        return getObject(Expression.class, FhirPropertyNames.PROPERTY_PATTERN_EXPRESSION);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public ParameterDefinition patternParameterDefinition() {
        return getObject(ParameterDefinition.class, FhirPropertyNames.PROPERTY_PATTERN_PARAMETER_DEFINITION);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public RelatedArtifact patternRelatedArtifact() {
        return getObject(RelatedArtifact.class, FhirPropertyNames.PROPERTY_PATTERN_RELATED_ARTIFACT);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public TriggerDefinition patternTriggerDefinition() {
        return getObject(TriggerDefinition.class, FhirPropertyNames.PROPERTY_PATTERN_TRIGGER_DEFINITION);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public UsageContext patternUsageContext() {
        return getObject(UsageContext.class, FhirPropertyNames.PROPERTY_PATTERN_USAGE_CONTEXT);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Dosage patternDosage() {
        return getObject(Dosage.class, FhirPropertyNames.PROPERTY_PATTERN_DOSAGE);
    }

    /**
     * Specifies a value that the value in the instance SHALL follow - that
     * is, any value in the pattern must be found in the instance. Other
     * additional values may be found too. This is effectively constraint by
     * example.
     *
     * When pattern[x] is used to constrain a primitive, it means that the
     * value provided in the pattern[x] must match the instance value
     * exactly.
     *
     * When pattern[x] is used to constrain an array, it means that each
     * element provided in the pattern[x] array must (recursively) match at
     * least one element from the instance array.
     *
     * When pattern[x] is used to constrain a complex object, it means that
     * each property in the pattern must be present in the complex object,
     * and its value must recursively match -- i.e.,
     *
     * 1. If primitive: it must match exactly the pattern value
     * 2. If a complex object: it must match (recursively) the pattern value
     * 3. If an array: it must match (recursively) the pattern value.
     */
    public Meta patternMeta() {
        return getObject(Meta.class, FhirPropertyNames.PROPERTY_PATTERN_META);
    }

    /**
     * A sample value for this element demonstrating the type of information
     * that would typically be found in the element.
     */
    public java.util.List<ElementDefinitionExample> example() {
        return getList(ElementDefinitionExample.class, FhirPropertyNames.PROPERTY_EXAMPLE);
    }

    /**
     * The minimum allowed value for the element. The value is inclusive.
     * This is allowed for the types date, dateTime, instant, time, decimal,
     * integer, and Quantity.
     */
    public String minValueDate() {
        return getString(FhirPropertyNames.PROPERTY_MIN_VALUE_DATE);
    }

    /**
     * The minimum allowed value for the element. The value is inclusive.
     * This is allowed for the types date, dateTime, instant, time, decimal,
     * integer, and Quantity.
     */
    public String minValueDateTime() {
        return getString(FhirPropertyNames.PROPERTY_MIN_VALUE_DATE_TIME);
    }

    /**
     * The minimum allowed value for the element. The value is inclusive.
     * This is allowed for the types date, dateTime, instant, time, decimal,
     * integer, and Quantity.
     */
    public String minValueInstant() {
        return getString(FhirPropertyNames.PROPERTY_MIN_VALUE_INSTANT);
    }

    /**
     * The minimum allowed value for the element. The value is inclusive.
     * This is allowed for the types date, dateTime, instant, time, decimal,
     * integer, and Quantity.
     */
    public String minValueTime() {
        return getString(FhirPropertyNames.PROPERTY_MIN_VALUE_TIME);
    }

    /**
     * The minimum allowed value for the element. The value is inclusive.
     * This is allowed for the types date, dateTime, instant, time, decimal,
     * integer, and Quantity.
     */
    public Integer minValueDecimal() {
        return data.getInt(FhirPropertyNames.PROPERTY_MIN_VALUE_DECIMAL);
    }

    /**
     * The minimum allowed value for the element. The value is inclusive.
     * This is allowed for the types date, dateTime, instant, time, decimal,
     * integer, and Quantity.
     */
    public Integer minValueInteger() {
        return data.getInt(FhirPropertyNames.PROPERTY_MIN_VALUE_INTEGER);
    }

    /**
     * The minimum allowed value for the element. The value is inclusive.
     * This is allowed for the types date, dateTime, instant, time, decimal,
     * integer, and Quantity.
     */
    public Integer minValuePositiveInt() {
        return data.getInt(FhirPropertyNames.PROPERTY_MIN_VALUE_POSITIVE_INT);
    }

    /**
     * The minimum allowed value for the element. The value is inclusive.
     * This is allowed for the types date, dateTime, instant, time, decimal,
     * integer, and Quantity.
     */
    public Integer minValueUnsignedInt() {
        return data.getInt(FhirPropertyNames.PROPERTY_MIN_VALUE_UNSIGNED_INT);
    }

    /**
     * The minimum allowed value for the element. The value is inclusive.
     * This is allowed for the types date, dateTime, instant, time, decimal,
     * integer, and Quantity.
     */
    public Quantity minValueQuantity() {
        return getObject(Quantity.class, FhirPropertyNames.PROPERTY_MIN_VALUE_QUANTITY);
    }

    /**
     * The maximum allowed value for the element. The value is inclusive.
     * This is allowed for the types date, dateTime, instant, time, decimal,
     * integer, and Quantity.
     */
    public String maxValueDate() {
        return getString(FhirPropertyNames.PROPERTY_MAX_VALUE_DATE);
    }

    /**
     * The maximum allowed value for the element. The value is inclusive.
     * This is allowed for the types date, dateTime, instant, time, decimal,
     * integer, and Quantity.
     */
    public String maxValueDateTime() {
        return getString(FhirPropertyNames.PROPERTY_MAX_VALUE_DATE_TIME);
    }

    /**
     * The maximum allowed value for the element. The value is inclusive.
     * This is allowed for the types date, dateTime, instant, time, decimal,
     * integer, and Quantity.
     */
    public String maxValueInstant() {
        return getString(FhirPropertyNames.PROPERTY_MAX_VALUE_INSTANT);
    }

    /**
     * The maximum allowed value for the element. The value is inclusive.
     * This is allowed for the types date, dateTime, instant, time, decimal,
     * integer, and Quantity.
     */
    public String maxValueTime() {
        return getString(FhirPropertyNames.PROPERTY_MAX_VALUE_TIME);
    }

    /**
     * The maximum allowed value for the element. The value is inclusive.
     * This is allowed for the types date, dateTime, instant, time, decimal,
     * integer, and Quantity.
     */
    public Integer maxValueDecimal() {
        return data.getInt(FhirPropertyNames.PROPERTY_MAX_VALUE_DECIMAL);
    }

    /**
     * The maximum allowed value for the element. The value is inclusive.
     * This is allowed for the types date, dateTime, instant, time, decimal,
     * integer, and Quantity.
     */
    public Integer maxValueInteger() {
        return data.getInt(FhirPropertyNames.PROPERTY_MAX_VALUE_INTEGER);
    }

    /**
     * The maximum allowed value for the element. The value is inclusive.
     * This is allowed for the types date, dateTime, instant, time, decimal,
     * integer, and Quantity.
     */
    public Integer maxValuePositiveInt() {
        return data.getInt(FhirPropertyNames.PROPERTY_MAX_VALUE_POSITIVE_INT);
    }

    /**
     * The maximum allowed value for the element. The value is inclusive.
     * This is allowed for the types date, dateTime, instant, time, decimal,
     * integer, and Quantity.
     */
    public Integer maxValueUnsignedInt() {
        return data.getInt(FhirPropertyNames.PROPERTY_MAX_VALUE_UNSIGNED_INT);
    }

    /**
     * The maximum allowed value for the element. The value is inclusive.
     * This is allowed for the types date, dateTime, instant, time, decimal,
     * integer, and Quantity.
     */
    public Quantity maxValueQuantity() {
        return getObject(Quantity.class, FhirPropertyNames.PROPERTY_MAX_VALUE_QUANTITY);
    }

    /**
     * Indicates the maximum length in characters that is permitted to be
     * present in conformant instances and which is expected to be supported
     * by conformant consumers that support the element.
     */
    public Integer maxLength() {
        return data.getInt(FhirPropertyNames.PROPERTY_MAX_LENGTH);
    }

    /**
     * A reference to an invariant that may make additional statements about
     * the cardinality or value in the instance.
     */
    public java.util.List<String> condition() {
        return getList(String.class, FhirPropertyNames.PROPERTY_CONDITION);
    }

    /**
     * Formal constraints such as co-occurrence and other constraints that
     * can be computationally evaluated within the context of the instance.
     */
    public java.util.List<ElementDefinitionConstraint> constraint() {
        return getList(ElementDefinitionConstraint.class, FhirPropertyNames.PROPERTY_CONSTRAINT);
    }

    /**
     * If true, implementations that produce or consume resources SHALL
     * provide &quot;support&quot; for the element in some meaningful way.  If false,
     * the element may be ignored and not supported. If false, whether to
     * populate or use the data element in any way is at the discretion of
     * the implementation.
     */
    public Boolean mustSupport() {
        return data.getBoolean(FhirPropertyNames.PROPERTY_MUST_SUPPORT);
    }

    /**
     * If true, the value of this element affects the interpretation of the
     * element or resource that contains it, and the value of the element
     * cannot be ignored. Typically, this is used for status, negation and
     * qualification codes. The effect of this is that the element cannot be
     * ignored by systems: they SHALL either recognize the element and
     * process it, and/or a pre-determination has been made that it is not
     * relevant to their particular system.
     */
    public Boolean isModifier() {
        return data.getBoolean(FhirPropertyNames.PROPERTY_IS_MODIFIER);
    }

    /**
     * Explains how that element affects the interpretation of the resource
     * or element that contains it.
     */
    public String isModifierReason() {
        return getString(FhirPropertyNames.PROPERTY_IS_MODIFIER_REASON);
    }

    /**
     * Whether the element should be included if a client requests a search
     * with the parameter _summary=true.
     */
    public Boolean isSummary() {
        return data.getBoolean(FhirPropertyNames.PROPERTY_IS_SUMMARY);
    }

    /**
     * Binds to a value set if this element is coded (code, Coding,
     * CodeableConcept, Quantity), or the data types (string, uri).
     */
    public ElementDefinitionBinding binding() {
        return getObject(ElementDefinitionBinding.class, FhirPropertyNames.PROPERTY_BINDING);
    }

    /**
     * Identifies a concept from an external specification that roughly
     * corresponds to this element.
     */
    public java.util.List<ElementDefinitionMapping> mapping() {
        return getList(ElementDefinitionMapping.class, FhirPropertyNames.PROPERTY_MAPPING);
    }

    public static final class Builder extends FhirObject.Builder<ElementDefinition, ElementDefinition.Builder> {

        private Builder() {
            super();
        }

        private Builder(final JsonObject data) {
            super(data);
        }

        public Builder id(final String id) {
            b.add(FhirPropertyNames.PROPERTY_ID, id);
            return this;
        }

        public Builder extension(final java.util.List<Extension> extension) {
            b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
            return this;
        }

        public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
            b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
            return this;
        }

        public Builder path(final String path) {
            b.add(FhirPropertyNames.PROPERTY_PATH, path);
            return this;
        }

        public Builder representation(final java.util.List<String> representation) {
            b.add(FhirPropertyNames.PROPERTY_REPRESENTATION, FhirObject.toStringArray(representation));
            return this;
        }

        public Builder sliceName(final String sliceName) {
            b.add(FhirPropertyNames.PROPERTY_SLICE_NAME, sliceName);
            return this;
        }

        public Builder sliceIsConstraining(final Boolean sliceIsConstraining) {
            b.add(FhirPropertyNames.PROPERTY_SLICE_IS_CONSTRAINING, sliceIsConstraining);
            return this;
        }

        public Builder label(final String label) {
            b.add(FhirPropertyNames.PROPERTY_LABEL, label);
            return this;
        }

        public Builder code(final java.util.List<Coding> code) {
            b.add(FhirPropertyNames.PROPERTY_CODE, FhirObject.toArray(code));
            return this;
        }

        public Builder slicing(final ElementDefinitionSlicing slicing) {
            b.add(FhirPropertyNames.PROPERTY_SLICING, slicing);
            return this;
        }

        public Builder shortValue(final String shortValue) {
            b.add(FhirPropertyNames.PROPERTY_SHORT, shortValue);
            return this;
        }

        public Builder definition(final String definition) {
            b.add(FhirPropertyNames.PROPERTY_DEFINITION, definition);
            return this;
        }

        public Builder comment(final String comment) {
            b.add(FhirPropertyNames.PROPERTY_COMMENT, comment);
            return this;
        }

        public Builder requirements(final String requirements) {
            b.add(FhirPropertyNames.PROPERTY_REQUIREMENTS, requirements);
            return this;
        }

        public Builder alias(final java.util.List<String> alias) {
            b.add(FhirPropertyNames.PROPERTY_ALIAS, FhirObject.toStringArray(alias));
            return this;
        }

        public Builder min(final Integer min) {
            b.add(FhirPropertyNames.PROPERTY_MIN, min);
            return this;
        }

        public Builder max(final String max) {
            b.add(FhirPropertyNames.PROPERTY_MAX, max);
            return this;
        }

        public Builder base(final ElementDefinitionBase base) {
            b.add(FhirPropertyNames.PROPERTY_BASE, base);
            return this;
        }

        public Builder contentReference(final java.net.URI contentReference) {
            b.add(FhirPropertyNames.PROPERTY_CONTENT_REFERENCE, contentReference.toString());
            return this;
        }

        public Builder type(final java.util.List<ElementDefinitionType> type) {
            b.add(FhirPropertyNames.PROPERTY_TYPE, FhirObject.toArray(type));
            return this;
        }

        public Builder defaultValueBase64Binary(final String defaultValueBase64Binary) {
            b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_BASE64_BINARY, defaultValueBase64Binary);
            return this;
        }

        public Builder defaultValueBoolean(final Boolean defaultValueBoolean) {
            b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_BOOLEAN, defaultValueBoolean);
            return this;
        }

        public Builder defaultValueCanonical(final String defaultValueCanonical) {
            b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_CANONICAL, defaultValueCanonical);
            return this;
        }

        public Builder defaultValueCode(final String defaultValueCode) {
            b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_CODE, defaultValueCode);
            return this;
        }

        public Builder defaultValueDate(final String defaultValueDate) {
            b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_DATE, defaultValueDate);
            return this;
        }

        public Builder defaultValueDateTime(final String defaultValueDateTime) {
            b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_DATE_TIME, defaultValueDateTime);
            return this;
        }

        public Builder defaultValueDecimal(final Integer defaultValueDecimal) {
            b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_DECIMAL, defaultValueDecimal);
            return this;
        }

        public Builder defaultValueId(final String defaultValueId) {
            b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_ID, defaultValueId);
            return this;
        }

        public Builder defaultValueInstant(final String defaultValueInstant) {
            b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_INSTANT, defaultValueInstant);
            return this;
        }

        public Builder defaultValueInteger(final Integer defaultValueInteger) {
            b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_INTEGER, defaultValueInteger);
            return this;
        }

        public Builder defaultValueMarkdown(final String defaultValueMarkdown) {
            b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_MARKDOWN, defaultValueMarkdown);
            return this;
        }

        public Builder defaultValueOid(final String defaultValueOid) {
            b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_OID, defaultValueOid);
            return this;
        }

        public Builder defaultValuePositiveInt(final Integer defaultValuePositiveInt) {
            b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_POSITIVE_INT, defaultValuePositiveInt);
            return this;
        }

        public Builder defaultValueString(final String defaultValueString) {
            b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_STRING, defaultValueString);
            return this;
        }

        public Builder defaultValueTime(final String defaultValueTime) {
            b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_TIME, defaultValueTime);
            return this;
        }

        public Builder defaultValueUnsignedInt(final Integer defaultValueUnsignedInt) {
            b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_UNSIGNED_INT, defaultValueUnsignedInt);
            return this;
        }

        public Builder defaultValueUri(final String defaultValueUri) {
            b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_URI, defaultValueUri);
            return this;
        }

        public Builder defaultValueUrl(final String defaultValueUrl) {
            b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_URL, defaultValueUrl);
            return this;
        }

        public Builder defaultValueUuid(final String defaultValueUuid) {
            b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_UUID, defaultValueUuid);
            return this;
        }

        public Builder defaultValueAddress(final Address defaultValueAddress) {
            b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_ADDRESS, defaultValueAddress);
            return this;
        }

        public Builder defaultValueAge(final Age defaultValueAge) {
            b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_AGE, defaultValueAge);
            return this;
        }

        public Builder defaultValueAnnotation(final Annotation defaultValueAnnotation) {
            b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_ANNOTATION, defaultValueAnnotation);
            return this;
        }

        public Builder defaultValueAttachment(final Attachment defaultValueAttachment) {
            b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_ATTACHMENT, defaultValueAttachment);
            return this;
        }

        public Builder defaultValueCodeableConcept(final CodeableConcept defaultValueCodeableConcept) {
            b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_CODEABLE_CONCEPT, defaultValueCodeableConcept);
            return this;
        }

        public Builder defaultValueCoding(final Coding defaultValueCoding) {
            b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_CODING, defaultValueCoding);
            return this;
        }

        public Builder defaultValueContactPoint(final ContactPoint defaultValueContactPoint) {
            b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_CONTACT_POINT, defaultValueContactPoint);
            return this;
        }

        public Builder defaultValueCount(final Count defaultValueCount) {
            b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_COUNT, defaultValueCount);
            return this;
        }

        public Builder defaultValueDistance(final Distance defaultValueDistance) {
            b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_DISTANCE, defaultValueDistance);
            return this;
        }

        public Builder defaultValueDuration(final Duration defaultValueDuration) {
            b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_DURATION, defaultValueDuration);
            return this;
        }

        public Builder defaultValueHumanName(final HumanName defaultValueHumanName) {
            b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_HUMAN_NAME, defaultValueHumanName);
            return this;
        }

        public Builder defaultValueIdentifier(final Identifier defaultValueIdentifier) {
            b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_IDENTIFIER, defaultValueIdentifier);
            return this;
        }

        public Builder defaultValueMoney(final Money defaultValueMoney) {
            b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_MONEY, defaultValueMoney);
            return this;
        }

        public Builder defaultValuePeriod(final Period defaultValuePeriod) {
            b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_PERIOD, defaultValuePeriod);
            return this;
        }

        public Builder defaultValueQuantity(final Quantity defaultValueQuantity) {
            b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_QUANTITY, defaultValueQuantity);
            return this;
        }

        public Builder defaultValueRange(final Range defaultValueRange) {
            b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_RANGE, defaultValueRange);
            return this;
        }

        public Builder defaultValueRatio(final Ratio defaultValueRatio) {
            b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_RATIO, defaultValueRatio);
            return this;
        }

        public Builder defaultValueReference(final Reference defaultValueReference) {
            b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_REFERENCE, defaultValueReference);
            return this;
        }

        public Builder defaultValueSampledData(final SampledData defaultValueSampledData) {
            b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_SAMPLED_DATA, defaultValueSampledData);
            return this;
        }

        public Builder defaultValueSignature(final Signature defaultValueSignature) {
            b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_SIGNATURE, defaultValueSignature);
            return this;
        }

        public Builder defaultValueTiming(final Timing defaultValueTiming) {
            b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_TIMING, defaultValueTiming);
            return this;
        }

        public Builder defaultValueContactDetail(final ContactDetail defaultValueContactDetail) {
            b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_CONTACT_DETAIL, defaultValueContactDetail);
            return this;
        }

        public Builder defaultValueContributor(final Contributor defaultValueContributor) {
            b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_CONTRIBUTOR, defaultValueContributor);
            return this;
        }

        public Builder defaultValueDataRequirement(final DataRequirement defaultValueDataRequirement) {
            b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_DATA_REQUIREMENT, defaultValueDataRequirement);
            return this;
        }

        public Builder defaultValueExpression(final Expression defaultValueExpression) {
            b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_EXPRESSION, defaultValueExpression);
            return this;
        }

        public Builder defaultValueParameterDefinition(final ParameterDefinition defaultValueParameterDefinition) {
            b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_PARAMETER_DEFINITION, defaultValueParameterDefinition);
            return this;
        }

        public Builder defaultValueRelatedArtifact(final RelatedArtifact defaultValueRelatedArtifact) {
            b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_RELATED_ARTIFACT, defaultValueRelatedArtifact);
            return this;
        }

        public Builder defaultValueTriggerDefinition(final TriggerDefinition defaultValueTriggerDefinition) {
            b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_TRIGGER_DEFINITION, defaultValueTriggerDefinition);
            return this;
        }

        public Builder defaultValueUsageContext(final UsageContext defaultValueUsageContext) {
            b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_USAGE_CONTEXT, defaultValueUsageContext);
            return this;
        }

        public Builder defaultValueDosage(final Dosage defaultValueDosage) {
            b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_DOSAGE, defaultValueDosage);
            return this;
        }

        public Builder defaultValueMeta(final Meta defaultValueMeta) {
            b.add(FhirPropertyNames.PROPERTY_DEFAULT_VALUE_META, defaultValueMeta);
            return this;
        }

        public Builder meaningWhenMissing(final String meaningWhenMissing) {
            b.add(FhirPropertyNames.PROPERTY_MEANING_WHEN_MISSING, meaningWhenMissing);
            return this;
        }

        public Builder orderMeaning(final String orderMeaning) {
            b.add(FhirPropertyNames.PROPERTY_ORDER_MEANING, orderMeaning);
            return this;
        }

        public Builder fixedBase64Binary(final String fixedBase64Binary) {
            b.add(FhirPropertyNames.PROPERTY_FIXED_BASE64_BINARY, fixedBase64Binary);
            return this;
        }

        public Builder fixedBoolean(final Boolean fixedBoolean) {
            b.add(FhirPropertyNames.PROPERTY_FIXED_BOOLEAN, fixedBoolean);
            return this;
        }

        public Builder fixedCanonical(final String fixedCanonical) {
            b.add(FhirPropertyNames.PROPERTY_FIXED_CANONICAL, fixedCanonical);
            return this;
        }

        public Builder fixedCode(final String fixedCode) {
            b.add(FhirPropertyNames.PROPERTY_FIXED_CODE, fixedCode);
            return this;
        }

        public Builder fixedDate(final String fixedDate) {
            b.add(FhirPropertyNames.PROPERTY_FIXED_DATE, fixedDate);
            return this;
        }

        public Builder fixedDateTime(final String fixedDateTime) {
            b.add(FhirPropertyNames.PROPERTY_FIXED_DATE_TIME, fixedDateTime);
            return this;
        }

        public Builder fixedDecimal(final Integer fixedDecimal) {
            b.add(FhirPropertyNames.PROPERTY_FIXED_DECIMAL, fixedDecimal);
            return this;
        }

        public Builder fixedId(final String fixedId) {
            b.add(FhirPropertyNames.PROPERTY_FIXED_ID, fixedId);
            return this;
        }

        public Builder fixedInstant(final String fixedInstant) {
            b.add(FhirPropertyNames.PROPERTY_FIXED_INSTANT, fixedInstant);
            return this;
        }

        public Builder fixedInteger(final Integer fixedInteger) {
            b.add(FhirPropertyNames.PROPERTY_FIXED_INTEGER, fixedInteger);
            return this;
        }

        public Builder fixedMarkdown(final String fixedMarkdown) {
            b.add(FhirPropertyNames.PROPERTY_FIXED_MARKDOWN, fixedMarkdown);
            return this;
        }

        public Builder fixedOid(final String fixedOid) {
            b.add(FhirPropertyNames.PROPERTY_FIXED_OID, fixedOid);
            return this;
        }

        public Builder fixedPositiveInt(final Integer fixedPositiveInt) {
            b.add(FhirPropertyNames.PROPERTY_FIXED_POSITIVE_INT, fixedPositiveInt);
            return this;
        }

        public Builder fixedString(final String fixedString) {
            b.add(FhirPropertyNames.PROPERTY_FIXED_STRING, fixedString);
            return this;
        }

        public Builder fixedTime(final String fixedTime) {
            b.add(FhirPropertyNames.PROPERTY_FIXED_TIME, fixedTime);
            return this;
        }

        public Builder fixedUnsignedInt(final Integer fixedUnsignedInt) {
            b.add(FhirPropertyNames.PROPERTY_FIXED_UNSIGNED_INT, fixedUnsignedInt);
            return this;
        }

        public Builder fixedUri(final String fixedUri) {
            b.add(FhirPropertyNames.PROPERTY_FIXED_URI, fixedUri);
            return this;
        }

        public Builder fixedUrl(final String fixedUrl) {
            b.add(FhirPropertyNames.PROPERTY_FIXED_URL, fixedUrl);
            return this;
        }

        public Builder fixedUuid(final String fixedUuid) {
            b.add(FhirPropertyNames.PROPERTY_FIXED_UUID, fixedUuid);
            return this;
        }

        public Builder fixedAddress(final Address fixedAddress) {
            b.add(FhirPropertyNames.PROPERTY_FIXED_ADDRESS, fixedAddress);
            return this;
        }

        public Builder fixedAge(final Age fixedAge) {
            b.add(FhirPropertyNames.PROPERTY_FIXED_AGE, fixedAge);
            return this;
        }

        public Builder fixedAnnotation(final Annotation fixedAnnotation) {
            b.add(FhirPropertyNames.PROPERTY_FIXED_ANNOTATION, fixedAnnotation);
            return this;
        }

        public Builder fixedAttachment(final Attachment fixedAttachment) {
            b.add(FhirPropertyNames.PROPERTY_FIXED_ATTACHMENT, fixedAttachment);
            return this;
        }

        public Builder fixedCodeableConcept(final CodeableConcept fixedCodeableConcept) {
            b.add(FhirPropertyNames.PROPERTY_FIXED_CODEABLE_CONCEPT, fixedCodeableConcept);
            return this;
        }

        public Builder fixedCoding(final Coding fixedCoding) {
            b.add(FhirPropertyNames.PROPERTY_FIXED_CODING, fixedCoding);
            return this;
        }

        public Builder fixedContactPoint(final ContactPoint fixedContactPoint) {
            b.add(FhirPropertyNames.PROPERTY_FIXED_CONTACT_POINT, fixedContactPoint);
            return this;
        }

        public Builder fixedCount(final Count fixedCount) {
            b.add(FhirPropertyNames.PROPERTY_FIXED_COUNT, fixedCount);
            return this;
        }

        public Builder fixedDistance(final Distance fixedDistance) {
            b.add(FhirPropertyNames.PROPERTY_FIXED_DISTANCE, fixedDistance);
            return this;
        }

        public Builder fixedDuration(final Duration fixedDuration) {
            b.add(FhirPropertyNames.PROPERTY_FIXED_DURATION, fixedDuration);
            return this;
        }

        public Builder fixedHumanName(final HumanName fixedHumanName) {
            b.add(FhirPropertyNames.PROPERTY_FIXED_HUMAN_NAME, fixedHumanName);
            return this;
        }

        public Builder fixedIdentifier(final Identifier fixedIdentifier) {
            b.add(FhirPropertyNames.PROPERTY_FIXED_IDENTIFIER, fixedIdentifier);
            return this;
        }

        public Builder fixedMoney(final Money fixedMoney) {
            b.add(FhirPropertyNames.PROPERTY_FIXED_MONEY, fixedMoney);
            return this;
        }

        public Builder fixedPeriod(final Period fixedPeriod) {
            b.add(FhirPropertyNames.PROPERTY_FIXED_PERIOD, fixedPeriod);
            return this;
        }

        public Builder fixedQuantity(final Quantity fixedQuantity) {
            b.add(FhirPropertyNames.PROPERTY_FIXED_QUANTITY, fixedQuantity);
            return this;
        }

        public Builder fixedRange(final Range fixedRange) {
            b.add(FhirPropertyNames.PROPERTY_FIXED_RANGE, fixedRange);
            return this;
        }

        public Builder fixedRatio(final Ratio fixedRatio) {
            b.add(FhirPropertyNames.PROPERTY_FIXED_RATIO, fixedRatio);
            return this;
        }

        public Builder fixedReference(final Reference fixedReference) {
            b.add(FhirPropertyNames.PROPERTY_FIXED_REFERENCE, fixedReference);
            return this;
        }

        public Builder fixedSampledData(final SampledData fixedSampledData) {
            b.add(FhirPropertyNames.PROPERTY_FIXED_SAMPLED_DATA, fixedSampledData);
            return this;
        }

        public Builder fixedSignature(final Signature fixedSignature) {
            b.add(FhirPropertyNames.PROPERTY_FIXED_SIGNATURE, fixedSignature);
            return this;
        }

        public Builder fixedTiming(final Timing fixedTiming) {
            b.add(FhirPropertyNames.PROPERTY_FIXED_TIMING, fixedTiming);
            return this;
        }

        public Builder fixedContactDetail(final ContactDetail fixedContactDetail) {
            b.add(FhirPropertyNames.PROPERTY_FIXED_CONTACT_DETAIL, fixedContactDetail);
            return this;
        }

        public Builder fixedContributor(final Contributor fixedContributor) {
            b.add(FhirPropertyNames.PROPERTY_FIXED_CONTRIBUTOR, fixedContributor);
            return this;
        }

        public Builder fixedDataRequirement(final DataRequirement fixedDataRequirement) {
            b.add(FhirPropertyNames.PROPERTY_FIXED_DATA_REQUIREMENT, fixedDataRequirement);
            return this;
        }

        public Builder fixedExpression(final Expression fixedExpression) {
            b.add(FhirPropertyNames.PROPERTY_FIXED_EXPRESSION, fixedExpression);
            return this;
        }

        public Builder fixedParameterDefinition(final ParameterDefinition fixedParameterDefinition) {
            b.add(FhirPropertyNames.PROPERTY_FIXED_PARAMETER_DEFINITION, fixedParameterDefinition);
            return this;
        }

        public Builder fixedRelatedArtifact(final RelatedArtifact fixedRelatedArtifact) {
            b.add(FhirPropertyNames.PROPERTY_FIXED_RELATED_ARTIFACT, fixedRelatedArtifact);
            return this;
        }

        public Builder fixedTriggerDefinition(final TriggerDefinition fixedTriggerDefinition) {
            b.add(FhirPropertyNames.PROPERTY_FIXED_TRIGGER_DEFINITION, fixedTriggerDefinition);
            return this;
        }

        public Builder fixedUsageContext(final UsageContext fixedUsageContext) {
            b.add(FhirPropertyNames.PROPERTY_FIXED_USAGE_CONTEXT, fixedUsageContext);
            return this;
        }

        public Builder fixedDosage(final Dosage fixedDosage) {
            b.add(FhirPropertyNames.PROPERTY_FIXED_DOSAGE, fixedDosage);
            return this;
        }

        public Builder fixedMeta(final Meta fixedMeta) {
            b.add(FhirPropertyNames.PROPERTY_FIXED_META, fixedMeta);
            return this;
        }

        public Builder patternBase64Binary(final String patternBase64Binary) {
            b.add(FhirPropertyNames.PROPERTY_PATTERN_BASE64_BINARY, patternBase64Binary);
            return this;
        }

        public Builder patternBoolean(final Boolean patternBoolean) {
            b.add(FhirPropertyNames.PROPERTY_PATTERN_BOOLEAN, patternBoolean);
            return this;
        }

        public Builder patternCanonical(final String patternCanonical) {
            b.add(FhirPropertyNames.PROPERTY_PATTERN_CANONICAL, patternCanonical);
            return this;
        }

        public Builder patternCode(final String patternCode) {
            b.add(FhirPropertyNames.PROPERTY_PATTERN_CODE, patternCode);
            return this;
        }

        public Builder patternDate(final String patternDate) {
            b.add(FhirPropertyNames.PROPERTY_PATTERN_DATE, patternDate);
            return this;
        }

        public Builder patternDateTime(final String patternDateTime) {
            b.add(FhirPropertyNames.PROPERTY_PATTERN_DATE_TIME, patternDateTime);
            return this;
        }

        public Builder patternDecimal(final Integer patternDecimal) {
            b.add(FhirPropertyNames.PROPERTY_PATTERN_DECIMAL, patternDecimal);
            return this;
        }

        public Builder patternId(final String patternId) {
            b.add(FhirPropertyNames.PROPERTY_PATTERN_ID, patternId);
            return this;
        }

        public Builder patternInstant(final String patternInstant) {
            b.add(FhirPropertyNames.PROPERTY_PATTERN_INSTANT, patternInstant);
            return this;
        }

        public Builder patternInteger(final Integer patternInteger) {
            b.add(FhirPropertyNames.PROPERTY_PATTERN_INTEGER, patternInteger);
            return this;
        }

        public Builder patternMarkdown(final String patternMarkdown) {
            b.add(FhirPropertyNames.PROPERTY_PATTERN_MARKDOWN, patternMarkdown);
            return this;
        }

        public Builder patternOid(final String patternOid) {
            b.add(FhirPropertyNames.PROPERTY_PATTERN_OID, patternOid);
            return this;
        }

        public Builder patternPositiveInt(final Integer patternPositiveInt) {
            b.add(FhirPropertyNames.PROPERTY_PATTERN_POSITIVE_INT, patternPositiveInt);
            return this;
        }

        public Builder patternString(final String patternString) {
            b.add(FhirPropertyNames.PROPERTY_PATTERN_STRING, patternString);
            return this;
        }

        public Builder patternTime(final String patternTime) {
            b.add(FhirPropertyNames.PROPERTY_PATTERN_TIME, patternTime);
            return this;
        }

        public Builder patternUnsignedInt(final Integer patternUnsignedInt) {
            b.add(FhirPropertyNames.PROPERTY_PATTERN_UNSIGNED_INT, patternUnsignedInt);
            return this;
        }

        public Builder patternUri(final String patternUri) {
            b.add(FhirPropertyNames.PROPERTY_PATTERN_URI, patternUri);
            return this;
        }

        public Builder patternUrl(final String patternUrl) {
            b.add(FhirPropertyNames.PROPERTY_PATTERN_URL, patternUrl);
            return this;
        }

        public Builder patternUuid(final String patternUuid) {
            b.add(FhirPropertyNames.PROPERTY_PATTERN_UUID, patternUuid);
            return this;
        }

        public Builder patternAddress(final Address patternAddress) {
            b.add(FhirPropertyNames.PROPERTY_PATTERN_ADDRESS, patternAddress);
            return this;
        }

        public Builder patternAge(final Age patternAge) {
            b.add(FhirPropertyNames.PROPERTY_PATTERN_AGE, patternAge);
            return this;
        }

        public Builder patternAnnotation(final Annotation patternAnnotation) {
            b.add(FhirPropertyNames.PROPERTY_PATTERN_ANNOTATION, patternAnnotation);
            return this;
        }

        public Builder patternAttachment(final Attachment patternAttachment) {
            b.add(FhirPropertyNames.PROPERTY_PATTERN_ATTACHMENT, patternAttachment);
            return this;
        }

        public Builder patternCodeableConcept(final CodeableConcept patternCodeableConcept) {
            b.add(FhirPropertyNames.PROPERTY_PATTERN_CODEABLE_CONCEPT, patternCodeableConcept);
            return this;
        }

        public Builder patternCoding(final Coding patternCoding) {
            b.add(FhirPropertyNames.PROPERTY_PATTERN_CODING, patternCoding);
            return this;
        }

        public Builder patternContactPoint(final ContactPoint patternContactPoint) {
            b.add(FhirPropertyNames.PROPERTY_PATTERN_CONTACT_POINT, patternContactPoint);
            return this;
        }

        public Builder patternCount(final Count patternCount) {
            b.add(FhirPropertyNames.PROPERTY_PATTERN_COUNT, patternCount);
            return this;
        }

        public Builder patternDistance(final Distance patternDistance) {
            b.add(FhirPropertyNames.PROPERTY_PATTERN_DISTANCE, patternDistance);
            return this;
        }

        public Builder patternDuration(final Duration patternDuration) {
            b.add(FhirPropertyNames.PROPERTY_PATTERN_DURATION, patternDuration);
            return this;
        }

        public Builder patternHumanName(final HumanName patternHumanName) {
            b.add(FhirPropertyNames.PROPERTY_PATTERN_HUMAN_NAME, patternHumanName);
            return this;
        }

        public Builder patternIdentifier(final Identifier patternIdentifier) {
            b.add(FhirPropertyNames.PROPERTY_PATTERN_IDENTIFIER, patternIdentifier);
            return this;
        }

        public Builder patternMoney(final Money patternMoney) {
            b.add(FhirPropertyNames.PROPERTY_PATTERN_MONEY, patternMoney);
            return this;
        }

        public Builder patternPeriod(final Period patternPeriod) {
            b.add(FhirPropertyNames.PROPERTY_PATTERN_PERIOD, patternPeriod);
            return this;
        }

        public Builder patternQuantity(final Quantity patternQuantity) {
            b.add(FhirPropertyNames.PROPERTY_PATTERN_QUANTITY, patternQuantity);
            return this;
        }

        public Builder patternRange(final Range patternRange) {
            b.add(FhirPropertyNames.PROPERTY_PATTERN_RANGE, patternRange);
            return this;
        }

        public Builder patternRatio(final Ratio patternRatio) {
            b.add(FhirPropertyNames.PROPERTY_PATTERN_RATIO, patternRatio);
            return this;
        }

        public Builder patternReference(final Reference patternReference) {
            b.add(FhirPropertyNames.PROPERTY_PATTERN_REFERENCE, patternReference);
            return this;
        }

        public Builder patternSampledData(final SampledData patternSampledData) {
            b.add(FhirPropertyNames.PROPERTY_PATTERN_SAMPLED_DATA, patternSampledData);
            return this;
        }

        public Builder patternSignature(final Signature patternSignature) {
            b.add(FhirPropertyNames.PROPERTY_PATTERN_SIGNATURE, patternSignature);
            return this;
        }

        public Builder patternTiming(final Timing patternTiming) {
            b.add(FhirPropertyNames.PROPERTY_PATTERN_TIMING, patternTiming);
            return this;
        }

        public Builder patternContactDetail(final ContactDetail patternContactDetail) {
            b.add(FhirPropertyNames.PROPERTY_PATTERN_CONTACT_DETAIL, patternContactDetail);
            return this;
        }

        public Builder patternContributor(final Contributor patternContributor) {
            b.add(FhirPropertyNames.PROPERTY_PATTERN_CONTRIBUTOR, patternContributor);
            return this;
        }

        public Builder patternDataRequirement(final DataRequirement patternDataRequirement) {
            b.add(FhirPropertyNames.PROPERTY_PATTERN_DATA_REQUIREMENT, patternDataRequirement);
            return this;
        }

        public Builder patternExpression(final Expression patternExpression) {
            b.add(FhirPropertyNames.PROPERTY_PATTERN_EXPRESSION, patternExpression);
            return this;
        }

        public Builder patternParameterDefinition(final ParameterDefinition patternParameterDefinition) {
            b.add(FhirPropertyNames.PROPERTY_PATTERN_PARAMETER_DEFINITION, patternParameterDefinition);
            return this;
        }

        public Builder patternRelatedArtifact(final RelatedArtifact patternRelatedArtifact) {
            b.add(FhirPropertyNames.PROPERTY_PATTERN_RELATED_ARTIFACT, patternRelatedArtifact);
            return this;
        }

        public Builder patternTriggerDefinition(final TriggerDefinition patternTriggerDefinition) {
            b.add(FhirPropertyNames.PROPERTY_PATTERN_TRIGGER_DEFINITION, patternTriggerDefinition);
            return this;
        }

        public Builder patternUsageContext(final UsageContext patternUsageContext) {
            b.add(FhirPropertyNames.PROPERTY_PATTERN_USAGE_CONTEXT, patternUsageContext);
            return this;
        }

        public Builder patternDosage(final Dosage patternDosage) {
            b.add(FhirPropertyNames.PROPERTY_PATTERN_DOSAGE, patternDosage);
            return this;
        }

        public Builder patternMeta(final Meta patternMeta) {
            b.add(FhirPropertyNames.PROPERTY_PATTERN_META, patternMeta);
            return this;
        }

        public Builder example(final java.util.List<ElementDefinitionExample> example) {
            b.add(FhirPropertyNames.PROPERTY_EXAMPLE, FhirObject.toArray(example));
            return this;
        }

        public Builder minValueDate(final String minValueDate) {
            b.add(FhirPropertyNames.PROPERTY_MIN_VALUE_DATE, minValueDate);
            return this;
        }

        public Builder minValueDateTime(final String minValueDateTime) {
            b.add(FhirPropertyNames.PROPERTY_MIN_VALUE_DATE_TIME, minValueDateTime);
            return this;
        }

        public Builder minValueInstant(final String minValueInstant) {
            b.add(FhirPropertyNames.PROPERTY_MIN_VALUE_INSTANT, minValueInstant);
            return this;
        }

        public Builder minValueTime(final String minValueTime) {
            b.add(FhirPropertyNames.PROPERTY_MIN_VALUE_TIME, minValueTime);
            return this;
        }

        public Builder minValueDecimal(final Integer minValueDecimal) {
            b.add(FhirPropertyNames.PROPERTY_MIN_VALUE_DECIMAL, minValueDecimal);
            return this;
        }

        public Builder minValueInteger(final Integer minValueInteger) {
            b.add(FhirPropertyNames.PROPERTY_MIN_VALUE_INTEGER, minValueInteger);
            return this;
        }

        public Builder minValuePositiveInt(final Integer minValuePositiveInt) {
            b.add(FhirPropertyNames.PROPERTY_MIN_VALUE_POSITIVE_INT, minValuePositiveInt);
            return this;
        }

        public Builder minValueUnsignedInt(final Integer minValueUnsignedInt) {
            b.add(FhirPropertyNames.PROPERTY_MIN_VALUE_UNSIGNED_INT, minValueUnsignedInt);
            return this;
        }

        public Builder minValueQuantity(final Quantity minValueQuantity) {
            b.add(FhirPropertyNames.PROPERTY_MIN_VALUE_QUANTITY, minValueQuantity);
            return this;
        }

        public Builder maxValueDate(final String maxValueDate) {
            b.add(FhirPropertyNames.PROPERTY_MAX_VALUE_DATE, maxValueDate);
            return this;
        }

        public Builder maxValueDateTime(final String maxValueDateTime) {
            b.add(FhirPropertyNames.PROPERTY_MAX_VALUE_DATE_TIME, maxValueDateTime);
            return this;
        }

        public Builder maxValueInstant(final String maxValueInstant) {
            b.add(FhirPropertyNames.PROPERTY_MAX_VALUE_INSTANT, maxValueInstant);
            return this;
        }

        public Builder maxValueTime(final String maxValueTime) {
            b.add(FhirPropertyNames.PROPERTY_MAX_VALUE_TIME, maxValueTime);
            return this;
        }

        public Builder maxValueDecimal(final Integer maxValueDecimal) {
            b.add(FhirPropertyNames.PROPERTY_MAX_VALUE_DECIMAL, maxValueDecimal);
            return this;
        }

        public Builder maxValueInteger(final Integer maxValueInteger) {
            b.add(FhirPropertyNames.PROPERTY_MAX_VALUE_INTEGER, maxValueInteger);
            return this;
        }

        public Builder maxValuePositiveInt(final Integer maxValuePositiveInt) {
            b.add(FhirPropertyNames.PROPERTY_MAX_VALUE_POSITIVE_INT, maxValuePositiveInt);
            return this;
        }

        public Builder maxValueUnsignedInt(final Integer maxValueUnsignedInt) {
            b.add(FhirPropertyNames.PROPERTY_MAX_VALUE_UNSIGNED_INT, maxValueUnsignedInt);
            return this;
        }

        public Builder maxValueQuantity(final Quantity maxValueQuantity) {
            b.add(FhirPropertyNames.PROPERTY_MAX_VALUE_QUANTITY, maxValueQuantity);
            return this;
        }

        public Builder maxLength(final Integer maxLength) {
            b.add(FhirPropertyNames.PROPERTY_MAX_LENGTH, maxLength);
            return this;
        }

        public Builder condition(final java.util.List<String> condition) {
            b.add(FhirPropertyNames.PROPERTY_CONDITION, FhirObject.toStringArray(condition));
            return this;
        }

        public Builder constraint(final java.util.List<ElementDefinitionConstraint> constraint) {
            b.add(FhirPropertyNames.PROPERTY_CONSTRAINT, FhirObject.toArray(constraint));
            return this;
        }

        public Builder mustSupport(final Boolean mustSupport) {
            b.add(FhirPropertyNames.PROPERTY_MUST_SUPPORT, mustSupport);
            return this;
        }

        public Builder isModifier(final Boolean isModifier) {
            b.add(FhirPropertyNames.PROPERTY_IS_MODIFIER, isModifier);
            return this;
        }

        public Builder isModifierReason(final String isModifierReason) {
            b.add(FhirPropertyNames.PROPERTY_IS_MODIFIER_REASON, isModifierReason);
            return this;
        }

        public Builder isSummary(final Boolean isSummary) {
            b.add(FhirPropertyNames.PROPERTY_IS_SUMMARY, isSummary);
            return this;
        }

        public Builder binding(final ElementDefinitionBinding binding) {
            b.add(FhirPropertyNames.PROPERTY_BINDING, binding);
            return this;
        }

        public Builder mapping(final java.util.List<ElementDefinitionMapping> mapping) {
            b.add(FhirPropertyNames.PROPERTY_MAPPING, FhirObject.toArray(mapping));
            return this;
        }

        public ElementDefinition build() {
            return new ElementDefinition(b.build());
        }
    }

    /**
     * Captures constraints on each element within the resource, profile, or
     * extension.
     */
    public static class ElementDefinitionBase extends FhirObject {
        public static final String RESOURCE_TYPE = "ElementDefinitionBase";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public ElementDefinitionBase(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * The Path that identifies the base element - this matches the
         * ElementDefinition.path for that element. Across FHIR, there is only
         * one base definition of any element - that is, an element definition on
         * a [[[StructureDefinition]]] without a StructureDefinition.base.
         */
        public String path() {
            return getString(FhirPropertyNames.PROPERTY_PATH);
        }

        /**
         * Minimum cardinality of the base element identified by the path.
         */
        public Integer min() {
            return data.getInt(FhirPropertyNames.PROPERTY_MIN);
        }

        /**
         * Maximum cardinality of the base element identified by the path.
         */
        public String max() {
            return getString(FhirPropertyNames.PROPERTY_MAX);
        }

        public static final class Builder extends FhirObject.Builder<ElementDefinitionBase, ElementDefinitionBase.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder path(final String path) {
                b.add(FhirPropertyNames.PROPERTY_PATH, path);
                return this;
            }

            public Builder min(final Integer min) {
                b.add(FhirPropertyNames.PROPERTY_MIN, min);
                return this;
            }

            public Builder max(final String max) {
                b.add(FhirPropertyNames.PROPERTY_MAX, max);
                return this;
            }

            public ElementDefinitionBase build() {
                return new ElementDefinitionBase(b.build());
            }
        }
    }

    /**
     * Captures constraints on each element within the resource, profile, or
     * extension.
     */
    public static class ElementDefinitionBinding extends FhirObject {
        public static final String RESOURCE_TYPE = "ElementDefinitionBinding";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public ElementDefinitionBinding(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Indicates the degree of conformance expectations associated with this
         * binding - that is, the degree to which the provided value set must be
         * adhered to in the instances.
         */
        public String strength() {
            return getString(FhirPropertyNames.PROPERTY_STRENGTH);
        }

        /**
         * Describes the intended use of this particular set of codes.
         */
        public String description() {
            return getString(FhirPropertyNames.PROPERTY_DESCRIPTION);
        }

        /**
         * Refers to the value set that identifies the set of codes the binding
         * refers to.
         */
        public String valueSet() {
            return getString(FhirPropertyNames.PROPERTY_VALUE_SET);
        }

        public static final class Builder extends FhirObject.Builder<ElementDefinitionBinding, ElementDefinitionBinding.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder strength(final String strength) {
                b.add(FhirPropertyNames.PROPERTY_STRENGTH, strength);
                return this;
            }

            public Builder description(final String description) {
                b.add(FhirPropertyNames.PROPERTY_DESCRIPTION, description);
                return this;
            }

            public Builder valueSet(final String valueSet) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_SET, valueSet);
                return this;
            }

            public ElementDefinitionBinding build() {
                return new ElementDefinitionBinding(b.build());
            }
        }
    }

    /**
     * Captures constraints on each element within the resource, profile, or
     * extension.
     */
    public static class ElementDefinitionConstraint extends FhirObject {
        public static final String RESOURCE_TYPE = "ElementDefinitionConstraint";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public ElementDefinitionConstraint(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Allows identification of which elements have their cardinalities
         * impacted by the constraint.  Will not be referenced for constraints
         * that do not affect cardinality.
         */
        public String key() {
            return getString(FhirPropertyNames.PROPERTY_KEY);
        }

        /**
         * Description of why this constraint is necessary or appropriate.
         */
        public String requirements() {
            return getString(FhirPropertyNames.PROPERTY_REQUIREMENTS);
        }

        /**
         * Identifies the impact constraint violation has on the conformance of
         * the instance.
         */
        public String severity() {
            return getString(FhirPropertyNames.PROPERTY_SEVERITY);
        }

        /**
         * Text that can be used to describe the constraint in messages
         * identifying that the constraint has been violated.
         */
        public String human() {
            return getString(FhirPropertyNames.PROPERTY_HUMAN);
        }

        /**
         * A [FHIRPath](fhirpath.html) expression of constraint that can be
         * executed to see if this constraint is met.
         */
        public String expression() {
            return getString(FhirPropertyNames.PROPERTY_EXPRESSION);
        }

        /**
         * An XPath expression of constraint that can be executed to see if this
         * constraint is met.
         */
        public String xpath() {
            return getString(FhirPropertyNames.PROPERTY_XPATH);
        }

        /**
         * A reference to the original source of the constraint, for traceability
         * purposes.
         */
        public String source() {
            return getString(FhirPropertyNames.PROPERTY_SOURCE);
        }

        public static final class Builder extends FhirObject.Builder<ElementDefinitionConstraint, ElementDefinitionConstraint.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder key(final String key) {
                b.add(FhirPropertyNames.PROPERTY_KEY, key);
                return this;
            }

            public Builder requirements(final String requirements) {
                b.add(FhirPropertyNames.PROPERTY_REQUIREMENTS, requirements);
                return this;
            }

            public Builder severity(final String severity) {
                b.add(FhirPropertyNames.PROPERTY_SEVERITY, severity);
                return this;
            }

            public Builder human(final String human) {
                b.add(FhirPropertyNames.PROPERTY_HUMAN, human);
                return this;
            }

            public Builder expression(final String expression) {
                b.add(FhirPropertyNames.PROPERTY_EXPRESSION, expression);
                return this;
            }

            public Builder xpath(final String xpath) {
                b.add(FhirPropertyNames.PROPERTY_XPATH, xpath);
                return this;
            }

            public Builder source(final String source) {
                b.add(FhirPropertyNames.PROPERTY_SOURCE, source);
                return this;
            }

            public ElementDefinitionConstraint build() {
                return new ElementDefinitionConstraint(b.build());
            }
        }
    }

    /**
     * Captures constraints on each element within the resource, profile, or
     * extension.
     */
    public static class ElementDefinitionDiscriminator extends FhirObject {
        public static final String RESOURCE_TYPE = "ElementDefinitionDiscriminator";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public ElementDefinitionDiscriminator(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * How the element value is interpreted when discrimination is evaluated.
         */
        public String type() {
            return getString(FhirPropertyNames.PROPERTY_TYPE);
        }

        /**
         * A FHIRPath expression, using [the simple subset of
         * FHIRPath](fhirpath.html#simple), that is used to identify the element
         * on which discrimination is based.
         */
        public String path() {
            return getString(FhirPropertyNames.PROPERTY_PATH);
        }

        public static final class Builder extends FhirObject.Builder<ElementDefinitionDiscriminator, ElementDefinitionDiscriminator.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder type(final String type) {
                b.add(FhirPropertyNames.PROPERTY_TYPE, type);
                return this;
            }

            public Builder path(final String path) {
                b.add(FhirPropertyNames.PROPERTY_PATH, path);
                return this;
            }

            public ElementDefinitionDiscriminator build() {
                return new ElementDefinitionDiscriminator(b.build());
            }
        }
    }

    /**
     * Captures constraints on each element within the resource, profile, or
     * extension.
     */
    public static class ElementDefinitionExample extends FhirObject {
        public static final String RESOURCE_TYPE = "ElementDefinitionExample";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public ElementDefinitionExample(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Describes the purpose of this example amoung the set of examples.
         */
        public String label() {
            return getString(FhirPropertyNames.PROPERTY_LABEL);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public String valueBase64Binary() {
            return getString(FhirPropertyNames.PROPERTY_VALUE_BASE64_BINARY);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Boolean valueBoolean() {
            return data.getBoolean(FhirPropertyNames.PROPERTY_VALUE_BOOLEAN);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public String valueCanonical() {
            return getString(FhirPropertyNames.PROPERTY_VALUE_CANONICAL);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public String valueCode() {
            return getString(FhirPropertyNames.PROPERTY_VALUE_CODE);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public String valueDate() {
            return getString(FhirPropertyNames.PROPERTY_VALUE_DATE);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public String valueDateTime() {
            return getString(FhirPropertyNames.PROPERTY_VALUE_DATE_TIME);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Integer valueDecimal() {
            return data.getInt(FhirPropertyNames.PROPERTY_VALUE_DECIMAL);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public String valueId() {
            return getString(FhirPropertyNames.PROPERTY_VALUE_ID);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public String valueInstant() {
            return getString(FhirPropertyNames.PROPERTY_VALUE_INSTANT);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Integer valueInteger() {
            return data.getInt(FhirPropertyNames.PROPERTY_VALUE_INTEGER);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public String valueMarkdown() {
            return getString(FhirPropertyNames.PROPERTY_VALUE_MARKDOWN);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public String valueOid() {
            return getString(FhirPropertyNames.PROPERTY_VALUE_OID);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Integer valuePositiveInt() {
            return data.getInt(FhirPropertyNames.PROPERTY_VALUE_POSITIVE_INT);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public String valueString() {
            return getString(FhirPropertyNames.PROPERTY_VALUE_STRING);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public String valueTime() {
            return getString(FhirPropertyNames.PROPERTY_VALUE_TIME);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Integer valueUnsignedInt() {
            return data.getInt(FhirPropertyNames.PROPERTY_VALUE_UNSIGNED_INT);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public String valueUri() {
            return getString(FhirPropertyNames.PROPERTY_VALUE_URI);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public String valueUrl() {
            return getString(FhirPropertyNames.PROPERTY_VALUE_URL);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public String valueUuid() {
            return getString(FhirPropertyNames.PROPERTY_VALUE_UUID);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Address valueAddress() {
            return getObject(Address.class, FhirPropertyNames.PROPERTY_VALUE_ADDRESS);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Age valueAge() {
            return getObject(Age.class, FhirPropertyNames.PROPERTY_VALUE_AGE);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Annotation valueAnnotation() {
            return getObject(Annotation.class, FhirPropertyNames.PROPERTY_VALUE_ANNOTATION);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Attachment valueAttachment() {
            return getObject(Attachment.class, FhirPropertyNames.PROPERTY_VALUE_ATTACHMENT);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public CodeableConcept valueCodeableConcept() {
            return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_VALUE_CODEABLE_CONCEPT);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Coding valueCoding() {
            return getObject(Coding.class, FhirPropertyNames.PROPERTY_VALUE_CODING);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public ContactPoint valueContactPoint() {
            return getObject(ContactPoint.class, FhirPropertyNames.PROPERTY_VALUE_CONTACT_POINT);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Count valueCount() {
            return getObject(Count.class, FhirPropertyNames.PROPERTY_VALUE_COUNT);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Distance valueDistance() {
            return getObject(Distance.class, FhirPropertyNames.PROPERTY_VALUE_DISTANCE);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Duration valueDuration() {
            return getObject(Duration.class, FhirPropertyNames.PROPERTY_VALUE_DURATION);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public HumanName valueHumanName() {
            return getObject(HumanName.class, FhirPropertyNames.PROPERTY_VALUE_HUMAN_NAME);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Identifier valueIdentifier() {
            return getObject(Identifier.class, FhirPropertyNames.PROPERTY_VALUE_IDENTIFIER);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Money valueMoney() {
            return getObject(Money.class, FhirPropertyNames.PROPERTY_VALUE_MONEY);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Period valuePeriod() {
            return getObject(Period.class, FhirPropertyNames.PROPERTY_VALUE_PERIOD);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Quantity valueQuantity() {
            return getObject(Quantity.class, FhirPropertyNames.PROPERTY_VALUE_QUANTITY);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Range valueRange() {
            return getObject(Range.class, FhirPropertyNames.PROPERTY_VALUE_RANGE);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Ratio valueRatio() {
            return getObject(Ratio.class, FhirPropertyNames.PROPERTY_VALUE_RATIO);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Reference valueReference() {
            return getObject(Reference.class, FhirPropertyNames.PROPERTY_VALUE_REFERENCE);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public SampledData valueSampledData() {
            return getObject(SampledData.class, FhirPropertyNames.PROPERTY_VALUE_SAMPLED_DATA);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Signature valueSignature() {
            return getObject(Signature.class, FhirPropertyNames.PROPERTY_VALUE_SIGNATURE);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Timing valueTiming() {
            return getObject(Timing.class, FhirPropertyNames.PROPERTY_VALUE_TIMING);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public ContactDetail valueContactDetail() {
            return getObject(ContactDetail.class, FhirPropertyNames.PROPERTY_VALUE_CONTACT_DETAIL);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Contributor valueContributor() {
            return getObject(Contributor.class, FhirPropertyNames.PROPERTY_VALUE_CONTRIBUTOR);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public DataRequirement valueDataRequirement() {
            return getObject(DataRequirement.class, FhirPropertyNames.PROPERTY_VALUE_DATA_REQUIREMENT);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Expression valueExpression() {
            return getObject(Expression.class, FhirPropertyNames.PROPERTY_VALUE_EXPRESSION);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public ParameterDefinition valueParameterDefinition() {
            return getObject(ParameterDefinition.class, FhirPropertyNames.PROPERTY_VALUE_PARAMETER_DEFINITION);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public RelatedArtifact valueRelatedArtifact() {
            return getObject(RelatedArtifact.class, FhirPropertyNames.PROPERTY_VALUE_RELATED_ARTIFACT);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public TriggerDefinition valueTriggerDefinition() {
            return getObject(TriggerDefinition.class, FhirPropertyNames.PROPERTY_VALUE_TRIGGER_DEFINITION);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public UsageContext valueUsageContext() {
            return getObject(UsageContext.class, FhirPropertyNames.PROPERTY_VALUE_USAGE_CONTEXT);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Dosage valueDosage() {
            return getObject(Dosage.class, FhirPropertyNames.PROPERTY_VALUE_DOSAGE);
        }

        /**
         * The actual value for the element, which must be one of the types
         * allowed for this element.
         */
        public Meta valueMeta() {
            return getObject(Meta.class, FhirPropertyNames.PROPERTY_VALUE_META);
        }

        public static final class Builder extends FhirObject.Builder<ElementDefinitionExample, ElementDefinitionExample.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder label(final String label) {
                b.add(FhirPropertyNames.PROPERTY_LABEL, label);
                return this;
            }

            public Builder valueBase64Binary(final String valueBase64Binary) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_BASE64_BINARY, valueBase64Binary);
                return this;
            }

            public Builder valueBoolean(final Boolean valueBoolean) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_BOOLEAN, valueBoolean);
                return this;
            }

            public Builder valueCanonical(final String valueCanonical) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_CANONICAL, valueCanonical);
                return this;
            }

            public Builder valueCode(final String valueCode) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_CODE, valueCode);
                return this;
            }

            public Builder valueDate(final String valueDate) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_DATE, valueDate);
                return this;
            }

            public Builder valueDateTime(final String valueDateTime) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_DATE_TIME, valueDateTime);
                return this;
            }

            public Builder valueDecimal(final Integer valueDecimal) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_DECIMAL, valueDecimal);
                return this;
            }

            public Builder valueId(final String valueId) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_ID, valueId);
                return this;
            }

            public Builder valueInstant(final String valueInstant) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_INSTANT, valueInstant);
                return this;
            }

            public Builder valueInteger(final Integer valueInteger) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_INTEGER, valueInteger);
                return this;
            }

            public Builder valueMarkdown(final String valueMarkdown) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_MARKDOWN, valueMarkdown);
                return this;
            }

            public Builder valueOid(final String valueOid) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_OID, valueOid);
                return this;
            }

            public Builder valuePositiveInt(final Integer valuePositiveInt) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_POSITIVE_INT, valuePositiveInt);
                return this;
            }

            public Builder valueString(final String valueString) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_STRING, valueString);
                return this;
            }

            public Builder valueTime(final String valueTime) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_TIME, valueTime);
                return this;
            }

            public Builder valueUnsignedInt(final Integer valueUnsignedInt) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_UNSIGNED_INT, valueUnsignedInt);
                return this;
            }

            public Builder valueUri(final String valueUri) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_URI, valueUri);
                return this;
            }

            public Builder valueUrl(final String valueUrl) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_URL, valueUrl);
                return this;
            }

            public Builder valueUuid(final String valueUuid) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_UUID, valueUuid);
                return this;
            }

            public Builder valueAddress(final Address valueAddress) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_ADDRESS, valueAddress);
                return this;
            }

            public Builder valueAge(final Age valueAge) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_AGE, valueAge);
                return this;
            }

            public Builder valueAnnotation(final Annotation valueAnnotation) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_ANNOTATION, valueAnnotation);
                return this;
            }

            public Builder valueAttachment(final Attachment valueAttachment) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_ATTACHMENT, valueAttachment);
                return this;
            }

            public Builder valueCodeableConcept(final CodeableConcept valueCodeableConcept) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_CODEABLE_CONCEPT, valueCodeableConcept);
                return this;
            }

            public Builder valueCoding(final Coding valueCoding) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_CODING, valueCoding);
                return this;
            }

            public Builder valueContactPoint(final ContactPoint valueContactPoint) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_CONTACT_POINT, valueContactPoint);
                return this;
            }

            public Builder valueCount(final Count valueCount) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_COUNT, valueCount);
                return this;
            }

            public Builder valueDistance(final Distance valueDistance) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_DISTANCE, valueDistance);
                return this;
            }

            public Builder valueDuration(final Duration valueDuration) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_DURATION, valueDuration);
                return this;
            }

            public Builder valueHumanName(final HumanName valueHumanName) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_HUMAN_NAME, valueHumanName);
                return this;
            }

            public Builder valueIdentifier(final Identifier valueIdentifier) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_IDENTIFIER, valueIdentifier);
                return this;
            }

            public Builder valueMoney(final Money valueMoney) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_MONEY, valueMoney);
                return this;
            }

            public Builder valuePeriod(final Period valuePeriod) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_PERIOD, valuePeriod);
                return this;
            }

            public Builder valueQuantity(final Quantity valueQuantity) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_QUANTITY, valueQuantity);
                return this;
            }

            public Builder valueRange(final Range valueRange) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_RANGE, valueRange);
                return this;
            }

            public Builder valueRatio(final Ratio valueRatio) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_RATIO, valueRatio);
                return this;
            }

            public Builder valueReference(final Reference valueReference) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_REFERENCE, valueReference);
                return this;
            }

            public Builder valueSampledData(final SampledData valueSampledData) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_SAMPLED_DATA, valueSampledData);
                return this;
            }

            public Builder valueSignature(final Signature valueSignature) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_SIGNATURE, valueSignature);
                return this;
            }

            public Builder valueTiming(final Timing valueTiming) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_TIMING, valueTiming);
                return this;
            }

            public Builder valueContactDetail(final ContactDetail valueContactDetail) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_CONTACT_DETAIL, valueContactDetail);
                return this;
            }

            public Builder valueContributor(final Contributor valueContributor) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_CONTRIBUTOR, valueContributor);
                return this;
            }

            public Builder valueDataRequirement(final DataRequirement valueDataRequirement) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_DATA_REQUIREMENT, valueDataRequirement);
                return this;
            }

            public Builder valueExpression(final Expression valueExpression) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_EXPRESSION, valueExpression);
                return this;
            }

            public Builder valueParameterDefinition(final ParameterDefinition valueParameterDefinition) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_PARAMETER_DEFINITION, valueParameterDefinition);
                return this;
            }

            public Builder valueRelatedArtifact(final RelatedArtifact valueRelatedArtifact) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_RELATED_ARTIFACT, valueRelatedArtifact);
                return this;
            }

            public Builder valueTriggerDefinition(final TriggerDefinition valueTriggerDefinition) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_TRIGGER_DEFINITION, valueTriggerDefinition);
                return this;
            }

            public Builder valueUsageContext(final UsageContext valueUsageContext) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_USAGE_CONTEXT, valueUsageContext);
                return this;
            }

            public Builder valueDosage(final Dosage valueDosage) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_DOSAGE, valueDosage);
                return this;
            }

            public Builder valueMeta(final Meta valueMeta) {
                b.add(FhirPropertyNames.PROPERTY_VALUE_META, valueMeta);
                return this;
            }

            public ElementDefinitionExample build() {
                return new ElementDefinitionExample(b.build());
            }
        }
    }

    /**
     * Captures constraints on each element within the resource, profile, or
     * extension.
     */
    public static class ElementDefinitionMapping extends FhirObject {
        public static final String RESOURCE_TYPE = "ElementDefinitionMapping";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public ElementDefinitionMapping(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * An internal reference to the definition of a mapping.
         */
        public String identity() {
            return getString(FhirPropertyNames.PROPERTY_IDENTITY);
        }

        /**
         * Identifies the computable language in which mapping.map is expressed.
         */
        public String language() {
            return getString(FhirPropertyNames.PROPERTY_LANGUAGE);
        }

        /**
         * Expresses what part of the target specification corresponds to this
         * element.
         */
        public String map() {
            return getString(FhirPropertyNames.PROPERTY_MAP);
        }

        /**
         * Comments that provide information about the mapping or its use.
         */
        public String comment() {
            return getString(FhirPropertyNames.PROPERTY_COMMENT);
        }

        public static final class Builder extends FhirObject.Builder<ElementDefinitionMapping, ElementDefinitionMapping.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder identity(final String identity) {
                b.add(FhirPropertyNames.PROPERTY_IDENTITY, identity);
                return this;
            }

            public Builder language(final String language) {
                b.add(FhirPropertyNames.PROPERTY_LANGUAGE, language);
                return this;
            }

            public Builder map(final String map) {
                b.add(FhirPropertyNames.PROPERTY_MAP, map);
                return this;
            }

            public Builder comment(final String comment) {
                b.add(FhirPropertyNames.PROPERTY_COMMENT, comment);
                return this;
            }

            public ElementDefinitionMapping build() {
                return new ElementDefinitionMapping(b.build());
            }
        }
    }

    /**
     * Captures constraints on each element within the resource, profile, or
     * extension.
     */
    public static class ElementDefinitionSlicing extends FhirObject {
        public static final String RESOURCE_TYPE = "ElementDefinitionSlicing";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public ElementDefinitionSlicing(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Designates which child elements are used to discriminate between the
         * slices when processing an instance. If one or more discriminators are
         * provided, the value of the child elements in the instance data SHALL
         * completely distinguish which slice the element in the resource matches
         * based on the allowed values for those elements in each of the slices.
         */
        public java.util.List<ElementDefinitionDiscriminator> discriminator() {
            return getList(ElementDefinitionDiscriminator.class, FhirPropertyNames.PROPERTY_DISCRIMINATOR);
        }

        /**
         * A human-readable text description of how the slicing works. If there
         * is no discriminator, this is required to be present to provide
         * whatever information is possible about how the slices can be
         * differentiated.
         */
        public String description() {
            return getString(FhirPropertyNames.PROPERTY_DESCRIPTION);
        }

        /**
         * If the matching elements have to occur in the same order as defined in
         * the profile.
         */
        public Boolean ordered() {
            return data.getBoolean(FhirPropertyNames.PROPERTY_ORDERED);
        }

        /**
         * Whether additional slices are allowed or not. When the slices are
         * ordered, profile authors can also say that additional slices are only
         * allowed at the end.
         */
        public String rules() {
            return getString(FhirPropertyNames.PROPERTY_RULES);
        }

        public static final class Builder extends FhirObject.Builder<ElementDefinitionSlicing, ElementDefinitionSlicing.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder discriminator(final java.util.List<ElementDefinitionDiscriminator> discriminator) {
                b.add(FhirPropertyNames.PROPERTY_DISCRIMINATOR, FhirObject.toArray(discriminator));
                return this;
            }

            public Builder description(final String description) {
                b.add(FhirPropertyNames.PROPERTY_DESCRIPTION, description);
                return this;
            }

            public Builder ordered(final Boolean ordered) {
                b.add(FhirPropertyNames.PROPERTY_ORDERED, ordered);
                return this;
            }

            public Builder rules(final String rules) {
                b.add(FhirPropertyNames.PROPERTY_RULES, rules);
                return this;
            }

            public ElementDefinitionSlicing build() {
                return new ElementDefinitionSlicing(b.build());
            }
        }
    }

    /**
     * Captures constraints on each element within the resource, profile, or
     * extension.
     */
    public static class ElementDefinitionType extends FhirObject {
        public static final String RESOURCE_TYPE = "ElementDefinitionType";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public ElementDefinitionType(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * URL of Data type or Resource that is a(or the) type used for this
         * element. References are URLs that are relative to
         * http://hl7.org/fhir/StructureDefinition e.g. &quot;string&quot; is a reference
         * to http://hl7.org/fhir/StructureDefinition/string. Absolute URLs are
         * only allowed in logical models.
         */
        public java.net.URI code() {
            return getUri(FhirPropertyNames.PROPERTY_CODE);
        }

        /**
         * Identifies a profile structure or implementation Guide that applies to
         * the datatype this element refers to. If any profiles are specified,
         * then the content must conform to at least one of them. The URL can be
         * a local reference - to a contained StructureDefinition, or a reference
         * to another StructureDefinition or Implementation Guide by a canonical
         * URL. When an implementation guide is specified, the type SHALL conform
         * to at least one profile defined in the implementation guide.
         */
        public java.util.List<String> profile() {
            return getList(String.class, FhirPropertyNames.PROPERTY_PROFILE);
        }

        /**
         * Used when the type is &quot;Reference&quot; or &quot;canonical&quot;, and identifies a
         * profile structure or implementation Guide that applies to the target
         * of the reference this element refers to. If any profiles are
         * specified, then the content must conform to at least one of them. The
         * URL can be a local reference - to a contained StructureDefinition, or
         * a reference to another StructureDefinition or Implementation Guide by
         * a canonical URL. When an implementation guide is specified, the target
         * resource SHALL conform to at least one profile defined in the
         * implementation guide.
         */
        public java.util.List<String> targetProfile() {
            return getList(String.class, FhirPropertyNames.PROPERTY_TARGET_PROFILE);
        }

        /**
         * If the type is a reference to another resource, how the resource is or
         * can be aggregated - is it a contained resource, or a reference, and if
         * the context is a bundle, is it included in the bundle.
         */
        public java.util.List<String> aggregation() {
            return getList(String.class, FhirPropertyNames.PROPERTY_AGGREGATION);
        }

        /**
         * Whether this reference needs to be version specific or version
         * independent, or whether either can be used.
         */
        public String versioning() {
            return getString(FhirPropertyNames.PROPERTY_VERSIONING);
        }

        public static final class Builder extends FhirObject.Builder<ElementDefinitionType, ElementDefinitionType.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder code(final java.net.URI code) {
                b.add(FhirPropertyNames.PROPERTY_CODE, code.toString());
                return this;
            }

            public Builder profile(final java.util.List<String> profile) {
                b.add(FhirPropertyNames.PROPERTY_PROFILE, FhirObject.toStringArray(profile));
                return this;
            }

            public Builder targetProfile(final java.util.List<String> targetProfile) {
                b.add(FhirPropertyNames.PROPERTY_TARGET_PROFILE, FhirObject.toStringArray(targetProfile));
                return this;
            }

            public Builder aggregation(final java.util.List<String> aggregation) {
                b.add(FhirPropertyNames.PROPERTY_AGGREGATION, FhirObject.toStringArray(aggregation));
                return this;
            }

            public Builder versioning(final String versioning) {
                b.add(FhirPropertyNames.PROPERTY_VERSIONING, versioning);
                return this;
            }

            public ElementDefinitionType build() {
                return new ElementDefinitionType(b.build());
            }
        }
    }
}
