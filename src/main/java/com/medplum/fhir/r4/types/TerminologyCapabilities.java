/*
 * Generated by com.medplum.generator.Generator
 * Do not edit manually.
 */

package com.medplum.fhir.r4.types;

import jakarta.json.JsonObject;

import com.medplum.fhir.r4.FhirPropertyNames;

/**
 * A TerminologyCapabilities resource documents a set of capabilities
 * (behaviors) of a FHIR Terminology Server that may be used as a
 * statement of actual server functionality or a statement of required or
 * desired server implementation.
 */
public class TerminologyCapabilities extends DomainResource {
    public static final String RESOURCE_TYPE = "TerminologyCapabilities";

    public static Builder create() {
        return new Builder();
    }

    public static Builder create(final JsonObject data) {
        return new Builder(data);
    }

    public TerminologyCapabilities(final JsonObject data) {
        super(data);
    }

    /**
     * An absolute URI that is used to identify this terminology capabilities
     * when it is referenced in a specification, model, design or an
     * instance; also called its canonical identifier. This SHOULD be
     * globally unique and SHOULD be a literal address at which at which an
     * authoritative instance of this terminology capabilities is (or will
     * be) published. This URL can be the target of a canonical reference. It
     * SHALL remain the same when the terminology capabilities is stored on
     * different servers.
     */
    public java.net.URI url() {
        return getUri(FhirPropertyNames.PROPERTY_URL);
    }

    /**
     * The identifier that is used to identify this version of the
     * terminology capabilities when it is referenced in a specification,
     * model, design or instance. This is an arbitrary value managed by the
     * terminology capabilities author and is not expected to be globally
     * unique. For example, it might be a timestamp (e.g. yyyymmdd) if a
     * managed version is not available. There is also no expectation that
     * versions can be placed in a lexicographical sequence.
     */
    public String version() {
        return getString(FhirPropertyNames.PROPERTY_VERSION);
    }

    /**
     * A natural language name identifying the terminology capabilities. This
     * name should be usable as an identifier for the module by machine
     * processing applications such as code generation.
     */
    public String name() {
        return getString(FhirPropertyNames.PROPERTY_NAME);
    }

    /**
     * A short, descriptive, user-friendly title for the terminology
     * capabilities.
     */
    public String title() {
        return getString(FhirPropertyNames.PROPERTY_TITLE);
    }

    /**
     * The status of this terminology capabilities. Enables tracking the
     * life-cycle of the content.
     */
    public String status() {
        return getString(FhirPropertyNames.PROPERTY_STATUS);
    }

    /**
     * A Boolean value to indicate that this terminology capabilities is
     * authored for testing purposes (or education/evaluation/marketing) and
     * is not intended to be used for genuine usage.
     */
    public Boolean experimental() {
        return data.getBoolean(FhirPropertyNames.PROPERTY_EXPERIMENTAL);
    }

    /**
     * The date  (and optionally time) when the terminology capabilities was
     * published. The date must change when the business version changes and
     * it must change if the status code changes. In addition, it should
     * change when the substantive content of the terminology capabilities
     * changes.
     */
    public java.time.Instant date() {
        return getInstant(FhirPropertyNames.PROPERTY_DATE);
    }

    /**
     * The name of the organization or individual that published the
     * terminology capabilities.
     */
    public String publisher() {
        return getString(FhirPropertyNames.PROPERTY_PUBLISHER);
    }

    /**
     * Contact details to assist a user in finding and communicating with the
     * publisher.
     */
    public java.util.List<ContactDetail> contact() {
        return getList(ContactDetail.class, FhirPropertyNames.PROPERTY_CONTACT);
    }

    /**
     * A free text natural language description of the terminology
     * capabilities from a consumer's perspective. Typically, this is used
     * when the capability statement describes a desired rather than an
     * actual solution, for example as a formal expression of requirements as
     * part of an RFP.
     */
    public String description() {
        return getString(FhirPropertyNames.PROPERTY_DESCRIPTION);
    }

    /**
     * The content was developed with a focus and intent of supporting the
     * contexts that are listed. These contexts may be general categories
     * (gender, age, ...) or may be references to specific programs
     * (insurance plans, studies, ...) and may be used to assist with
     * indexing and searching for appropriate terminology capabilities
     * instances.
     */
    public java.util.List<UsageContext> useContext() {
        return getList(UsageContext.class, FhirPropertyNames.PROPERTY_USE_CONTEXT);
    }

    /**
     * A legal or geographic region in which the terminology capabilities is
     * intended to be used.
     */
    public java.util.List<CodeableConcept> jurisdiction() {
        return getList(CodeableConcept.class, FhirPropertyNames.PROPERTY_JURISDICTION);
    }

    /**
     * Explanation of why this terminology capabilities is needed and why it
     * has been designed as it has.
     */
    public String purpose() {
        return getString(FhirPropertyNames.PROPERTY_PURPOSE);
    }

    /**
     * A copyright statement relating to the terminology capabilities and/or
     * its contents. Copyright statements are generally legal restrictions on
     * the use and publishing of the terminology capabilities.
     */
    public String copyright() {
        return getString(FhirPropertyNames.PROPERTY_COPYRIGHT);
    }

    /**
     * The way that this statement is intended to be used, to describe an
     * actual running instance of software, a particular product (kind, not
     * instance of software) or a class of implementation (e.g. a desired
     * purchase).
     */
    public String kind() {
        return getString(FhirPropertyNames.PROPERTY_KIND);
    }

    /**
     * Software that is covered by this terminology capability statement.  It
     * is used when the statement describes the capabilities of a particular
     * software version, independent of an installation.
     */
    public TerminologyCapabilitiesSoftware software() {
        return getObject(TerminologyCapabilitiesSoftware.class, FhirPropertyNames.PROPERTY_SOFTWARE);
    }

    /**
     * Identifies a specific implementation instance that is described by the
     * terminology capability statement - i.e. a particular installation,
     * rather than the capabilities of a software program.
     */
    public TerminologyCapabilitiesImplementation implementation() {
        return getObject(TerminologyCapabilitiesImplementation.class, FhirPropertyNames.PROPERTY_IMPLEMENTATION);
    }

    /**
     * Whether the server supports lockedDate.
     */
    public Boolean lockedDate() {
        return data.getBoolean(FhirPropertyNames.PROPERTY_LOCKED_DATE);
    }

    /**
     * Identifies a code system that is supported by the server. If there is
     * a no code system URL, then this declares the general assumptions a
     * client can make about support for any CodeSystem resource.
     */
    public java.util.List<TerminologyCapabilitiesCodeSystem> codeSystem() {
        return getList(TerminologyCapabilitiesCodeSystem.class, FhirPropertyNames.PROPERTY_CODE_SYSTEM);
    }

    /**
     * Information about the
     * [ValueSet/$expand](valueset-operation-expand.html) operation.
     */
    public TerminologyCapabilitiesExpansion expansion() {
        return getObject(TerminologyCapabilitiesExpansion.class, FhirPropertyNames.PROPERTY_EXPANSION);
    }

    /**
     * The degree to which the server supports the code search parameter on
     * ValueSet, if it is supported.
     */
    public String codeSearch() {
        return getString(FhirPropertyNames.PROPERTY_CODE_SEARCH);
    }

    /**
     * Information about the
     * [ValueSet/$validate-code](valueset-operation-validate-code.html)
     * operation.
     */
    public TerminologyCapabilitiesValidateCode validateCode() {
        return getObject(TerminologyCapabilitiesValidateCode.class, FhirPropertyNames.PROPERTY_VALIDATE_CODE);
    }

    /**
     * Information about the
     * [ConceptMap/$translate](conceptmap-operation-translate.html)
     * operation.
     */
    public TerminologyCapabilitiesTranslation translation() {
        return getObject(TerminologyCapabilitiesTranslation.class, FhirPropertyNames.PROPERTY_TRANSLATION);
    }

    /**
     * Whether the $closure operation is supported.
     */
    public TerminologyCapabilitiesClosure closure() {
        return getObject(TerminologyCapabilitiesClosure.class, FhirPropertyNames.PROPERTY_CLOSURE);
    }

    public static final class Builder extends DomainResource.Builder<TerminologyCapabilities, TerminologyCapabilities.Builder> {

        private Builder() {
            super(RESOURCE_TYPE);
        }

        private Builder(final JsonObject data) {
            super(RESOURCE_TYPE, data);
        }

        public Builder url(final java.net.URI url) {
            b.add(FhirPropertyNames.PROPERTY_URL, url.toString());
            return this;
        }

        public Builder version(final String version) {
            b.add(FhirPropertyNames.PROPERTY_VERSION, version);
            return this;
        }

        public Builder name(final String name) {
            b.add(FhirPropertyNames.PROPERTY_NAME, name);
            return this;
        }

        public Builder title(final String title) {
            b.add(FhirPropertyNames.PROPERTY_TITLE, title);
            return this;
        }

        public Builder status(final String status) {
            b.add(FhirPropertyNames.PROPERTY_STATUS, status);
            return this;
        }

        public Builder experimental(final Boolean experimental) {
            b.add(FhirPropertyNames.PROPERTY_EXPERIMENTAL, experimental);
            return this;
        }

        public Builder date(final java.time.Instant date) {
            b.add(FhirPropertyNames.PROPERTY_DATE, date.toString());
            return this;
        }

        public Builder publisher(final String publisher) {
            b.add(FhirPropertyNames.PROPERTY_PUBLISHER, publisher);
            return this;
        }

        public Builder contact(final java.util.List<ContactDetail> contact) {
            b.add(FhirPropertyNames.PROPERTY_CONTACT, FhirObject.toArray(contact));
            return this;
        }

        public Builder description(final String description) {
            b.add(FhirPropertyNames.PROPERTY_DESCRIPTION, description);
            return this;
        }

        public Builder useContext(final java.util.List<UsageContext> useContext) {
            b.add(FhirPropertyNames.PROPERTY_USE_CONTEXT, FhirObject.toArray(useContext));
            return this;
        }

        public Builder jurisdiction(final java.util.List<CodeableConcept> jurisdiction) {
            b.add(FhirPropertyNames.PROPERTY_JURISDICTION, FhirObject.toArray(jurisdiction));
            return this;
        }

        public Builder purpose(final String purpose) {
            b.add(FhirPropertyNames.PROPERTY_PURPOSE, purpose);
            return this;
        }

        public Builder copyright(final String copyright) {
            b.add(FhirPropertyNames.PROPERTY_COPYRIGHT, copyright);
            return this;
        }

        public Builder kind(final String kind) {
            b.add(FhirPropertyNames.PROPERTY_KIND, kind);
            return this;
        }

        public Builder software(final TerminologyCapabilitiesSoftware software) {
            b.add(FhirPropertyNames.PROPERTY_SOFTWARE, software);
            return this;
        }

        public Builder implementation(final TerminologyCapabilitiesImplementation implementation) {
            b.add(FhirPropertyNames.PROPERTY_IMPLEMENTATION, implementation);
            return this;
        }

        public Builder lockedDate(final Boolean lockedDate) {
            b.add(FhirPropertyNames.PROPERTY_LOCKED_DATE, lockedDate);
            return this;
        }

        public Builder codeSystem(final java.util.List<TerminologyCapabilitiesCodeSystem> codeSystem) {
            b.add(FhirPropertyNames.PROPERTY_CODE_SYSTEM, FhirObject.toArray(codeSystem));
            return this;
        }

        public Builder expansion(final TerminologyCapabilitiesExpansion expansion) {
            b.add(FhirPropertyNames.PROPERTY_EXPANSION, expansion);
            return this;
        }

        public Builder codeSearch(final String codeSearch) {
            b.add(FhirPropertyNames.PROPERTY_CODE_SEARCH, codeSearch);
            return this;
        }

        public Builder validateCode(final TerminologyCapabilitiesValidateCode validateCode) {
            b.add(FhirPropertyNames.PROPERTY_VALIDATE_CODE, validateCode);
            return this;
        }

        public Builder translation(final TerminologyCapabilitiesTranslation translation) {
            b.add(FhirPropertyNames.PROPERTY_TRANSLATION, translation);
            return this;
        }

        public Builder closure(final TerminologyCapabilitiesClosure closure) {
            b.add(FhirPropertyNames.PROPERTY_CLOSURE, closure);
            return this;
        }

        public TerminologyCapabilities build() {
            return new TerminologyCapabilities(b.build());
        }
    }

    /**
     * A TerminologyCapabilities resource documents a set of capabilities
     * (behaviors) of a FHIR Terminology Server that may be used as a
     * statement of actual server functionality or a statement of required or
     * desired server implementation.
     */
    public static class TerminologyCapabilitiesClosure extends FhirObject {
        public static final String RESOURCE_TYPE = "TerminologyCapabilitiesClosure";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public TerminologyCapabilitiesClosure(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * If cross-system closure is supported.
         */
        public Boolean translation() {
            return data.getBoolean(FhirPropertyNames.PROPERTY_TRANSLATION);
        }

        public static final class Builder extends FhirObject.Builder<TerminologyCapabilitiesClosure, TerminologyCapabilitiesClosure.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder translation(final Boolean translation) {
                b.add(FhirPropertyNames.PROPERTY_TRANSLATION, translation);
                return this;
            }

            public TerminologyCapabilitiesClosure build() {
                return new TerminologyCapabilitiesClosure(b.build());
            }
        }
    }

    /**
     * A TerminologyCapabilities resource documents a set of capabilities
     * (behaviors) of a FHIR Terminology Server that may be used as a
     * statement of actual server functionality or a statement of required or
     * desired server implementation.
     */
    public static class TerminologyCapabilitiesCodeSystem extends FhirObject {
        public static final String RESOURCE_TYPE = "TerminologyCapabilitiesCodeSystem";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public TerminologyCapabilitiesCodeSystem(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * URI for the Code System.
         */
        public String uri() {
            return getString(FhirPropertyNames.PROPERTY_URI);
        }

        /**
         * For the code system, a list of versions that are supported by the
         * server.
         */
        public java.util.List<TerminologyCapabilitiesVersion> version() {
            return getList(TerminologyCapabilitiesVersion.class, FhirPropertyNames.PROPERTY_VERSION);
        }

        /**
         * True if subsumption is supported for this version of the code system.
         */
        public Boolean subsumption() {
            return data.getBoolean(FhirPropertyNames.PROPERTY_SUBSUMPTION);
        }

        public static final class Builder extends FhirObject.Builder<TerminologyCapabilitiesCodeSystem, TerminologyCapabilitiesCodeSystem.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder uri(final String uri) {
                b.add(FhirPropertyNames.PROPERTY_URI, uri);
                return this;
            }

            public Builder version(final java.util.List<TerminologyCapabilitiesVersion> version) {
                b.add(FhirPropertyNames.PROPERTY_VERSION, FhirObject.toArray(version));
                return this;
            }

            public Builder subsumption(final Boolean subsumption) {
                b.add(FhirPropertyNames.PROPERTY_SUBSUMPTION, subsumption);
                return this;
            }

            public TerminologyCapabilitiesCodeSystem build() {
                return new TerminologyCapabilitiesCodeSystem(b.build());
            }
        }
    }

    /**
     * A TerminologyCapabilities resource documents a set of capabilities
     * (behaviors) of a FHIR Terminology Server that may be used as a
     * statement of actual server functionality or a statement of required or
     * desired server implementation.
     */
    public static class TerminologyCapabilitiesExpansion extends FhirObject {
        public static final String RESOURCE_TYPE = "TerminologyCapabilitiesExpansion";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public TerminologyCapabilitiesExpansion(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Whether the server can return nested value sets.
         */
        public Boolean hierarchical() {
            return data.getBoolean(FhirPropertyNames.PROPERTY_HIERARCHICAL);
        }

        /**
         * Whether the server supports paging on expansion.
         */
        public Boolean paging() {
            return data.getBoolean(FhirPropertyNames.PROPERTY_PAGING);
        }

        /**
         * Allow request for incomplete expansions?
         */
        public Boolean incomplete() {
            return data.getBoolean(FhirPropertyNames.PROPERTY_INCOMPLETE);
        }

        /**
         * Supported expansion parameter.
         */
        public java.util.List<TerminologyCapabilitiesParameter> parameter() {
            return getList(TerminologyCapabilitiesParameter.class, FhirPropertyNames.PROPERTY_PARAMETER);
        }

        /**
         * Documentation about text searching works.
         */
        public String textFilter() {
            return getString(FhirPropertyNames.PROPERTY_TEXT_FILTER);
        }

        public static final class Builder extends FhirObject.Builder<TerminologyCapabilitiesExpansion, TerminologyCapabilitiesExpansion.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder hierarchical(final Boolean hierarchical) {
                b.add(FhirPropertyNames.PROPERTY_HIERARCHICAL, hierarchical);
                return this;
            }

            public Builder paging(final Boolean paging) {
                b.add(FhirPropertyNames.PROPERTY_PAGING, paging);
                return this;
            }

            public Builder incomplete(final Boolean incomplete) {
                b.add(FhirPropertyNames.PROPERTY_INCOMPLETE, incomplete);
                return this;
            }

            public Builder parameter(final java.util.List<TerminologyCapabilitiesParameter> parameter) {
                b.add(FhirPropertyNames.PROPERTY_PARAMETER, FhirObject.toArray(parameter));
                return this;
            }

            public Builder textFilter(final String textFilter) {
                b.add(FhirPropertyNames.PROPERTY_TEXT_FILTER, textFilter);
                return this;
            }

            public TerminologyCapabilitiesExpansion build() {
                return new TerminologyCapabilitiesExpansion(b.build());
            }
        }
    }

    /**
     * A TerminologyCapabilities resource documents a set of capabilities
     * (behaviors) of a FHIR Terminology Server that may be used as a
     * statement of actual server functionality or a statement of required or
     * desired server implementation.
     */
    public static class TerminologyCapabilitiesFilter extends FhirObject {
        public static final String RESOURCE_TYPE = "TerminologyCapabilitiesFilter";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public TerminologyCapabilitiesFilter(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Code of the property supported.
         */
        public String code() {
            return getString(FhirPropertyNames.PROPERTY_CODE);
        }

        /**
         * Operations supported for the property.
         */
        public java.util.List<String> op() {
            return getList(String.class, FhirPropertyNames.PROPERTY_OP);
        }

        public static final class Builder extends FhirObject.Builder<TerminologyCapabilitiesFilter, TerminologyCapabilitiesFilter.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder code(final String code) {
                b.add(FhirPropertyNames.PROPERTY_CODE, code);
                return this;
            }

            public Builder op(final java.util.List<String> op) {
                b.add(FhirPropertyNames.PROPERTY_OP, FhirObject.toStringArray(op));
                return this;
            }

            public TerminologyCapabilitiesFilter build() {
                return new TerminologyCapabilitiesFilter(b.build());
            }
        }
    }

    /**
     * A TerminologyCapabilities resource documents a set of capabilities
     * (behaviors) of a FHIR Terminology Server that may be used as a
     * statement of actual server functionality or a statement of required or
     * desired server implementation.
     */
    public static class TerminologyCapabilitiesImplementation extends FhirObject {
        public static final String RESOURCE_TYPE = "TerminologyCapabilitiesImplementation";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public TerminologyCapabilitiesImplementation(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Information about the specific installation that this terminology
         * capability statement relates to.
         */
        public String description() {
            return getString(FhirPropertyNames.PROPERTY_DESCRIPTION);
        }

        /**
         * An absolute base URL for the implementation.
         */
        public java.net.URI url() {
            return getUri(FhirPropertyNames.PROPERTY_URL);
        }

        public static final class Builder extends FhirObject.Builder<TerminologyCapabilitiesImplementation, TerminologyCapabilitiesImplementation.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder description(final String description) {
                b.add(FhirPropertyNames.PROPERTY_DESCRIPTION, description);
                return this;
            }

            public Builder url(final java.net.URI url) {
                b.add(FhirPropertyNames.PROPERTY_URL, url.toString());
                return this;
            }

            public TerminologyCapabilitiesImplementation build() {
                return new TerminologyCapabilitiesImplementation(b.build());
            }
        }
    }

    /**
     * A TerminologyCapabilities resource documents a set of capabilities
     * (behaviors) of a FHIR Terminology Server that may be used as a
     * statement of actual server functionality or a statement of required or
     * desired server implementation.
     */
    public static class TerminologyCapabilitiesParameter extends FhirObject {
        public static final String RESOURCE_TYPE = "TerminologyCapabilitiesParameter";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public TerminologyCapabilitiesParameter(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Expansion Parameter name.
         */
        public String name() {
            return getString(FhirPropertyNames.PROPERTY_NAME);
        }

        /**
         * Description of support for parameter.
         */
        public String documentation() {
            return getString(FhirPropertyNames.PROPERTY_DOCUMENTATION);
        }

        public static final class Builder extends FhirObject.Builder<TerminologyCapabilitiesParameter, TerminologyCapabilitiesParameter.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder name(final String name) {
                b.add(FhirPropertyNames.PROPERTY_NAME, name);
                return this;
            }

            public Builder documentation(final String documentation) {
                b.add(FhirPropertyNames.PROPERTY_DOCUMENTATION, documentation);
                return this;
            }

            public TerminologyCapabilitiesParameter build() {
                return new TerminologyCapabilitiesParameter(b.build());
            }
        }
    }

    /**
     * A TerminologyCapabilities resource documents a set of capabilities
     * (behaviors) of a FHIR Terminology Server that may be used as a
     * statement of actual server functionality or a statement of required or
     * desired server implementation.
     */
    public static class TerminologyCapabilitiesSoftware extends FhirObject {
        public static final String RESOURCE_TYPE = "TerminologyCapabilitiesSoftware";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public TerminologyCapabilitiesSoftware(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Name the software is known by.
         */
        public String name() {
            return getString(FhirPropertyNames.PROPERTY_NAME);
        }

        /**
         * The version identifier for the software covered by this statement.
         */
        public String version() {
            return getString(FhirPropertyNames.PROPERTY_VERSION);
        }

        public static final class Builder extends FhirObject.Builder<TerminologyCapabilitiesSoftware, TerminologyCapabilitiesSoftware.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder name(final String name) {
                b.add(FhirPropertyNames.PROPERTY_NAME, name);
                return this;
            }

            public Builder version(final String version) {
                b.add(FhirPropertyNames.PROPERTY_VERSION, version);
                return this;
            }

            public TerminologyCapabilitiesSoftware build() {
                return new TerminologyCapabilitiesSoftware(b.build());
            }
        }
    }

    /**
     * A TerminologyCapabilities resource documents a set of capabilities
     * (behaviors) of a FHIR Terminology Server that may be used as a
     * statement of actual server functionality or a statement of required or
     * desired server implementation.
     */
    public static class TerminologyCapabilitiesTranslation extends FhirObject {
        public static final String RESOURCE_TYPE = "TerminologyCapabilitiesTranslation";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public TerminologyCapabilitiesTranslation(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Whether the client must identify the map.
         */
        public Boolean needsMap() {
            return data.getBoolean(FhirPropertyNames.PROPERTY_NEEDS_MAP);
        }

        public static final class Builder extends FhirObject.Builder<TerminologyCapabilitiesTranslation, TerminologyCapabilitiesTranslation.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder needsMap(final Boolean needsMap) {
                b.add(FhirPropertyNames.PROPERTY_NEEDS_MAP, needsMap);
                return this;
            }

            public TerminologyCapabilitiesTranslation build() {
                return new TerminologyCapabilitiesTranslation(b.build());
            }
        }
    }

    /**
     * A TerminologyCapabilities resource documents a set of capabilities
     * (behaviors) of a FHIR Terminology Server that may be used as a
     * statement of actual server functionality or a statement of required or
     * desired server implementation.
     */
    public static class TerminologyCapabilitiesValidateCode extends FhirObject {
        public static final String RESOURCE_TYPE = "TerminologyCapabilitiesValidateCode";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public TerminologyCapabilitiesValidateCode(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Whether translations are validated.
         */
        public Boolean translations() {
            return data.getBoolean(FhirPropertyNames.PROPERTY_TRANSLATIONS);
        }

        public static final class Builder extends FhirObject.Builder<TerminologyCapabilitiesValidateCode, TerminologyCapabilitiesValidateCode.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder translations(final Boolean translations) {
                b.add(FhirPropertyNames.PROPERTY_TRANSLATIONS, translations);
                return this;
            }

            public TerminologyCapabilitiesValidateCode build() {
                return new TerminologyCapabilitiesValidateCode(b.build());
            }
        }
    }

    /**
     * A TerminologyCapabilities resource documents a set of capabilities
     * (behaviors) of a FHIR Terminology Server that may be used as a
     * statement of actual server functionality or a statement of required or
     * desired server implementation.
     */
    public static class TerminologyCapabilitiesVersion extends FhirObject {
        public static final String RESOURCE_TYPE = "TerminologyCapabilitiesVersion";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public TerminologyCapabilitiesVersion(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * For version-less code systems, there should be a single version with
         * no identifier.
         */
        public String code() {
            return getString(FhirPropertyNames.PROPERTY_CODE);
        }

        /**
         * If this is the default version for this code system.
         */
        public Boolean isDefault() {
            return data.getBoolean(FhirPropertyNames.PROPERTY_IS_DEFAULT);
        }

        /**
         * If the compositional grammar defined by the code system is supported.
         */
        public Boolean compositional() {
            return data.getBoolean(FhirPropertyNames.PROPERTY_COMPOSITIONAL);
        }

        /**
         * Language Displays supported.
         */
        public java.util.List<String> language() {
            return getList(String.class, FhirPropertyNames.PROPERTY_LANGUAGE);
        }

        /**
         * Filter Properties supported.
         */
        public java.util.List<TerminologyCapabilitiesFilter> filter() {
            return getList(TerminologyCapabilitiesFilter.class, FhirPropertyNames.PROPERTY_FILTER);
        }

        /**
         * Properties supported for $lookup.
         */
        public java.util.List<String> property() {
            return getList(String.class, FhirPropertyNames.PROPERTY_PROPERTY);
        }

        public static final class Builder extends FhirObject.Builder<TerminologyCapabilitiesVersion, TerminologyCapabilitiesVersion.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder code(final String code) {
                b.add(FhirPropertyNames.PROPERTY_CODE, code);
                return this;
            }

            public Builder isDefault(final Boolean isDefault) {
                b.add(FhirPropertyNames.PROPERTY_IS_DEFAULT, isDefault);
                return this;
            }

            public Builder compositional(final Boolean compositional) {
                b.add(FhirPropertyNames.PROPERTY_COMPOSITIONAL, compositional);
                return this;
            }

            public Builder language(final java.util.List<String> language) {
                b.add(FhirPropertyNames.PROPERTY_LANGUAGE, FhirObject.toStringArray(language));
                return this;
            }

            public Builder filter(final java.util.List<TerminologyCapabilitiesFilter> filter) {
                b.add(FhirPropertyNames.PROPERTY_FILTER, FhirObject.toArray(filter));
                return this;
            }

            public Builder property(final java.util.List<String> property) {
                b.add(FhirPropertyNames.PROPERTY_PROPERTY, FhirObject.toStringArray(property));
                return this;
            }

            public TerminologyCapabilitiesVersion build() {
                return new TerminologyCapabilitiesVersion(b.build());
            }
        }
    }
}
