/*
 * Generated by com.medplum.generator.Generator
 * Do not edit manually.
 */

package com.medplum.fhir.r4.types;

import jakarta.json.JsonObject;

import com.medplum.fhir.r4.FhirPropertyNames;

/**
 * A summary of information based on the results of executing a
 * TestScript.
 */
public class TestReport extends DomainResource {
    public static final String RESOURCE_TYPE = "TestReport";

    public static Builder create() {
        return new Builder();
    }

    public static Builder create(final JsonObject data) {
        return new Builder(data);
    }

    public TestReport(final JsonObject data) {
        super(data);
    }

    /**
     * Identifier for the TestScript assigned for external purposes outside
     * the context of FHIR.
     */
    public Identifier identifier() {
        return getObject(Identifier.class, FhirPropertyNames.PROPERTY_IDENTIFIER);
    }

    /**
     * A free text natural language name identifying the executed TestScript.
     */
    public String name() {
        return getString(FhirPropertyNames.PROPERTY_NAME);
    }

    /**
     * The current state of this test report.
     */
    public String status() {
        return getString(FhirPropertyNames.PROPERTY_STATUS);
    }

    /**
     * Ideally this is an absolute URL that is used to identify the
     * version-specific TestScript that was executed, matching the
     * `TestScript.url`.
     */
    public Reference testScript() {
        return getObject(Reference.class, FhirPropertyNames.PROPERTY_TEST_SCRIPT);
    }

    /**
     * The overall result from the execution of the TestScript.
     */
    public String result() {
        return getString(FhirPropertyNames.PROPERTY_RESULT);
    }

    /**
     * The final score (percentage of tests passed) resulting from the
     * execution of the TestScript.
     */
    public Double score() {
        return data.getJsonNumber(FhirPropertyNames.PROPERTY_SCORE).doubleValue();
    }

    /**
     * Name of the tester producing this report (Organization or individual).
     */
    public String tester() {
        return getString(FhirPropertyNames.PROPERTY_TESTER);
    }

    /**
     * When the TestScript was executed and this TestReport was generated.
     */
    public java.time.Instant issued() {
        return getInstant(FhirPropertyNames.PROPERTY_ISSUED);
    }

    /**
     * A participant in the test execution, either the execution engine, a
     * client, or a server.
     */
    public java.util.List<TestReportParticipant> participant() {
        return getList(TestReportParticipant.class, FhirPropertyNames.PROPERTY_PARTICIPANT);
    }

    /**
     * The results of the series of required setup operations before the
     * tests were executed.
     */
    public TestReportSetup setup() {
        return getObject(TestReportSetup.class, FhirPropertyNames.PROPERTY_SETUP);
    }

    /**
     * A test executed from the test script.
     */
    public java.util.List<TestReportTest> test() {
        return getList(TestReportTest.class, FhirPropertyNames.PROPERTY_TEST);
    }

    /**
     * The results of the series of operations required to clean up after all
     * the tests were executed (successfully or otherwise).
     */
    public TestReportTeardown teardown() {
        return getObject(TestReportTeardown.class, FhirPropertyNames.PROPERTY_TEARDOWN);
    }

    public static final class Builder extends DomainResource.Builder<TestReport, TestReport.Builder> {

        private Builder() {
            super(RESOURCE_TYPE);
        }

        private Builder(final JsonObject data) {
            super(RESOURCE_TYPE, data);
        }

        public Builder identifier(final Identifier identifier) {
            b.add(FhirPropertyNames.PROPERTY_IDENTIFIER, identifier);
            return this;
        }

        public Builder name(final String name) {
            b.add(FhirPropertyNames.PROPERTY_NAME, name);
            return this;
        }

        public Builder status(final String status) {
            b.add(FhirPropertyNames.PROPERTY_STATUS, status);
            return this;
        }

        public Builder testScript(final Reference testScript) {
            b.add(FhirPropertyNames.PROPERTY_TEST_SCRIPT, testScript);
            return this;
        }

        public Builder result(final String result) {
            b.add(FhirPropertyNames.PROPERTY_RESULT, result);
            return this;
        }

        public Builder score(final Double score) {
            b.add(FhirPropertyNames.PROPERTY_SCORE, score);
            return this;
        }

        public Builder tester(final String tester) {
            b.add(FhirPropertyNames.PROPERTY_TESTER, tester);
            return this;
        }

        public Builder issued(final java.time.Instant issued) {
            b.add(FhirPropertyNames.PROPERTY_ISSUED, issued.toString());
            return this;
        }

        public Builder participant(final java.util.List<TestReportParticipant> participant) {
            b.add(FhirPropertyNames.PROPERTY_PARTICIPANT, FhirObject.toArray(participant));
            return this;
        }

        public Builder setup(final TestReportSetup setup) {
            b.add(FhirPropertyNames.PROPERTY_SETUP, setup);
            return this;
        }

        public Builder test(final java.util.List<TestReportTest> test) {
            b.add(FhirPropertyNames.PROPERTY_TEST, FhirObject.toArray(test));
            return this;
        }

        public Builder teardown(final TestReportTeardown teardown) {
            b.add(FhirPropertyNames.PROPERTY_TEARDOWN, teardown);
            return this;
        }

        public TestReport build() {
            return new TestReport(b.build());
        }
    }

    /**
     * A summary of information based on the results of executing a
     * TestScript.
     */
    public static class TestReportAction extends FhirObject {
        public static final String RESOURCE_TYPE = "TestReportAction";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public TestReportAction(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * The operation performed.
         */
        public TestReportOperation operation() {
            return getObject(TestReportOperation.class, FhirPropertyNames.PROPERTY_OPERATION);
        }

        /**
         * The results of the assertion performed on the previous operations.
         */
        public TestReportAssert assertValue() {
            return getObject(TestReportAssert.class, FhirPropertyNames.PROPERTY_ASSERT);
        }

        public static final class Builder extends FhirObject.Builder<TestReportAction, TestReportAction.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder operation(final TestReportOperation operation) {
                b.add(FhirPropertyNames.PROPERTY_OPERATION, operation);
                return this;
            }

            public Builder assertValue(final TestReportAssert assertValue) {
                b.add(FhirPropertyNames.PROPERTY_ASSERT, assertValue);
                return this;
            }

            public TestReportAction build() {
                return new TestReportAction(b.build());
            }
        }
    }

    /**
     * A summary of information based on the results of executing a
     * TestScript.
     */
    public static class TestReportAction1 extends FhirObject {
        public static final String RESOURCE_TYPE = "TestReportAction1";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public TestReportAction1(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * An operation would involve a REST request to a server.
         */
        public TestReportOperation operation() {
            return getObject(TestReportOperation.class, FhirPropertyNames.PROPERTY_OPERATION);
        }

        /**
         * The results of the assertion performed on the previous operations.
         */
        public TestReportAssert assertValue() {
            return getObject(TestReportAssert.class, FhirPropertyNames.PROPERTY_ASSERT);
        }

        public static final class Builder extends FhirObject.Builder<TestReportAction1, TestReportAction1.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder operation(final TestReportOperation operation) {
                b.add(FhirPropertyNames.PROPERTY_OPERATION, operation);
                return this;
            }

            public Builder assertValue(final TestReportAssert assertValue) {
                b.add(FhirPropertyNames.PROPERTY_ASSERT, assertValue);
                return this;
            }

            public TestReportAction1 build() {
                return new TestReportAction1(b.build());
            }
        }
    }

    /**
     * A summary of information based on the results of executing a
     * TestScript.
     */
    public static class TestReportAction2 extends FhirObject {
        public static final String RESOURCE_TYPE = "TestReportAction2";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public TestReportAction2(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * An operation would involve a REST request to a server.
         */
        public TestReportOperation operation() {
            return getObject(TestReportOperation.class, FhirPropertyNames.PROPERTY_OPERATION);
        }

        public static final class Builder extends FhirObject.Builder<TestReportAction2, TestReportAction2.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder operation(final TestReportOperation operation) {
                b.add(FhirPropertyNames.PROPERTY_OPERATION, operation);
                return this;
            }

            public TestReportAction2 build() {
                return new TestReportAction2(b.build());
            }
        }
    }

    /**
     * A summary of information based on the results of executing a
     * TestScript.
     */
    public static class TestReportAssert extends FhirObject {
        public static final String RESOURCE_TYPE = "TestReportAssert";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public TestReportAssert(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * The result of this assertion.
         */
        public String result() {
            return getString(FhirPropertyNames.PROPERTY_RESULT);
        }

        /**
         * An explanatory message associated with the result.
         */
        public String message() {
            return getString(FhirPropertyNames.PROPERTY_MESSAGE);
        }

        /**
         * A link to further details on the result.
         */
        public String detail() {
            return getString(FhirPropertyNames.PROPERTY_DETAIL);
        }

        public static final class Builder extends FhirObject.Builder<TestReportAssert, TestReportAssert.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder result(final String result) {
                b.add(FhirPropertyNames.PROPERTY_RESULT, result);
                return this;
            }

            public Builder message(final String message) {
                b.add(FhirPropertyNames.PROPERTY_MESSAGE, message);
                return this;
            }

            public Builder detail(final String detail) {
                b.add(FhirPropertyNames.PROPERTY_DETAIL, detail);
                return this;
            }

            public TestReportAssert build() {
                return new TestReportAssert(b.build());
            }
        }
    }

    /**
     * A summary of information based on the results of executing a
     * TestScript.
     */
    public static class TestReportOperation extends FhirObject {
        public static final String RESOURCE_TYPE = "TestReportOperation";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public TestReportOperation(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * The result of this operation.
         */
        public String result() {
            return getString(FhirPropertyNames.PROPERTY_RESULT);
        }

        /**
         * An explanatory message associated with the result.
         */
        public String message() {
            return getString(FhirPropertyNames.PROPERTY_MESSAGE);
        }

        /**
         * A link to further details on the result.
         */
        public java.net.URI detail() {
            return getUri(FhirPropertyNames.PROPERTY_DETAIL);
        }

        public static final class Builder extends FhirObject.Builder<TestReportOperation, TestReportOperation.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder result(final String result) {
                b.add(FhirPropertyNames.PROPERTY_RESULT, result);
                return this;
            }

            public Builder message(final String message) {
                b.add(FhirPropertyNames.PROPERTY_MESSAGE, message);
                return this;
            }

            public Builder detail(final java.net.URI detail) {
                b.add(FhirPropertyNames.PROPERTY_DETAIL, detail.toString());
                return this;
            }

            public TestReportOperation build() {
                return new TestReportOperation(b.build());
            }
        }
    }

    /**
     * A summary of information based on the results of executing a
     * TestScript.
     */
    public static class TestReportParticipant extends FhirObject {
        public static final String RESOURCE_TYPE = "TestReportParticipant";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public TestReportParticipant(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * The type of participant.
         */
        public String type() {
            return getString(FhirPropertyNames.PROPERTY_TYPE);
        }

        /**
         * The uri of the participant. An absolute URL is preferred.
         */
        public java.net.URI uri() {
            return getUri(FhirPropertyNames.PROPERTY_URI);
        }

        /**
         * The display name of the participant.
         */
        public String display() {
            return getString(FhirPropertyNames.PROPERTY_DISPLAY);
        }

        public static final class Builder extends FhirObject.Builder<TestReportParticipant, TestReportParticipant.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder type(final String type) {
                b.add(FhirPropertyNames.PROPERTY_TYPE, type);
                return this;
            }

            public Builder uri(final java.net.URI uri) {
                b.add(FhirPropertyNames.PROPERTY_URI, uri.toString());
                return this;
            }

            public Builder display(final String display) {
                b.add(FhirPropertyNames.PROPERTY_DISPLAY, display);
                return this;
            }

            public TestReportParticipant build() {
                return new TestReportParticipant(b.build());
            }
        }
    }

    /**
     * A summary of information based on the results of executing a
     * TestScript.
     */
    public static class TestReportSetup extends FhirObject {
        public static final String RESOURCE_TYPE = "TestReportSetup";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public TestReportSetup(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Action would contain either an operation or an assertion.
         */
        public java.util.List<TestReportAction> action() {
            return getList(TestReportAction.class, FhirPropertyNames.PROPERTY_ACTION);
        }

        public static final class Builder extends FhirObject.Builder<TestReportSetup, TestReportSetup.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder action(final java.util.List<TestReportAction> action) {
                b.add(FhirPropertyNames.PROPERTY_ACTION, FhirObject.toArray(action));
                return this;
            }

            public TestReportSetup build() {
                return new TestReportSetup(b.build());
            }
        }
    }

    /**
     * A summary of information based on the results of executing a
     * TestScript.
     */
    public static class TestReportTeardown extends FhirObject {
        public static final String RESOURCE_TYPE = "TestReportTeardown";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public TestReportTeardown(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * The teardown action will only contain an operation.
         */
        public java.util.List<TestReportAction2> action() {
            return getList(TestReportAction2.class, FhirPropertyNames.PROPERTY_ACTION);
        }

        public static final class Builder extends FhirObject.Builder<TestReportTeardown, TestReportTeardown.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder action(final java.util.List<TestReportAction2> action) {
                b.add(FhirPropertyNames.PROPERTY_ACTION, FhirObject.toArray(action));
                return this;
            }

            public TestReportTeardown build() {
                return new TestReportTeardown(b.build());
            }
        }
    }

    /**
     * A summary of information based on the results of executing a
     * TestScript.
     */
    public static class TestReportTest extends FhirObject {
        public static final String RESOURCE_TYPE = "TestReportTest";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public TestReportTest(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * The name of this test used for tracking/logging purposes by test
         * engines.
         */
        public String name() {
            return getString(FhirPropertyNames.PROPERTY_NAME);
        }

        /**
         * A short description of the test used by test engines for tracking and
         * reporting purposes.
         */
        public String description() {
            return getString(FhirPropertyNames.PROPERTY_DESCRIPTION);
        }

        /**
         * Action would contain either an operation or an assertion.
         */
        public java.util.List<TestReportAction1> action() {
            return getList(TestReportAction1.class, FhirPropertyNames.PROPERTY_ACTION);
        }

        public static final class Builder extends FhirObject.Builder<TestReportTest, TestReportTest.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder name(final String name) {
                b.add(FhirPropertyNames.PROPERTY_NAME, name);
                return this;
            }

            public Builder description(final String description) {
                b.add(FhirPropertyNames.PROPERTY_DESCRIPTION, description);
                return this;
            }

            public Builder action(final java.util.List<TestReportAction1> action) {
                b.add(FhirPropertyNames.PROPERTY_ACTION, FhirObject.toArray(action));
                return this;
            }

            public TestReportTest build() {
                return new TestReportTest(b.build());
            }
        }
    }
}
