/*
 * Generated by com.medplum.generator.Generator
 * Do not edit manually.
 */

package com.medplum.fhir.r4.types;

import jakarta.json.JsonObject;

import com.medplum.fhir.r4.FhirPropertyNames;

/**
 * The detailed description of a substance, typically at a level beyond
 * what is used for prescribing.
 */
public class SubstanceSpecification extends DomainResource {
    public static final String RESOURCE_TYPE = "SubstanceSpecification";

    public static Builder create() {
        return new Builder();
    }

    public static Builder create(final JsonObject data) {
        return new Builder(data);
    }

    public SubstanceSpecification(final JsonObject data) {
        super(data);
    }

    /**
     * Identifier by which this substance is known.
     */
    public Identifier identifier() {
        return getObject(Identifier.class, FhirPropertyNames.PROPERTY_IDENTIFIER);
    }

    /**
     * High level categorization, e.g. polymer or nucleic acid.
     */
    public CodeableConcept type() {
        return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_TYPE);
    }

    /**
     * Status of substance within the catalogue e.g. approved.
     */
    public CodeableConcept status() {
        return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_STATUS);
    }

    /**
     * If the substance applies to only human or veterinary use.
     */
    public CodeableConcept domain() {
        return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_DOMAIN);
    }

    /**
     * Textual description of the substance.
     */
    public String description() {
        return getString(FhirPropertyNames.PROPERTY_DESCRIPTION);
    }

    /**
     * Supporting literature.
     */
    public java.util.List<Reference> source() {
        return getList(Reference.class, FhirPropertyNames.PROPERTY_SOURCE);
    }

    /**
     * Textual comment about this record of a substance.
     */
    public String comment() {
        return getString(FhirPropertyNames.PROPERTY_COMMENT);
    }

    /**
     * Moiety, for structural modifications.
     */
    public java.util.List<SubstanceSpecificationMoiety> moiety() {
        return getList(SubstanceSpecificationMoiety.class, FhirPropertyNames.PROPERTY_MOIETY);
    }

    /**
     * General specifications for this substance, including how it is related
     * to other substances.
     */
    public java.util.List<SubstanceSpecificationProperty> property() {
        return getList(SubstanceSpecificationProperty.class, FhirPropertyNames.PROPERTY_PROPERTY);
    }

    /**
     * General information detailing this substance.
     */
    public Reference referenceInformation() {
        return getObject(Reference.class, FhirPropertyNames.PROPERTY_REFERENCE_INFORMATION);
    }

    /**
     * Structural information.
     */
    public SubstanceSpecificationStructure structure() {
        return getObject(SubstanceSpecificationStructure.class, FhirPropertyNames.PROPERTY_STRUCTURE);
    }

    /**
     * Codes associated with the substance.
     */
    public java.util.List<SubstanceSpecificationCode> code() {
        return getList(SubstanceSpecificationCode.class, FhirPropertyNames.PROPERTY_CODE);
    }

    /**
     * Names applicable to this substance.
     */
    public java.util.List<SubstanceSpecificationName> name() {
        return getList(SubstanceSpecificationName.class, FhirPropertyNames.PROPERTY_NAME);
    }

    /**
     * The molecular weight or weight range (for proteins, polymers or
     * nucleic acids).
     */
    public java.util.List<SubstanceSpecificationMolecularWeight> molecularWeight() {
        return getList(SubstanceSpecificationMolecularWeight.class, FhirPropertyNames.PROPERTY_MOLECULAR_WEIGHT);
    }

    /**
     * A link between this substance and another, with details of the
     * relationship.
     */
    public java.util.List<SubstanceSpecificationRelationship> relationship() {
        return getList(SubstanceSpecificationRelationship.class, FhirPropertyNames.PROPERTY_RELATIONSHIP);
    }

    /**
     * Data items specific to nucleic acids.
     */
    public Reference nucleicAcid() {
        return getObject(Reference.class, FhirPropertyNames.PROPERTY_NUCLEIC_ACID);
    }

    /**
     * Data items specific to polymers.
     */
    public Reference polymer() {
        return getObject(Reference.class, FhirPropertyNames.PROPERTY_POLYMER);
    }

    /**
     * Data items specific to proteins.
     */
    public Reference protein() {
        return getObject(Reference.class, FhirPropertyNames.PROPERTY_PROTEIN);
    }

    /**
     * Material or taxonomic/anatomical source for the substance.
     */
    public Reference sourceMaterial() {
        return getObject(Reference.class, FhirPropertyNames.PROPERTY_SOURCE_MATERIAL);
    }

    public static final class Builder extends DomainResource.Builder<SubstanceSpecification, SubstanceSpecification.Builder> {

        private Builder() {
            super(RESOURCE_TYPE);
        }

        private Builder(final JsonObject data) {
            super(RESOURCE_TYPE, data);
        }

        public Builder identifier(final Identifier identifier) {
            b.add(FhirPropertyNames.PROPERTY_IDENTIFIER, identifier);
            return this;
        }

        public Builder type(final CodeableConcept type) {
            b.add(FhirPropertyNames.PROPERTY_TYPE, type);
            return this;
        }

        public Builder status(final CodeableConcept status) {
            b.add(FhirPropertyNames.PROPERTY_STATUS, status);
            return this;
        }

        public Builder domain(final CodeableConcept domain) {
            b.add(FhirPropertyNames.PROPERTY_DOMAIN, domain);
            return this;
        }

        public Builder description(final String description) {
            b.add(FhirPropertyNames.PROPERTY_DESCRIPTION, description);
            return this;
        }

        public Builder source(final java.util.List<Reference> source) {
            b.add(FhirPropertyNames.PROPERTY_SOURCE, FhirObject.toArray(source));
            return this;
        }

        public Builder comment(final String comment) {
            b.add(FhirPropertyNames.PROPERTY_COMMENT, comment);
            return this;
        }

        public Builder moiety(final java.util.List<SubstanceSpecificationMoiety> moiety) {
            b.add(FhirPropertyNames.PROPERTY_MOIETY, FhirObject.toArray(moiety));
            return this;
        }

        public Builder property(final java.util.List<SubstanceSpecificationProperty> property) {
            b.add(FhirPropertyNames.PROPERTY_PROPERTY, FhirObject.toArray(property));
            return this;
        }

        public Builder referenceInformation(final Reference referenceInformation) {
            b.add(FhirPropertyNames.PROPERTY_REFERENCE_INFORMATION, referenceInformation);
            return this;
        }

        public Builder structure(final SubstanceSpecificationStructure structure) {
            b.add(FhirPropertyNames.PROPERTY_STRUCTURE, structure);
            return this;
        }

        public Builder code(final java.util.List<SubstanceSpecificationCode> code) {
            b.add(FhirPropertyNames.PROPERTY_CODE, FhirObject.toArray(code));
            return this;
        }

        public Builder name(final java.util.List<SubstanceSpecificationName> name) {
            b.add(FhirPropertyNames.PROPERTY_NAME, FhirObject.toArray(name));
            return this;
        }

        public Builder molecularWeight(final java.util.List<SubstanceSpecificationMolecularWeight> molecularWeight) {
            b.add(FhirPropertyNames.PROPERTY_MOLECULAR_WEIGHT, FhirObject.toArray(molecularWeight));
            return this;
        }

        public Builder relationship(final java.util.List<SubstanceSpecificationRelationship> relationship) {
            b.add(FhirPropertyNames.PROPERTY_RELATIONSHIP, FhirObject.toArray(relationship));
            return this;
        }

        public Builder nucleicAcid(final Reference nucleicAcid) {
            b.add(FhirPropertyNames.PROPERTY_NUCLEIC_ACID, nucleicAcid);
            return this;
        }

        public Builder polymer(final Reference polymer) {
            b.add(FhirPropertyNames.PROPERTY_POLYMER, polymer);
            return this;
        }

        public Builder protein(final Reference protein) {
            b.add(FhirPropertyNames.PROPERTY_PROTEIN, protein);
            return this;
        }

        public Builder sourceMaterial(final Reference sourceMaterial) {
            b.add(FhirPropertyNames.PROPERTY_SOURCE_MATERIAL, sourceMaterial);
            return this;
        }

        public SubstanceSpecification build() {
            return new SubstanceSpecification(b.build());
        }
    }

    /**
     * The detailed description of a substance, typically at a level beyond
     * what is used for prescribing.
     */
    public static class SubstanceSpecificationCode extends FhirObject {
        public static final String RESOURCE_TYPE = "SubstanceSpecificationCode";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public SubstanceSpecificationCode(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * The specific code.
         */
        public CodeableConcept code() {
            return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_CODE);
        }

        /**
         * Status of the code assignment.
         */
        public CodeableConcept status() {
            return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_STATUS);
        }

        /**
         * The date at which the code status is changed as part of the
         * terminology maintenance.
         */
        public java.time.Instant statusDate() {
            return getInstant(FhirPropertyNames.PROPERTY_STATUS_DATE);
        }

        /**
         * Any comment can be provided in this field, if necessary.
         */
        public String comment() {
            return getString(FhirPropertyNames.PROPERTY_COMMENT);
        }

        /**
         * Supporting literature.
         */
        public java.util.List<Reference> source() {
            return getList(Reference.class, FhirPropertyNames.PROPERTY_SOURCE);
        }

        public static final class Builder extends FhirObject.Builder<SubstanceSpecificationCode, SubstanceSpecificationCode.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder code(final CodeableConcept code) {
                b.add(FhirPropertyNames.PROPERTY_CODE, code);
                return this;
            }

            public Builder status(final CodeableConcept status) {
                b.add(FhirPropertyNames.PROPERTY_STATUS, status);
                return this;
            }

            public Builder statusDate(final java.time.Instant statusDate) {
                b.add(FhirPropertyNames.PROPERTY_STATUS_DATE, statusDate.toString());
                return this;
            }

            public Builder comment(final String comment) {
                b.add(FhirPropertyNames.PROPERTY_COMMENT, comment);
                return this;
            }

            public Builder source(final java.util.List<Reference> source) {
                b.add(FhirPropertyNames.PROPERTY_SOURCE, FhirObject.toArray(source));
                return this;
            }

            public SubstanceSpecificationCode build() {
                return new SubstanceSpecificationCode(b.build());
            }
        }
    }

    /**
     * The detailed description of a substance, typically at a level beyond
     * what is used for prescribing.
     */
    public static class SubstanceSpecificationIsotope extends FhirObject {
        public static final String RESOURCE_TYPE = "SubstanceSpecificationIsotope";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public SubstanceSpecificationIsotope(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Substance identifier for each non-natural or radioisotope.
         */
        public Identifier identifier() {
            return getObject(Identifier.class, FhirPropertyNames.PROPERTY_IDENTIFIER);
        }

        /**
         * Substance name for each non-natural or radioisotope.
         */
        public CodeableConcept name() {
            return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_NAME);
        }

        /**
         * The type of isotopic substitution present in a single substance.
         */
        public CodeableConcept substitution() {
            return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_SUBSTITUTION);
        }

        /**
         * Half life - for a non-natural nuclide.
         */
        public Quantity halfLife() {
            return getObject(Quantity.class, FhirPropertyNames.PROPERTY_HALF_LIFE);
        }

        /**
         * The molecular weight or weight range (for proteins, polymers or
         * nucleic acids).
         */
        public SubstanceSpecificationMolecularWeight molecularWeight() {
            return getObject(SubstanceSpecificationMolecularWeight.class, FhirPropertyNames.PROPERTY_MOLECULAR_WEIGHT);
        }

        public static final class Builder extends FhirObject.Builder<SubstanceSpecificationIsotope, SubstanceSpecificationIsotope.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder identifier(final Identifier identifier) {
                b.add(FhirPropertyNames.PROPERTY_IDENTIFIER, identifier);
                return this;
            }

            public Builder name(final CodeableConcept name) {
                b.add(FhirPropertyNames.PROPERTY_NAME, name);
                return this;
            }

            public Builder substitution(final CodeableConcept substitution) {
                b.add(FhirPropertyNames.PROPERTY_SUBSTITUTION, substitution);
                return this;
            }

            public Builder halfLife(final Quantity halfLife) {
                b.add(FhirPropertyNames.PROPERTY_HALF_LIFE, halfLife);
                return this;
            }

            public Builder molecularWeight(final SubstanceSpecificationMolecularWeight molecularWeight) {
                b.add(FhirPropertyNames.PROPERTY_MOLECULAR_WEIGHT, molecularWeight);
                return this;
            }

            public SubstanceSpecificationIsotope build() {
                return new SubstanceSpecificationIsotope(b.build());
            }
        }
    }

    /**
     * The detailed description of a substance, typically at a level beyond
     * what is used for prescribing.
     */
    public static class SubstanceSpecificationMoiety extends FhirObject {
        public static final String RESOURCE_TYPE = "SubstanceSpecificationMoiety";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public SubstanceSpecificationMoiety(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Role that the moiety is playing.
         */
        public CodeableConcept role() {
            return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_ROLE);
        }

        /**
         * Identifier by which this moiety substance is known.
         */
        public Identifier identifier() {
            return getObject(Identifier.class, FhirPropertyNames.PROPERTY_IDENTIFIER);
        }

        /**
         * Textual name for this moiety substance.
         */
        public String name() {
            return getString(FhirPropertyNames.PROPERTY_NAME);
        }

        /**
         * Stereochemistry type.
         */
        public CodeableConcept stereochemistry() {
            return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_STEREOCHEMISTRY);
        }

        /**
         * Optical activity type.
         */
        public CodeableConcept opticalActivity() {
            return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_OPTICAL_ACTIVITY);
        }

        /**
         * Molecular formula.
         */
        public String molecularFormula() {
            return getString(FhirPropertyNames.PROPERTY_MOLECULAR_FORMULA);
        }

        /**
         * Quantitative value for this moiety.
         */
        public Quantity amountQuantity() {
            return getObject(Quantity.class, FhirPropertyNames.PROPERTY_AMOUNT_QUANTITY);
        }

        /**
         * Quantitative value for this moiety.
         */
        public String amountString() {
            return getString(FhirPropertyNames.PROPERTY_AMOUNT_STRING);
        }

        public static final class Builder extends FhirObject.Builder<SubstanceSpecificationMoiety, SubstanceSpecificationMoiety.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder role(final CodeableConcept role) {
                b.add(FhirPropertyNames.PROPERTY_ROLE, role);
                return this;
            }

            public Builder identifier(final Identifier identifier) {
                b.add(FhirPropertyNames.PROPERTY_IDENTIFIER, identifier);
                return this;
            }

            public Builder name(final String name) {
                b.add(FhirPropertyNames.PROPERTY_NAME, name);
                return this;
            }

            public Builder stereochemistry(final CodeableConcept stereochemistry) {
                b.add(FhirPropertyNames.PROPERTY_STEREOCHEMISTRY, stereochemistry);
                return this;
            }

            public Builder opticalActivity(final CodeableConcept opticalActivity) {
                b.add(FhirPropertyNames.PROPERTY_OPTICAL_ACTIVITY, opticalActivity);
                return this;
            }

            public Builder molecularFormula(final String molecularFormula) {
                b.add(FhirPropertyNames.PROPERTY_MOLECULAR_FORMULA, molecularFormula);
                return this;
            }

            public Builder amountQuantity(final Quantity amountQuantity) {
                b.add(FhirPropertyNames.PROPERTY_AMOUNT_QUANTITY, amountQuantity);
                return this;
            }

            public Builder amountString(final String amountString) {
                b.add(FhirPropertyNames.PROPERTY_AMOUNT_STRING, amountString);
                return this;
            }

            public SubstanceSpecificationMoiety build() {
                return new SubstanceSpecificationMoiety(b.build());
            }
        }
    }

    /**
     * The detailed description of a substance, typically at a level beyond
     * what is used for prescribing.
     */
    public static class SubstanceSpecificationMolecularWeight extends FhirObject {
        public static final String RESOURCE_TYPE = "SubstanceSpecificationMolecularWeight";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public SubstanceSpecificationMolecularWeight(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * The method by which the molecular weight was determined.
         */
        public CodeableConcept method() {
            return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_METHOD);
        }

        /**
         * Type of molecular weight such as exact, average (also known as. number
         * average), weight average.
         */
        public CodeableConcept type() {
            return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_TYPE);
        }

        /**
         * Used to capture quantitative values for a variety of elements. If only
         * limits are given, the arithmetic mean would be the average. If only a
         * single definite value for a given element is given, it would be
         * captured in this field.
         */
        public Quantity amount() {
            return getObject(Quantity.class, FhirPropertyNames.PROPERTY_AMOUNT);
        }

        public static final class Builder extends FhirObject.Builder<SubstanceSpecificationMolecularWeight, SubstanceSpecificationMolecularWeight.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder method(final CodeableConcept method) {
                b.add(FhirPropertyNames.PROPERTY_METHOD, method);
                return this;
            }

            public Builder type(final CodeableConcept type) {
                b.add(FhirPropertyNames.PROPERTY_TYPE, type);
                return this;
            }

            public Builder amount(final Quantity amount) {
                b.add(FhirPropertyNames.PROPERTY_AMOUNT, amount);
                return this;
            }

            public SubstanceSpecificationMolecularWeight build() {
                return new SubstanceSpecificationMolecularWeight(b.build());
            }
        }
    }

    /**
     * The detailed description of a substance, typically at a level beyond
     * what is used for prescribing.
     */
    public static class SubstanceSpecificationName extends FhirObject {
        public static final String RESOURCE_TYPE = "SubstanceSpecificationName";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public SubstanceSpecificationName(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * The actual name.
         */
        public String name() {
            return getString(FhirPropertyNames.PROPERTY_NAME);
        }

        /**
         * Name type.
         */
        public CodeableConcept type() {
            return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_TYPE);
        }

        /**
         * The status of the name.
         */
        public CodeableConcept status() {
            return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_STATUS);
        }

        /**
         * If this is the preferred name for this substance.
         */
        public Boolean preferred() {
            return data.getBoolean(FhirPropertyNames.PROPERTY_PREFERRED);
        }

        /**
         * Language of the name.
         */
        public java.util.List<CodeableConcept> language() {
            return getList(CodeableConcept.class, FhirPropertyNames.PROPERTY_LANGUAGE);
        }

        /**
         * The use context of this name for example if there is a different name
         * a drug active ingredient as opposed to a food colour additive.
         */
        public java.util.List<CodeableConcept> domain() {
            return getList(CodeableConcept.class, FhirPropertyNames.PROPERTY_DOMAIN);
        }

        /**
         * The jurisdiction where this name applies.
         */
        public java.util.List<CodeableConcept> jurisdiction() {
            return getList(CodeableConcept.class, FhirPropertyNames.PROPERTY_JURISDICTION);
        }

        /**
         * A synonym of this name.
         */
        public java.util.List<SubstanceSpecificationName> synonym() {
            return getList(SubstanceSpecificationName.class, FhirPropertyNames.PROPERTY_SYNONYM);
        }

        /**
         * A translation for this name.
         */
        public java.util.List<SubstanceSpecificationName> translation() {
            return getList(SubstanceSpecificationName.class, FhirPropertyNames.PROPERTY_TRANSLATION);
        }

        /**
         * Details of the official nature of this name.
         */
        public java.util.List<SubstanceSpecificationOfficial> official() {
            return getList(SubstanceSpecificationOfficial.class, FhirPropertyNames.PROPERTY_OFFICIAL);
        }

        /**
         * Supporting literature.
         */
        public java.util.List<Reference> source() {
            return getList(Reference.class, FhirPropertyNames.PROPERTY_SOURCE);
        }

        public static final class Builder extends FhirObject.Builder<SubstanceSpecificationName, SubstanceSpecificationName.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder name(final String name) {
                b.add(FhirPropertyNames.PROPERTY_NAME, name);
                return this;
            }

            public Builder type(final CodeableConcept type) {
                b.add(FhirPropertyNames.PROPERTY_TYPE, type);
                return this;
            }

            public Builder status(final CodeableConcept status) {
                b.add(FhirPropertyNames.PROPERTY_STATUS, status);
                return this;
            }

            public Builder preferred(final Boolean preferred) {
                b.add(FhirPropertyNames.PROPERTY_PREFERRED, preferred);
                return this;
            }

            public Builder language(final java.util.List<CodeableConcept> language) {
                b.add(FhirPropertyNames.PROPERTY_LANGUAGE, FhirObject.toArray(language));
                return this;
            }

            public Builder domain(final java.util.List<CodeableConcept> domain) {
                b.add(FhirPropertyNames.PROPERTY_DOMAIN, FhirObject.toArray(domain));
                return this;
            }

            public Builder jurisdiction(final java.util.List<CodeableConcept> jurisdiction) {
                b.add(FhirPropertyNames.PROPERTY_JURISDICTION, FhirObject.toArray(jurisdiction));
                return this;
            }

            public Builder synonym(final java.util.List<SubstanceSpecificationName> synonym) {
                b.add(FhirPropertyNames.PROPERTY_SYNONYM, FhirObject.toArray(synonym));
                return this;
            }

            public Builder translation(final java.util.List<SubstanceSpecificationName> translation) {
                b.add(FhirPropertyNames.PROPERTY_TRANSLATION, FhirObject.toArray(translation));
                return this;
            }

            public Builder official(final java.util.List<SubstanceSpecificationOfficial> official) {
                b.add(FhirPropertyNames.PROPERTY_OFFICIAL, FhirObject.toArray(official));
                return this;
            }

            public Builder source(final java.util.List<Reference> source) {
                b.add(FhirPropertyNames.PROPERTY_SOURCE, FhirObject.toArray(source));
                return this;
            }

            public SubstanceSpecificationName build() {
                return new SubstanceSpecificationName(b.build());
            }
        }
    }

    /**
     * The detailed description of a substance, typically at a level beyond
     * what is used for prescribing.
     */
    public static class SubstanceSpecificationOfficial extends FhirObject {
        public static final String RESOURCE_TYPE = "SubstanceSpecificationOfficial";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public SubstanceSpecificationOfficial(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Which authority uses this official name.
         */
        public CodeableConcept authority() {
            return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_AUTHORITY);
        }

        /**
         * The status of the official name.
         */
        public CodeableConcept status() {
            return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_STATUS);
        }

        /**
         * Date of official name change.
         */
        public java.time.Instant date() {
            return getInstant(FhirPropertyNames.PROPERTY_DATE);
        }

        public static final class Builder extends FhirObject.Builder<SubstanceSpecificationOfficial, SubstanceSpecificationOfficial.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder authority(final CodeableConcept authority) {
                b.add(FhirPropertyNames.PROPERTY_AUTHORITY, authority);
                return this;
            }

            public Builder status(final CodeableConcept status) {
                b.add(FhirPropertyNames.PROPERTY_STATUS, status);
                return this;
            }

            public Builder date(final java.time.Instant date) {
                b.add(FhirPropertyNames.PROPERTY_DATE, date.toString());
                return this;
            }

            public SubstanceSpecificationOfficial build() {
                return new SubstanceSpecificationOfficial(b.build());
            }
        }
    }

    /**
     * The detailed description of a substance, typically at a level beyond
     * what is used for prescribing.
     */
    public static class SubstanceSpecificationProperty extends FhirObject {
        public static final String RESOURCE_TYPE = "SubstanceSpecificationProperty";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public SubstanceSpecificationProperty(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * A category for this property, e.g. Physical, Chemical, Enzymatic.
         */
        public CodeableConcept category() {
            return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_CATEGORY);
        }

        /**
         * Property type e.g. viscosity, pH, isoelectric point.
         */
        public CodeableConcept code() {
            return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_CODE);
        }

        /**
         * Parameters that were used in the measurement of a property (e.g. for
         * viscosity: measured at 20C with a pH of 7.1).
         */
        public String parameters() {
            return getString(FhirPropertyNames.PROPERTY_PARAMETERS);
        }

        /**
         * A substance upon which a defining property depends (e.g. for
         * solubility: in water, in alcohol).
         */
        public Reference definingSubstanceReference() {
            return getObject(Reference.class, FhirPropertyNames.PROPERTY_DEFINING_SUBSTANCE_REFERENCE);
        }

        /**
         * A substance upon which a defining property depends (e.g. for
         * solubility: in water, in alcohol).
         */
        public CodeableConcept definingSubstanceCodeableConcept() {
            return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_DEFINING_SUBSTANCE_CODEABLE_CONCEPT);
        }

        /**
         * Quantitative value for this property.
         */
        public Quantity amountQuantity() {
            return getObject(Quantity.class, FhirPropertyNames.PROPERTY_AMOUNT_QUANTITY);
        }

        /**
         * Quantitative value for this property.
         */
        public String amountString() {
            return getString(FhirPropertyNames.PROPERTY_AMOUNT_STRING);
        }

        public static final class Builder extends FhirObject.Builder<SubstanceSpecificationProperty, SubstanceSpecificationProperty.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder category(final CodeableConcept category) {
                b.add(FhirPropertyNames.PROPERTY_CATEGORY, category);
                return this;
            }

            public Builder code(final CodeableConcept code) {
                b.add(FhirPropertyNames.PROPERTY_CODE, code);
                return this;
            }

            public Builder parameters(final String parameters) {
                b.add(FhirPropertyNames.PROPERTY_PARAMETERS, parameters);
                return this;
            }

            public Builder definingSubstanceReference(final Reference definingSubstanceReference) {
                b.add(FhirPropertyNames.PROPERTY_DEFINING_SUBSTANCE_REFERENCE, definingSubstanceReference);
                return this;
            }

            public Builder definingSubstanceCodeableConcept(final CodeableConcept definingSubstanceCodeableConcept) {
                b.add(FhirPropertyNames.PROPERTY_DEFINING_SUBSTANCE_CODEABLE_CONCEPT, definingSubstanceCodeableConcept);
                return this;
            }

            public Builder amountQuantity(final Quantity amountQuantity) {
                b.add(FhirPropertyNames.PROPERTY_AMOUNT_QUANTITY, amountQuantity);
                return this;
            }

            public Builder amountString(final String amountString) {
                b.add(FhirPropertyNames.PROPERTY_AMOUNT_STRING, amountString);
                return this;
            }

            public SubstanceSpecificationProperty build() {
                return new SubstanceSpecificationProperty(b.build());
            }
        }
    }

    /**
     * The detailed description of a substance, typically at a level beyond
     * what is used for prescribing.
     */
    public static class SubstanceSpecificationRelationship extends FhirObject {
        public static final String RESOURCE_TYPE = "SubstanceSpecificationRelationship";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public SubstanceSpecificationRelationship(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * A pointer to another substance, as a resource or just a
         * representational code.
         */
        public Reference substanceReference() {
            return getObject(Reference.class, FhirPropertyNames.PROPERTY_SUBSTANCE_REFERENCE);
        }

        /**
         * A pointer to another substance, as a resource or just a
         * representational code.
         */
        public CodeableConcept substanceCodeableConcept() {
            return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_SUBSTANCE_CODEABLE_CONCEPT);
        }

        /**
         * For example &quot;salt to parent&quot;, &quot;active moiety&quot;, &quot;starting material&quot;.
         */
        public CodeableConcept relationship() {
            return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_RELATIONSHIP);
        }

        /**
         * For example where an enzyme strongly bonds with a particular
         * substance, this is a defining relationship for that enzyme, out of
         * several possible substance relationships.
         */
        public Boolean isDefining() {
            return data.getBoolean(FhirPropertyNames.PROPERTY_IS_DEFINING);
        }

        /**
         * A numeric factor for the relationship, for instance to express that
         * the salt of a substance has some percentage of the active substance in
         * relation to some other.
         */
        public Quantity amountQuantity() {
            return getObject(Quantity.class, FhirPropertyNames.PROPERTY_AMOUNT_QUANTITY);
        }

        /**
         * A numeric factor for the relationship, for instance to express that
         * the salt of a substance has some percentage of the active substance in
         * relation to some other.
         */
        public Range amountRange() {
            return getObject(Range.class, FhirPropertyNames.PROPERTY_AMOUNT_RANGE);
        }

        /**
         * A numeric factor for the relationship, for instance to express that
         * the salt of a substance has some percentage of the active substance in
         * relation to some other.
         */
        public Ratio amountRatio() {
            return getObject(Ratio.class, FhirPropertyNames.PROPERTY_AMOUNT_RATIO);
        }

        /**
         * A numeric factor for the relationship, for instance to express that
         * the salt of a substance has some percentage of the active substance in
         * relation to some other.
         */
        public String amountString() {
            return getString(FhirPropertyNames.PROPERTY_AMOUNT_STRING);
        }

        /**
         * For use when the numeric.
         */
        public Ratio amountRatioLowLimit() {
            return getObject(Ratio.class, FhirPropertyNames.PROPERTY_AMOUNT_RATIO_LOW_LIMIT);
        }

        /**
         * An operator for the amount, for example &quot;average&quot;, &quot;approximately&quot;,
         * &quot;less than&quot;.
         */
        public CodeableConcept amountType() {
            return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_AMOUNT_TYPE);
        }

        /**
         * Supporting literature.
         */
        public java.util.List<Reference> source() {
            return getList(Reference.class, FhirPropertyNames.PROPERTY_SOURCE);
        }

        public static final class Builder extends FhirObject.Builder<SubstanceSpecificationRelationship, SubstanceSpecificationRelationship.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder substanceReference(final Reference substanceReference) {
                b.add(FhirPropertyNames.PROPERTY_SUBSTANCE_REFERENCE, substanceReference);
                return this;
            }

            public Builder substanceCodeableConcept(final CodeableConcept substanceCodeableConcept) {
                b.add(FhirPropertyNames.PROPERTY_SUBSTANCE_CODEABLE_CONCEPT, substanceCodeableConcept);
                return this;
            }

            public Builder relationship(final CodeableConcept relationship) {
                b.add(FhirPropertyNames.PROPERTY_RELATIONSHIP, relationship);
                return this;
            }

            public Builder isDefining(final Boolean isDefining) {
                b.add(FhirPropertyNames.PROPERTY_IS_DEFINING, isDefining);
                return this;
            }

            public Builder amountQuantity(final Quantity amountQuantity) {
                b.add(FhirPropertyNames.PROPERTY_AMOUNT_QUANTITY, amountQuantity);
                return this;
            }

            public Builder amountRange(final Range amountRange) {
                b.add(FhirPropertyNames.PROPERTY_AMOUNT_RANGE, amountRange);
                return this;
            }

            public Builder amountRatio(final Ratio amountRatio) {
                b.add(FhirPropertyNames.PROPERTY_AMOUNT_RATIO, amountRatio);
                return this;
            }

            public Builder amountString(final String amountString) {
                b.add(FhirPropertyNames.PROPERTY_AMOUNT_STRING, amountString);
                return this;
            }

            public Builder amountRatioLowLimit(final Ratio amountRatioLowLimit) {
                b.add(FhirPropertyNames.PROPERTY_AMOUNT_RATIO_LOW_LIMIT, amountRatioLowLimit);
                return this;
            }

            public Builder amountType(final CodeableConcept amountType) {
                b.add(FhirPropertyNames.PROPERTY_AMOUNT_TYPE, amountType);
                return this;
            }

            public Builder source(final java.util.List<Reference> source) {
                b.add(FhirPropertyNames.PROPERTY_SOURCE, FhirObject.toArray(source));
                return this;
            }

            public SubstanceSpecificationRelationship build() {
                return new SubstanceSpecificationRelationship(b.build());
            }
        }
    }

    /**
     * The detailed description of a substance, typically at a level beyond
     * what is used for prescribing.
     */
    public static class SubstanceSpecificationRepresentation extends FhirObject {
        public static final String RESOURCE_TYPE = "SubstanceSpecificationRepresentation";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public SubstanceSpecificationRepresentation(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * The type of structure (e.g. Full, Partial, Representative).
         */
        public CodeableConcept type() {
            return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_TYPE);
        }

        /**
         * The structural representation as text string in a format e.g. InChI,
         * SMILES, MOLFILE, CDX.
         */
        public String representation() {
            return getString(FhirPropertyNames.PROPERTY_REPRESENTATION);
        }

        /**
         * An attached file with the structural representation.
         */
        public Attachment attachment() {
            return getObject(Attachment.class, FhirPropertyNames.PROPERTY_ATTACHMENT);
        }

        public static final class Builder extends FhirObject.Builder<SubstanceSpecificationRepresentation, SubstanceSpecificationRepresentation.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder type(final CodeableConcept type) {
                b.add(FhirPropertyNames.PROPERTY_TYPE, type);
                return this;
            }

            public Builder representation(final String representation) {
                b.add(FhirPropertyNames.PROPERTY_REPRESENTATION, representation);
                return this;
            }

            public Builder attachment(final Attachment attachment) {
                b.add(FhirPropertyNames.PROPERTY_ATTACHMENT, attachment);
                return this;
            }

            public SubstanceSpecificationRepresentation build() {
                return new SubstanceSpecificationRepresentation(b.build());
            }
        }
    }

    /**
     * The detailed description of a substance, typically at a level beyond
     * what is used for prescribing.
     */
    public static class SubstanceSpecificationStructure extends FhirObject {
        public static final String RESOURCE_TYPE = "SubstanceSpecificationStructure";

        public static Builder create() {
            return new Builder();
        }

        public static Builder create(final JsonObject data) {
            return new Builder(data);
        }

        public SubstanceSpecificationStructure(final JsonObject data) {
            super(data);
        }

        /**
         * Unique id for the element within a resource (for internal references).
         * This may be any string value that does not contain spaces.
         */
        public String id() {
            return getString(FhirPropertyNames.PROPERTY_ID);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element. To make the use of extensions
         * safe and manageable, there is a strict set of governance  applied to
         * the definition and use of extensions. Though any implementer can
         * define an extension, there is a set of requirements that SHALL be met
         * as part of the definition of the extension.
         */
        public java.util.List<Extension> extension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
        }

        /**
         * May be used to represent additional information that is not part of
         * the basic definition of the element and that modifies the
         * understanding of the element in which it is contained and/or the
         * understanding of the containing element's descendants. Usually
         * modifier elements provide negation or qualification. To make the use
         * of extensions safe and manageable, there is a strict set of governance
         * applied to the definition and use of extensions. Though any
         * implementer can define an extension, there is a set of requirements
         * that SHALL be met as part of the definition of the extension.
         * Applications processing a resource are required to check for modifier
         * extensions.
         *
         * Modifier extensions SHALL NOT change the meaning of any elements on
         * Resource or DomainResource (including cannot change the meaning of
         * modifierExtension itself).
         */
        public java.util.List<Extension> modifierExtension() {
            return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
        }

        /**
         * Stereochemistry type.
         */
        public CodeableConcept stereochemistry() {
            return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_STEREOCHEMISTRY);
        }

        /**
         * Optical activity type.
         */
        public CodeableConcept opticalActivity() {
            return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_OPTICAL_ACTIVITY);
        }

        /**
         * Molecular formula.
         */
        public String molecularFormula() {
            return getString(FhirPropertyNames.PROPERTY_MOLECULAR_FORMULA);
        }

        /**
         * Specified per moiety according to the Hill system, i.e. first C, then
         * H, then alphabetical, each moiety separated by a dot.
         */
        public String molecularFormulaByMoiety() {
            return getString(FhirPropertyNames.PROPERTY_MOLECULAR_FORMULA_BY_MOIETY);
        }

        /**
         * Applicable for single substances that contain a radionuclide or a
         * non-natural isotopic ratio.
         */
        public java.util.List<SubstanceSpecificationIsotope> isotope() {
            return getList(SubstanceSpecificationIsotope.class, FhirPropertyNames.PROPERTY_ISOTOPE);
        }

        /**
         * The molecular weight or weight range (for proteins, polymers or
         * nucleic acids).
         */
        public SubstanceSpecificationMolecularWeight molecularWeight() {
            return getObject(SubstanceSpecificationMolecularWeight.class, FhirPropertyNames.PROPERTY_MOLECULAR_WEIGHT);
        }

        /**
         * Supporting literature.
         */
        public java.util.List<Reference> source() {
            return getList(Reference.class, FhirPropertyNames.PROPERTY_SOURCE);
        }

        /**
         * Molecular structural representation.
         */
        public java.util.List<SubstanceSpecificationRepresentation> representation() {
            return getList(SubstanceSpecificationRepresentation.class, FhirPropertyNames.PROPERTY_REPRESENTATION);
        }

        public static final class Builder extends FhirObject.Builder<SubstanceSpecificationStructure, SubstanceSpecificationStructure.Builder> {

            private Builder() {
                super();
            }

            private Builder(final JsonObject data) {
                super(data);
            }

            public Builder id(final String id) {
                b.add(FhirPropertyNames.PROPERTY_ID, id);
                return this;
            }

            public Builder extension(final java.util.List<Extension> extension) {
                b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
                return this;
            }

            public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
                b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
                return this;
            }

            public Builder stereochemistry(final CodeableConcept stereochemistry) {
                b.add(FhirPropertyNames.PROPERTY_STEREOCHEMISTRY, stereochemistry);
                return this;
            }

            public Builder opticalActivity(final CodeableConcept opticalActivity) {
                b.add(FhirPropertyNames.PROPERTY_OPTICAL_ACTIVITY, opticalActivity);
                return this;
            }

            public Builder molecularFormula(final String molecularFormula) {
                b.add(FhirPropertyNames.PROPERTY_MOLECULAR_FORMULA, molecularFormula);
                return this;
            }

            public Builder molecularFormulaByMoiety(final String molecularFormulaByMoiety) {
                b.add(FhirPropertyNames.PROPERTY_MOLECULAR_FORMULA_BY_MOIETY, molecularFormulaByMoiety);
                return this;
            }

            public Builder isotope(final java.util.List<SubstanceSpecificationIsotope> isotope) {
                b.add(FhirPropertyNames.PROPERTY_ISOTOPE, FhirObject.toArray(isotope));
                return this;
            }

            public Builder molecularWeight(final SubstanceSpecificationMolecularWeight molecularWeight) {
                b.add(FhirPropertyNames.PROPERTY_MOLECULAR_WEIGHT, molecularWeight);
                return this;
            }

            public Builder source(final java.util.List<Reference> source) {
                b.add(FhirPropertyNames.PROPERTY_SOURCE, FhirObject.toArray(source));
                return this;
            }

            public Builder representation(final java.util.List<SubstanceSpecificationRepresentation> representation) {
                b.add(FhirPropertyNames.PROPERTY_REPRESENTATION, FhirObject.toArray(representation));
                return this;
            }

            public SubstanceSpecificationStructure build() {
                return new SubstanceSpecificationStructure(b.build());
            }
        }
    }
}
