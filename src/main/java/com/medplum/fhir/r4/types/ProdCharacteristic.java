/*
 * Generated by com.medplum.generator.Generator
 * Do not edit manually.
 */

package com.medplum.fhir.r4.types;

import jakarta.json.JsonObject;

import com.medplum.fhir.r4.FhirPropertyNames;

/**
 * The marketing status describes the date when a medicinal product is
 * actually put on the market or the date as of which it is no longer
 * available.
 */
public class ProdCharacteristic extends FhirObject {
    public static final String RESOURCE_TYPE = "ProdCharacteristic";

    public static Builder create() {
        return new Builder();
    }

    public static Builder create(final JsonObject data) {
        return new Builder(data);
    }

    public ProdCharacteristic(final JsonObject data) {
        super(data);
    }

    /**
     * Unique id for the element within a resource (for internal references).
     * This may be any string value that does not contain spaces.
     */
    public String id() {
        return getString(FhirPropertyNames.PROPERTY_ID);
    }

    /**
     * May be used to represent additional information that is not part of
     * the basic definition of the element. To make the use of extensions
     * safe and manageable, there is a strict set of governance  applied to
     * the definition and use of extensions. Though any implementer can
     * define an extension, there is a set of requirements that SHALL be met
     * as part of the definition of the extension.
     */
    public java.util.List<Extension> extension() {
        return getList(Extension.class, FhirPropertyNames.PROPERTY_EXTENSION);
    }

    /**
     * May be used to represent additional information that is not part of
     * the basic definition of the element and that modifies the
     * understanding of the element in which it is contained and/or the
     * understanding of the containing element's descendants. Usually
     * modifier elements provide negation or qualification. To make the use
     * of extensions safe and manageable, there is a strict set of governance
     * applied to the definition and use of extensions. Though any
     * implementer can define an extension, there is a set of requirements
     * that SHALL be met as part of the definition of the extension.
     * Applications processing a resource are required to check for modifier
     * extensions.
     *
     * Modifier extensions SHALL NOT change the meaning of any elements on
     * Resource or DomainResource (including cannot change the meaning of
     * modifierExtension itself).
     */
    public java.util.List<Extension> modifierExtension() {
        return getList(Extension.class, FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION);
    }

    /**
     * Where applicable, the height can be specified using a numerical value
     * and its unit of measurement The unit of measurement shall be specified
     * in accordance with ISO 11240 and the resulting terminology The symbol
     * and the symbol identifier shall be used.
     */
    public Quantity height() {
        return getObject(Quantity.class, FhirPropertyNames.PROPERTY_HEIGHT);
    }

    /**
     * Where applicable, the width can be specified using a numerical value
     * and its unit of measurement The unit of measurement shall be specified
     * in accordance with ISO 11240 and the resulting terminology The symbol
     * and the symbol identifier shall be used.
     */
    public Quantity width() {
        return getObject(Quantity.class, FhirPropertyNames.PROPERTY_WIDTH);
    }

    /**
     * Where applicable, the depth can be specified using a numerical value
     * and its unit of measurement The unit of measurement shall be specified
     * in accordance with ISO 11240 and the resulting terminology The symbol
     * and the symbol identifier shall be used.
     */
    public Quantity depth() {
        return getObject(Quantity.class, FhirPropertyNames.PROPERTY_DEPTH);
    }

    /**
     * Where applicable, the weight can be specified using a numerical value
     * and its unit of measurement The unit of measurement shall be specified
     * in accordance with ISO 11240 and the resulting terminology The symbol
     * and the symbol identifier shall be used.
     */
    public Quantity weight() {
        return getObject(Quantity.class, FhirPropertyNames.PROPERTY_WEIGHT);
    }

    /**
     * Where applicable, the nominal volume can be specified using a
     * numerical value and its unit of measurement The unit of measurement
     * shall be specified in accordance with ISO 11240 and the resulting
     * terminology The symbol and the symbol identifier shall be used.
     */
    public Quantity nominalVolume() {
        return getObject(Quantity.class, FhirPropertyNames.PROPERTY_NOMINAL_VOLUME);
    }

    /**
     * Where applicable, the external diameter can be specified using a
     * numerical value and its unit of measurement The unit of measurement
     * shall be specified in accordance with ISO 11240 and the resulting
     * terminology The symbol and the symbol identifier shall be used.
     */
    public Quantity externalDiameter() {
        return getObject(Quantity.class, FhirPropertyNames.PROPERTY_EXTERNAL_DIAMETER);
    }

    /**
     * Where applicable, the shape can be specified An appropriate controlled
     * vocabulary shall be used The term and the term identifier shall be
     * used.
     */
    public String shape() {
        return getString(FhirPropertyNames.PROPERTY_SHAPE);
    }

    /**
     * Where applicable, the color can be specified An appropriate controlled
     * vocabulary shall be used The term and the term identifier shall be
     * used.
     */
    public java.util.List<String> color() {
        return getList(String.class, FhirPropertyNames.PROPERTY_COLOR);
    }

    /**
     * Where applicable, the imprint can be specified as text.
     */
    public java.util.List<String> imprint() {
        return getList(String.class, FhirPropertyNames.PROPERTY_IMPRINT);
    }

    /**
     * Where applicable, the image can be provided The format of the image
     * attachment shall be specified by regional implementations.
     */
    public java.util.List<Attachment> image() {
        return getList(Attachment.class, FhirPropertyNames.PROPERTY_IMAGE);
    }

    /**
     * Where applicable, the scoring can be specified An appropriate
     * controlled vocabulary shall be used The term and the term identifier
     * shall be used.
     */
    public CodeableConcept scoring() {
        return getObject(CodeableConcept.class, FhirPropertyNames.PROPERTY_SCORING);
    }

    public static final class Builder extends FhirObject.Builder<ProdCharacteristic, ProdCharacteristic.Builder> {

        private Builder() {
            super();
        }

        private Builder(final JsonObject data) {
            super(data);
        }

        public Builder id(final String id) {
            b.add(FhirPropertyNames.PROPERTY_ID, id);
            return this;
        }

        public Builder extension(final java.util.List<Extension> extension) {
            b.add(FhirPropertyNames.PROPERTY_EXTENSION, FhirObject.toArray(extension));
            return this;
        }

        public Builder modifierExtension(final java.util.List<Extension> modifierExtension) {
            b.add(FhirPropertyNames.PROPERTY_MODIFIER_EXTENSION, FhirObject.toArray(modifierExtension));
            return this;
        }

        public Builder height(final Quantity height) {
            b.add(FhirPropertyNames.PROPERTY_HEIGHT, height);
            return this;
        }

        public Builder width(final Quantity width) {
            b.add(FhirPropertyNames.PROPERTY_WIDTH, width);
            return this;
        }

        public Builder depth(final Quantity depth) {
            b.add(FhirPropertyNames.PROPERTY_DEPTH, depth);
            return this;
        }

        public Builder weight(final Quantity weight) {
            b.add(FhirPropertyNames.PROPERTY_WEIGHT, weight);
            return this;
        }

        public Builder nominalVolume(final Quantity nominalVolume) {
            b.add(FhirPropertyNames.PROPERTY_NOMINAL_VOLUME, nominalVolume);
            return this;
        }

        public Builder externalDiameter(final Quantity externalDiameter) {
            b.add(FhirPropertyNames.PROPERTY_EXTERNAL_DIAMETER, externalDiameter);
            return this;
        }

        public Builder shape(final String shape) {
            b.add(FhirPropertyNames.PROPERTY_SHAPE, shape);
            return this;
        }

        public Builder color(final java.util.List<String> color) {
            b.add(FhirPropertyNames.PROPERTY_COLOR, FhirObject.toStringArray(color));
            return this;
        }

        public Builder imprint(final java.util.List<String> imprint) {
            b.add(FhirPropertyNames.PROPERTY_IMPRINT, FhirObject.toStringArray(imprint));
            return this;
        }

        public Builder image(final java.util.List<Attachment> image) {
            b.add(FhirPropertyNames.PROPERTY_IMAGE, FhirObject.toArray(image));
            return this;
        }

        public Builder scoring(final CodeableConcept scoring) {
            b.add(FhirPropertyNames.PROPERTY_SCORING, scoring);
            return this;
        }

        public ProdCharacteristic build() {
            return new ProdCharacteristic(b.build());
        }
    }
}
